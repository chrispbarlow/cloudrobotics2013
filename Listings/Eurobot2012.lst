
Eurobot2012.elf:     file format elf32-littlemips


Disassembly of section .text:

20000000 <_text>:
   .extern _etext
   .extern _ebss
   .extern Handle_Interrupts

   .set noreorder
		nop
20000000:	00000000 	nop
        j _startup            # Reset vector
20000004:	08000005 	j	20000014 <_startup>
        nop
20000008:	00000000 	nop

        j Handler            # Interrupt vector
2000000c:	08000b73 	j	20002dcc <Handler>
        nop
20000010:	00000000 	nop

20000014 <_startup>:

   .func   _startup
_startup:                     # Start of code section
/* Set global pointer register */
        la $28, _gp
20000014:	3c1c4000 	lui	gp,0x4000
20000018:	279c041c 	addiu	gp,gp,1052

/* Set the stack pointer */
        la $t0, USR_Stk_Base_Val
2000001c:	3c084000 	lui	t0,0x4000
20000020:	35083e00 	ori	t0,t0,0x3e00
        move $sp, $t0
20000024:	0100e821 	move	sp,t0

        mtc0 $sp, $25         # Save CP0 Status Reg
20000028:	409dc800 	mtc0	sp,$25

/* Fill the stack */
        la $3, Top_Stack - 4
2000002c:	3c034000 	lui	v1,0x4000
20000030:	34633ffc 	ori	v1,v1,0x3ffc
        la $4, Top_Stack -IRQ_Stk -USR_Stk
20000034:	3c044000 	lui	a0,0x4000
20000038:	34843600 	ori	a0,a0,0x3600
        la $5, 0xDEC0ADDE
2000003c:	3c05dec0 	lui	a1,0xdec0
20000040:	34a5adde 	ori	a1,a1,0xadde

20000044 <Stk_fill>:
Stk_fill:
		sw $5, 0($4)
20000044:	ac850000 	sw	a1,0(a0)
		slt $2, $4, $3
20000048:	0083102a 	slt	v0,a0,v1
		bnez $2, Stk_fill
2000004c:	1440fffd 	bnez	v0,20000044 <Stk_fill>
		addiu $4, $4, 4
20000050:	24840004 	addiu	a0,a0,4
/* End of stack-filler */

		/* Special value at the bottom of the interrupt stack */
		la $4, Top_Stack -IRQ_Stk
20000054:	3c044000 	lui	a0,0x4000
20000058:	34843e00 	ori	a0,a0,0x3e00
		la $5, INT_Stk_Val
2000005c:	3c054000 	lui	a1,0x4000
20000060:	24a5037c 	addiu	a1,a1,892
		lw $5, 0($5)
20000064:	8ca50000 	lw	a1,0(a1)
		nop
20000068:	00000000 	nop
		sw $5, 0($4)
2000006c:	ac850000 	sw	a1,0(a0)

		/* Special value at the bottom of the user stack */
		la $4, Top_Stack -IRQ_Stk -USR_Stk
20000070:	3c044000 	lui	a0,0x4000
20000074:	34843600 	ori	a0,a0,0x3600
		la $5, USR_Stk_Val
20000078:	3c054000 	lui	a1,0x4000
2000007c:	24a50378 	addiu	a1,a1,888
		lw $5, 0($5)
20000080:	8ca50000 	lw	a1,0(a1)
		nop
20000084:	00000000 	nop
		sw $5, 0($4)
20000088:	ac850000 	sw	a1,0(a0)

        la $4, _etext
2000008c:	3c042000 	lui	a0,0x2000
20000090:	24845114 	addiu	a0,a0,20756
        la $5, _text
20000094:	3c052000 	lui	a1,0x2000
20000098:	24a50000 	addiu	a1,a1,0
        subu $4, $4, $5
2000009c:	00852023 	subu	a0,a0,a1
        la $5, _edata
200000a0:	3c054000 	lui	a1,0x4000
200000a4:	24a5041c 	addiu	a1,a1,1052
        la $6, _data
200000a8:	3c064000 	lui	a2,0x4000
200000ac:	24c60000 	addiu	a2,a2,0

200000b0 <Data_copy>:
Data_copy:
        lw $2, 0($4)
200000b0:	8c820000 	lw	v0,0(a0)
        nop
200000b4:	00000000 	nop
        slt $3, $6, $5
200000b8:	00c5182a 	slt	v1,a2,a1
        sw $2, 0($6)
200000bc:	acc20000 	sw	v0,0(a2)
        addiu $6, $6, 4
200000c0:	24c60004 	addiu	a2,a2,4
        bnez  $3, Data_copy
200000c4:	1460fffa 	bnez	v1,200000b0 <Data_copy>
        addiu $4, $4, 4
200000c8:	24840004 	addiu	a0,a0,4

/* Clear .bss section (Zero init) */
        la $4, _bss   # Clear BSS Segment
200000cc:	3c044000 	lui	a0,0x4000
200000d0:	2484041c 	addiu	a0,a0,1052
        la $5, _ebss  # Clear BSS Segment
200000d4:	3c054000 	lui	a1,0x4000
200000d8:	24a50c54 	addiu	a1,a1,3156

200000dc <BSS_clear>:
BSS_clear:
        sw  $0, 0($4)
200000dc:	ac800000 	sw	zero,0(a0)
        slt $3, $4, $5
200000e0:	0085182a 	slt	v1,a0,a1
        bnez  $3, BSS_clear
200000e4:	1460fffd 	bnez	v1,200000dc <BSS_clear>
        addiu $4, $4, 4
200000e8:	24840004 	addiu	a0,a0,4

        la $4, _stext
200000ec:	3c040000 	lui	a0,0x0
200000f0:	24840000 	addiu	a0,a0,0
        la $5, _etext
200000f4:	3c052000 	lui	a1,0x2000
200000f8:	24a55114 	addiu	a1,a1,20756
        la $6, _text
200000fc:	3c062000 	lui	a2,0x2000
20000100:	24c60000 	addiu	a2,a2,0

20000104 <Code_copy>:
Code_copy:
        lw $2, 0($4)
20000104:	8c820000 	lw	v0,0(a0)
        nop
20000108:	00000000 	nop
        slt $3, $6, $5
2000010c:	00c5182a 	slt	v1,a2,a1
        sw $2, 0($6)
20000110:	acc20000 	sw	v0,0(a2)
        addiu $6, $6, 4
20000114:	24c60004 	addiu	a2,a2,4
        bnez  $3, Code_copy
20000118:	1460fffa 	bnez	v1,20000104 <Code_copy>
        addiu $4, $4, 4
2000011c:	24840004 	addiu	a0,a0,4


/* Enable system interrupts */
        mfc0 $4, $12         # Read CP0 Status Reg
20000120:	40046000 	mfc0	a0,c0_sr
        nop
20000124:	00000000 	nop
        ori $4, $4, 0x700    # Set IE and IRQ = 7
20000128:	34840700 	ori	a0,a0,0x700
        nop
2000012c:	00000000 	nop
        mtc0 $4, $12         # Save CP0 Status Reg
20000130:	40846000 	mtc0	a0,c0_sr
        nop
20000134:	00000000 	nop
        
        la $4, 0xFF00
20000138:	3404ff00 	li	a0,0xff00
        nop
2000013c:	00000000 	nop
        mtc0 $4, $13
20000140:	40846800 	mtc0	a0,c0_cause
        jalr $t0
		nop
#endif

/* Finally, start running the C code - branch to main() */
		la $t0, main
20000144:	3c082000 	lui	t0,0x2000
20000148:	25080158 	addiu	t0,t0,344
        jalr $t0        # Call main()
2000014c:	0100f809 	jalr	t0
        nop
20000150:	00000000 	nop

20000154 <_exit>:

	.global _exit
_exit:                  # Halt if main returns
        b   _exit
20000154:	1000ffff                                ....

20000158 <main>:
 *
 * This function should never exit, as embedded systems do not have an
 * operating system to return to.
 */
int main(void)
{
20000158:	27bdffe8 	addiu	sp,sp,-24
2000015c:	afbf0014 	sw	ra,20(sp)
 * @param
 */
TTE_ALWAYS_INLINE
static inline void Target_Mapping_Init(void)
{
	Device_Add(NULL);
20000160:	0c000f9a 	jal	20003e68 <Device_Add>
20000164:	00002021 	move	a0,zero
	return 0;
#endif

	Target_Mapping_Init();

	Scheduler_Init(Config_Tick_Period);
20000168:	0c000cb7 	jal	200032dc <Scheduler_Init>
2000016c:	240403e8 	li	a0,1000
	Tasks_Init();
20000170:	0c000064 	jal	20000190 <Tasks_Init>
20000174:	00000000 	nop

	Scheduler_Start();
20000178:	0c000cad 	jal	200032b4 <Scheduler_Start>
2000017c:	00000000 	nop

	while (TRUE)
	{
		Scheduler_Dispatch();
20000180:	0c000c4f 	jal	2000313c <Scheduler_Dispatch>
20000184:	00000000 	nop
20000188:	08000060 	j	20000180 <main+0x28>
2000018c:	00000000 	nop

20000190 <Tasks_Init>:

/**
 * Initialise all hardware for all tasks.
 */
void Tasks_Init(void)
{
20000190:	27bdffe8 	addiu	sp,sp,-24
20000194:	afbf0014 	sw	ra,20(sp)
	Flashing_LED_Init();
20000198:	0c000ab7 	jal	20002adc <Flashing_LED_Init>
2000019c:	00000000 	nop
	System_timer_Init();
200001a0:	0c00007f 	jal	200001fc <System_timer_Init>
200001a4:	00000000 	nop
	System_Control_Init();
200001a8:	0c0000a3 	jal	2000028c <System_Control_Init>
200001ac:	00000000 	nop
	PathFinder_Init();
200001b0:	0c0004f3 	jal	200013cc <PathFinder_Init>
200001b4:	00000000 	nop
	Read_Enc_Init();
200001b8:	0c000466 	jal	20001198 <Read_Enc_Init>
200001bc:	00000000 	nop
	Motor_Right_Init();
200001c0:	0c0006ef 	jal	20001bbc <Motor_Right_Init>
200001c4:	00000000 	nop
	Motor_Left_Init();
200001c8:	0c000830 	jal	200020c0 <Motor_Left_Init>
200001cc:	00000000 	nop
	Course_Corrector_Init();
200001d0:	0c000af0 	jal	20002bc0 <Course_Corrector_Init>
200001d4:	00000000 	nop
	Script_Keeper_Init();
200001d8:	0c0001ba 	jal	200006e8 <Script_Keeper_Init>
200001dc:	00000000 	nop
	CAN_relay_Init();
200001e0:	0c000b0a 	jal	20002c28 <CAN_relay_Init>
200001e4:	00000000 	nop
	Message_Sender_Init();
200001e8:	0c000a84 	jal	20002a10 <Message_Sender_Init>
200001ec:	00000000 	nop
	Opponent_Tracker_Init();
}
200001f0:	8fbf0014 	lw	ra,20(sp)
	Motor_Left_Init();
	Course_Corrector_Init();
	Script_Keeper_Init();
	CAN_relay_Init();
	Message_Sender_Init();
	Opponent_Tracker_Init();
200001f4:	0800058e 	j	20001638 <Opponent_Tracker_Init>
200001f8:	27bd0018 	addiu	sp,sp,24

200001fc <System_timer_Init>:
 * This will be called from Tasks_Init by default.
 */
void System_timer_Init(void)
{
	Timer_Status = Stopped;
	Init_period_reload = Tasks[0].period_reload;
200001fc:	3c024000 	lui	v0,0x4000
20000200:	24420158 	addiu	v0,v0,344
20000204:	8c420004 	lw	v0,4(v0)
 * Initialisation for the System_Timer package.
 * This will be called from Tasks_Init by default.
 */
void System_timer_Init(void)
{
	Timer_Status = Stopped;
20000208:	af8000f0 	sw	zero,240(gp)
	Init_period_reload = Tasks[0].period_reload;
}
2000020c:	03e00008 	jr	ra
20000210:	af8200f4 	sw	v0,244(gp)

20000214 <System_timer_Update>:
 * Waits for game to start (from System_Mode_G - switched by System_Control)
 * Changes period_reload to ninety seconds and switches system mode to Game_Over next time it is called
 */
void System_timer_Update(void)
{
	if(System_Mode_G == Go)
20000214:	8f8200f8 	lw	v0,248(gp)
20000218:	24030002 	li	v1,2
2000021c:	14430016 	bne	v0,v1,20000278 <System_timer_Update+0x64>
20000220:	00000000 	nop
	{
		switch(Timer_Status)
20000224:	8f8300f0 	lw	v1,240(gp)
20000228:	00000000 	nop
2000022c:	10600005 	beqz	v1,20000244 <System_timer_Update+0x30>
20000230:	24040001 	li	a0,1
20000234:	1464000d 	bne	v1,a0,2000026c <System_timer_Update+0x58>
20000238:	3c044000 	lui	a0,0x4000
				Tasks[0].period_reload = Ninety_Seconds;
				Timer_Status = Init;
				break;

			case Init:
				Tasks[0].period_reload = 1;
2000023c:	08000098 	j	20000260 <System_timer_Update+0x4c>
20000240:	24840158 	addiu	a0,a0,344
	if(System_Mode_G == Go)
	{
		switch(Timer_Status)
		{
			case Stopped:
				Tasks[0].period_reload = Ninety_Seconds;
20000244:	3c030001 	lui	v1,0x1
20000248:	3c024000 	lui	v0,0x4000
2000024c:	24420158 	addiu	v0,v0,344
20000250:	34635ba8 	ori	v1,v1,0x5ba8
20000254:	ac430004 	sw	v1,4(v0)
				Timer_Status = Init;
20000258:	08000099 	j	20000264 <System_timer_Update+0x50>
2000025c:	24020001 	li	v0,1
				break;

			case Init:
				Tasks[0].period_reload = 1;
20000260:	ac830004 	sw	v1,4(a0)
				Timer_Status = Running;
				break;
20000264:	03e00008 	jr	ra
20000268:	af8200f0 	sw	v0,240(gp)

			case Running:
			default:
				System_Mode_G = Game_Over;
2000026c:	24020004 	li	v0,4
20000270:	03e00008 	jr	ra
20000274:	af8200f8 	sw	v0,248(gp)
				break;
		}
	}
	/* Allow System reset */
	else if(System_Mode_G == Ready)
20000278:	14400002 	bnez	v0,20000284 <System_timer_Update+0x70>
2000027c:	00000000 	nop
	{
		Timer_Status = Stopped;
20000280:	af8000f0 	sw	zero,240(gp)
20000284:	03e00008 	jr	ra
20000288:	00000000 	nop

2000028c <System_Control_Init>:
 * This will be called from Tasks_Init by default.
 */
void System_Control_Init(void)
{
	/* Port initialisation */
	GPIO_Set_Direction(Red_Cord_SW, GPIO_INPUT);
2000028c:	3c028000 	lui	v0,0x8000
20000290:	34430500 	ori	v1,v0,0x500
20000294:	8c650004 	lw	a1,4(v1)
20000298:	2404fffe 	li	a0,-2
2000029c:	00a42024 	and	a0,a1,a0
200002a0:	ac640004 	sw	a0,4(v1)
200002a4:	8c640004 	lw	a0,4(v1)
	GPIO_Set_Direction(Blue_Cord_SW, GPIO_INPUT);

	GPIO_Set_Direction(Error_Lamp, GPIO_OUTPUT);
200002a8:	34420200 	ori	v0,v0,0x200
 * This will be called from Tasks_Init by default.
 */
void System_Control_Init(void)
{
	/* Port initialisation */
	GPIO_Set_Direction(Red_Cord_SW, GPIO_INPUT);
200002ac:	ac640004 	sw	a0,4(v1)
	GPIO_Set_Direction(Blue_Cord_SW, GPIO_INPUT);
200002b0:	8c650004 	lw	a1,4(v1)
200002b4:	2404fffd 	li	a0,-3
200002b8:	00a42024 	and	a0,a1,a0
200002bc:	ac640004 	sw	a0,4(v1)
200002c0:	8c650004 	lw	a1,4(v1)

	GPIO_Set_Direction(Error_Lamp, GPIO_OUTPUT);
200002c4:	2404feff 	li	a0,-257
 */
void System_Control_Init(void)
{
	/* Port initialisation */
	GPIO_Set_Direction(Red_Cord_SW, GPIO_INPUT);
	GPIO_Set_Direction(Blue_Cord_SW, GPIO_INPUT);
200002c8:	ac650004 	sw	a1,4(v1)

	GPIO_Set_Direction(Error_Lamp, GPIO_OUTPUT);
200002cc:	8c450004 	lw	a1,4(v0)
	GPIO_Write(Error_Lamp, GPIO_LOW);

	GPIO_Set_Direction(Ready_Lamp_Rd, GPIO_OUTPUT);
200002d0:	2406ffbf 	li	a2,-65
{
	/* Port initialisation */
	GPIO_Set_Direction(Red_Cord_SW, GPIO_INPUT);
	GPIO_Set_Direction(Blue_Cord_SW, GPIO_INPUT);

	GPIO_Set_Direction(Error_Lamp, GPIO_OUTPUT);
200002d4:	00a42824 	and	a1,a1,a0
200002d8:	ac450004 	sw	a1,4(v0)
200002dc:	8c470004 	lw	a3,4(v0)
	GPIO_Write(Error_Lamp, GPIO_LOW);

	GPIO_Set_Direction(Ready_Lamp_Rd, GPIO_OUTPUT);
	GPIO_Write(Ready_Lamp_Rd, GPIO_LOW);

	GPIO_Set_Direction(Ready_Lamp_Bl, GPIO_OUTPUT);
200002e0:	2405ff7f 	li	a1,-129
{
	/* Port initialisation */
	GPIO_Set_Direction(Red_Cord_SW, GPIO_INPUT);
	GPIO_Set_Direction(Blue_Cord_SW, GPIO_INPUT);

	GPIO_Set_Direction(Error_Lamp, GPIO_OUTPUT);
200002e4:	34e70100 	ori	a3,a3,0x100
200002e8:	ac470004 	sw	a3,4(v0)
	GPIO_Write(Error_Lamp, GPIO_LOW);
200002ec:	8c470000 	lw	a3,0(v0)
200002f0:	00000000 	nop
200002f4:	00e42024 	and	a0,a3,a0
200002f8:	ac440000 	sw	a0,0(v0)
200002fc:	8c440000 	lw	a0,0(v0)
20000300:	00000000 	nop
20000304:	ac440000 	sw	a0,0(v0)

	GPIO_Set_Direction(Ready_Lamp_Rd, GPIO_OUTPUT);
20000308:	8c470004 	lw	a3,4(v0)
	GPIO_Write(Ready_Lamp_Rd, GPIO_LOW);

	GPIO_Set_Direction(Ready_Lamp_Bl, GPIO_OUTPUT);
	GPIO_Write(Ready_Lamp_Bl, GPIO_LOW);

	GPIO_Set_Direction(KILL_ALL, GPIO_OUTPUT);
2000030c:	3c040080 	lui	a0,0x80
	GPIO_Set_Direction(Blue_Cord_SW, GPIO_INPUT);

	GPIO_Set_Direction(Error_Lamp, GPIO_OUTPUT);
	GPIO_Write(Error_Lamp, GPIO_LOW);

	GPIO_Set_Direction(Ready_Lamp_Rd, GPIO_OUTPUT);
20000310:	00e63824 	and	a3,a3,a2
20000314:	ac470004 	sw	a3,4(v0)
20000318:	8c470004 	lw	a3,4(v0)
2000031c:	00000000 	nop
20000320:	34e70040 	ori	a3,a3,0x40
20000324:	ac470004 	sw	a3,4(v0)
	GPIO_Write(Ready_Lamp_Rd, GPIO_LOW);
20000328:	8c470000 	lw	a3,0(v0)
2000032c:	00000000 	nop
20000330:	00e63024 	and	a2,a3,a2
20000334:	ac460000 	sw	a2,0(v0)
20000338:	8c460000 	lw	a2,0(v0)
2000033c:	00000000 	nop
20000340:	ac460000 	sw	a2,0(v0)

	GPIO_Set_Direction(Ready_Lamp_Bl, GPIO_OUTPUT);
20000344:	8c460004 	lw	a2,4(v0)
20000348:	00000000 	nop
2000034c:	00c53024 	and	a2,a2,a1
20000350:	ac460004 	sw	a2,4(v0)
20000354:	8c460004 	lw	a2,4(v0)
20000358:	00000000 	nop
2000035c:	34c60080 	ori	a2,a2,0x80
20000360:	ac460004 	sw	a2,4(v0)
	GPIO_Write(Ready_Lamp_Bl, GPIO_LOW);
20000364:	8c460000 	lw	a2,0(v0)
20000368:	00000000 	nop
2000036c:	00c52824 	and	a1,a2,a1
20000370:	ac450000 	sw	a1,0(v0)
20000374:	8c450000 	lw	a1,0(v0)
20000378:	00000000 	nop
2000037c:	ac450000 	sw	a1,0(v0)

	GPIO_Set_Direction(KILL_ALL, GPIO_OUTPUT);
20000380:	8c650004 	lw	a1,4(v1)
20000384:	3c02ff7f 	lui	v0,0xff7f
20000388:	3442ffff 	ori	v0,v0,0xffff
2000038c:	00a21024 	and	v0,a1,v0
20000390:	ac620004 	sw	v0,4(v1)
20000394:	8c620004 	lw	v0,4(v1)
	GPIO_Write(KILL_ALL, GPIO_HIGH);

	/* State and orientation initialisation */
	System_Mode_G = Ready;
	Orientation_G = East;
20000398:	24050003 	li	a1,3
	GPIO_Write(Ready_Lamp_Rd, GPIO_LOW);

	GPIO_Set_Direction(Ready_Lamp_Bl, GPIO_OUTPUT);
	GPIO_Write(Ready_Lamp_Bl, GPIO_LOW);

	GPIO_Set_Direction(KILL_ALL, GPIO_OUTPUT);
2000039c:	00441025 	or	v0,v0,a0
200003a0:	ac620004 	sw	v0,4(v1)
	GPIO_Write(KILL_ALL, GPIO_HIGH);
200003a4:	8c620000 	lw	v0,0(v1)

	/* State and orientation initialisation */
	System_Mode_G = Ready;
	Orientation_G = East;
200003a8:	af850050 	sw	a1,80(gp)

	GPIO_Set_Direction(Ready_Lamp_Bl, GPIO_OUTPUT);
	GPIO_Write(Ready_Lamp_Bl, GPIO_LOW);

	GPIO_Set_Direction(KILL_ALL, GPIO_OUTPUT);
	GPIO_Write(KILL_ALL, GPIO_HIGH);
200003ac:	ac620000 	sw	v0,0(v1)
200003b0:	8c620000 	lw	v0,0(v1)

	/* State and orientation initialisation */
	System_Mode_G = Ready;
200003b4:	af8000f8 	sw	zero,248(gp)

	GPIO_Set_Direction(Ready_Lamp_Bl, GPIO_OUTPUT);
	GPIO_Write(Ready_Lamp_Bl, GPIO_LOW);

	GPIO_Set_Direction(KILL_ALL, GPIO_OUTPUT);
	GPIO_Write(KILL_ALL, GPIO_HIGH);
200003b8:	00442025 	or	a0,v0,a0
200003bc:	ac640000 	sw	a0,0(v1)

	/* State and orientation initialisation */
	System_Mode_G = Ready;
	Orientation_G = East;
	Team_Colour = Red;
200003c0:	af8000c0 	sw	zero,192(gp)
	debounce = 0;
}
200003c4:	03e00008 	jr	ra
200003c8:	a38000fc 	sb	zero,252(gp)

200003cc <System_Control_Update>:
/**
 * Main system mode control
 */
void System_Control_Update(void)
{
	switch(System_Mode_G)
200003cc:	8f8200f8 	lw	v0,248(gp)
200003d0:	24030002 	li	v1,2
200003d4:	104300a8 	beq	v0,v1,20000678 <System_Control_Update+0x2ac>
200003d8:	2c440003 	sltiu	a0,v0,3
200003dc:	10800007 	beqz	a0,200003fc <System_Control_Update+0x30>
200003e0:	00000000 	nop
200003e4:	1040000d 	beqz	v0,2000041c <System_Control_Update+0x50>
200003e8:	24040001 	li	a0,1
200003ec:	144400a4 	bne	v0,a0,20000680 <System_Control_Update+0x2b4>
200003f0:	3c028000 	lui	v0,0x8000
		break;

	/* Wait for removal of pull cord to "Go" */
	case Set:
		if(
				(GPIO_Get(Red_Cord_SW) == GPIO_HIGH)
200003f4:	08000157 	j	2000055c <System_Control_Update+0x190>
200003f8:	34420500 	ori	v0,v0,0x500
/**
 * Main system mode control
 */
void System_Control_Update(void)
{
	switch(System_Mode_G)
200003fc:	24030003 	li	v1,3
20000400:	10430069 	beq	v0,v1,200005a8 <System_Control_Update+0x1dc>
20000404:	00000000 	nop
20000408:	24030004 	li	v1,4
2000040c:	1443009c 	bne	v0,v1,20000680 <System_Control_Update+0x2b4>
20000410:	3c028000 	lui	v0,0x8000
		GPIO_Write(Ready_Lamp_Bl, GPIO_HIGH);
		break;

	/* Signal Game Over */
	case Game_Over:
		GPIO_Write(KILL_ALL, GPIO_LOW);
20000414:	08000188 	j	20000620 <System_Control_Update+0x254>
20000418:	34430500 	ori	v1,v0,0x500
	switch(System_Mode_G)
	{
	/* Wait for pull cord to determine direction */
	case Ready:
		if(
			((GPIO_Get(Red_Cord_SW) == GPIO_HIGH) && (GPIO_Get(Blue_Cord_SW) == GPIO_HIGH))
2000041c:	3c028000 	lui	v0,0x8000
20000420:	34420500 	ori	v0,v0,0x500
20000424:	8c430000 	lw	v1,0(v0)
20000428:	00000000 	nop
{
	switch(System_Mode_G)
	{
	/* Wait for pull cord to determine direction */
	case Ready:
		if(
2000042c:	30630001 	andi	v1,v1,0x1
20000430:	10600006 	beqz	v1,2000044c <System_Control_Update+0x80>
20000434:	00000000 	nop
			((GPIO_Get(Red_Cord_SW) == GPIO_HIGH) && (GPIO_Get(Blue_Cord_SW) == GPIO_HIGH))
20000438:	8c420000 	lw	v0,0(v0)
2000043c:	00000000 	nop
{
	switch(System_Mode_G)
	{
	/* Wait for pull cord to determine direction */
	case Ready:
		if(
20000440:	30420002 	andi	v0,v0,0x2
20000444:	14400043 	bnez	v0,20000554 <System_Control_Update+0x188>
20000448:	00000000 	nop
			((GPIO_Get(Red_Cord_SW) == GPIO_HIGH) && (GPIO_Get(Blue_Cord_SW) == GPIO_HIGH))
			||
			((GPIO_Get(Red_Cord_SW) == GPIO_LOW) && (GPIO_Get(Blue_Cord_SW) == GPIO_LOW))
2000044c:	3c028000 	lui	v0,0x8000
20000450:	34420500 	ori	v0,v0,0x500
20000454:	8c430000 	lw	v1,0(v0)
20000458:	00000000 	nop
{
	switch(System_Mode_G)
	{
	/* Wait for pull cord to determine direction */
	case Ready:
		if(
2000045c:	30630001 	andi	v1,v1,0x1
20000460:	14600006 	bnez	v1,2000047c <System_Control_Update+0xb0>
20000464:	00000000 	nop
			((GPIO_Get(Red_Cord_SW) == GPIO_HIGH) && (GPIO_Get(Blue_Cord_SW) == GPIO_HIGH))
			||
			((GPIO_Get(Red_Cord_SW) == GPIO_LOW) && (GPIO_Get(Blue_Cord_SW) == GPIO_LOW))
20000468:	8c420000 	lw	v0,0(v0)
2000046c:	00000000 	nop
{
	switch(System_Mode_G)
	{
	/* Wait for pull cord to determine direction */
	case Ready:
		if(
20000470:	30420002 	andi	v0,v0,0x2
20000474:	10400037 	beqz	v0,20000554 <System_Control_Update+0x188>
20000478:	00000000 	nop
			//GPIO_Write(Ready_Lamp_Rd, GPIO_HIGH);
			//GPIO_Write(Ready_Lamp_Bl, GPIO_HIGH);
			//System_Mode_G = E_Stop;
			debounce = 0;
		}
		else if((GPIO_Get(Red_Cord_SW) == GPIO_LOW) && (++debounce > 100))
2000047c:	3c028000 	lui	v0,0x8000
20000480:	34430500 	ori	v1,v0,0x500
20000484:	8c630000 	lw	v1,0(v1)
20000488:	00000000 	nop
2000048c:	30630001 	andi	v1,v1,0x1
20000490:	14600017 	bnez	v1,200004f0 <System_Control_Update+0x124>
20000494:	34430500 	ori	v1,v0,0x500
20000498:	938300fc 	lbu	v1,252(gp)
2000049c:	00000000 	nop
200004a0:	24630001 	addiu	v1,v1,1
200004a4:	306300ff 	andi	v1,v1,0xff
200004a8:	2c640065 	sltiu	a0,v1,101
200004ac:	1480000f 	bnez	a0,200004ec <System_Control_Update+0x120>
200004b0:	a38300fc 	sb	v1,252(gp)
		{
			Orientation_G = West;
			GPIO_Write(Ready_Lamp_Rd, GPIO_HIGH);
200004b4:	34420200 	ori	v0,v0,0x200
200004b8:	8c440000 	lw	a0,0(v0)
			System_Mode_G = Set;
200004bc:	24030001 	li	v1,1
			debounce = 0;
		}
		else if((GPIO_Get(Red_Cord_SW) == GPIO_LOW) && (++debounce > 100))
		{
			Orientation_G = West;
			GPIO_Write(Ready_Lamp_Rd, GPIO_HIGH);
200004c0:	ac440000 	sw	a0,0(v0)
200004c4:	8c440000 	lw	a0,0(v0)
			System_Mode_G = Set;
			Script_no_G = 0;
			Team_Colour = Red;
			Script_update = True;
200004c8:	af8300dc 	sw	v1,220(gp)
			debounce = 0;
		}
		else if((GPIO_Get(Red_Cord_SW) == GPIO_LOW) && (++debounce > 100))
		{
			Orientation_G = West;
			GPIO_Write(Ready_Lamp_Rd, GPIO_HIGH);
200004cc:	34840040 	ori	a0,a0,0x40
200004d0:	ac440000 	sw	a0,0(v0)
			//System_Mode_G = E_Stop;
			debounce = 0;
		}
		else if((GPIO_Get(Red_Cord_SW) == GPIO_LOW) && (++debounce > 100))
		{
			Orientation_G = West;
200004d4:	24020004 	li	v0,4
200004d8:	af820050 	sw	v0,80(gp)
			GPIO_Write(Ready_Lamp_Rd, GPIO_HIGH);
			System_Mode_G = Set;
200004dc:	af8300f8 	sw	v1,248(gp)
			Script_no_G = 0;
200004e0:	a38000e0 	sb	zero,224(gp)
			Team_Colour = Red;
200004e4:	08000155 	j	20000554 <System_Control_Update+0x188>
200004e8:	af8000c0 	sw	zero,192(gp)
			Script_update = True;
			debounce = 0;
		}
		else if((GPIO_Get(Blue_Cord_SW) == GPIO_LOW) && (++debounce > 100))
200004ec:	34430500 	ori	v1,v0,0x500
200004f0:	8c630000 	lw	v1,0(v1)
200004f4:	00000000 	nop
200004f8:	30630002 	andi	v1,v1,0x2
200004fc:	14600078 	bnez	v1,200006e0 <System_Control_Update+0x314>
20000500:	00000000 	nop
20000504:	938300fc 	lbu	v1,252(gp)
20000508:	00000000 	nop
2000050c:	24630001 	addiu	v1,v1,1
20000510:	306300ff 	andi	v1,v1,0xff
20000514:	2c640065 	sltiu	a0,v1,101
20000518:	14800057 	bnez	a0,20000678 <System_Control_Update+0x2ac>
2000051c:	a38300fc 	sb	v1,252(gp)
		{
			Orientation_G = East;
			GPIO_Write(Ready_Lamp_Bl, GPIO_HIGH);
20000520:	34420200 	ori	v0,v0,0x200
20000524:	8c440000 	lw	a0,0(v0)
			System_Mode_G = Set;
20000528:	24030001 	li	v1,1
			debounce = 0;
		}
		else if((GPIO_Get(Blue_Cord_SW) == GPIO_LOW) && (++debounce > 100))
		{
			Orientation_G = East;
			GPIO_Write(Ready_Lamp_Bl, GPIO_HIGH);
2000052c:	ac440000 	sw	a0,0(v0)
20000530:	8c440000 	lw	a0,0(v0)
			System_Mode_G = Set;
			Script_no_G = 0;
			Team_Colour = Blue;
			Script_update = True;
20000534:	af8300dc 	sw	v1,220(gp)
			debounce = 0;
		}
		else if((GPIO_Get(Blue_Cord_SW) == GPIO_LOW) && (++debounce > 100))
		{
			Orientation_G = East;
			GPIO_Write(Ready_Lamp_Bl, GPIO_HIGH);
20000538:	34840080 	ori	a0,a0,0x80
2000053c:	ac440000 	sw	a0,0(v0)
			Script_update = True;
			debounce = 0;
		}
		else if((GPIO_Get(Blue_Cord_SW) == GPIO_LOW) && (++debounce > 100))
		{
			Orientation_G = East;
20000540:	24020003 	li	v0,3
20000544:	af820050 	sw	v0,80(gp)
			GPIO_Write(Ready_Lamp_Bl, GPIO_HIGH);
			System_Mode_G = Set;
20000548:	af8300f8 	sw	v1,248(gp)
			Script_no_G = 0;
2000054c:	a38000e0 	sb	zero,224(gp)
			Team_Colour = Blue;
20000550:	af8300c0 	sw	v1,192(gp)
			Script_update = True;
			debounce = 0;
20000554:	03e00008 	jr	ra
20000558:	a38000fc 	sb	zero,252(gp)
		break;

	/* Wait for removal of pull cord to "Go" */
	case Set:
		if(
				(GPIO_Get(Red_Cord_SW) == GPIO_HIGH)
2000055c:	8c440000 	lw	a0,0(v0)
20000560:	00000000 	nop
		}
		break;

	/* Wait for removal of pull cord to "Go" */
	case Set:
		if(
20000564:	30840001 	andi	a0,a0,0x1
20000568:	1080005d 	beqz	a0,200006e0 <System_Control_Update+0x314>
2000056c:	00000000 	nop
				(GPIO_Get(Red_Cord_SW) == GPIO_HIGH)
				&&
				(GPIO_Get(Blue_Cord_SW) == GPIO_HIGH)
20000570:	8c420000 	lw	v0,0(v0)
20000574:	00000000 	nop
		}
		break;

	/* Wait for removal of pull cord to "Go" */
	case Set:
		if(
20000578:	30420002 	andi	v0,v0,0x2
2000057c:	10400058 	beqz	v0,200006e0 <System_Control_Update+0x314>
20000580:	00000000 	nop
				(GPIO_Get(Red_Cord_SW) == GPIO_HIGH)
				&&
				(GPIO_Get(Blue_Cord_SW) == GPIO_HIGH)
				&&
				(++debounce > 100)
20000584:	938200fc 	lbu	v0,252(gp)
20000588:	00000000 	nop
2000058c:	24420001 	addiu	v0,v0,1
20000590:	304200ff 	andi	v0,v0,0xff
		}
		break;

	/* Wait for removal of pull cord to "Go" */
	case Set:
		if(
20000594:	2c440065 	sltiu	a0,v0,101
20000598:	14800037 	bnez	a0,20000678 <System_Control_Update+0x2ac>
2000059c:	a38200fc 	sb	v0,252(gp)
				(GPIO_Get(Blue_Cord_SW) == GPIO_HIGH)
				&&
				(++debounce > 100)
		)
		{
			System_Mode_G = Go;
200005a0:	03e00008 	jr	ra
200005a4:	af8300f8 	sw	v1,248(gp)
	case Go:
		break;

	/* Signal E Stop */
	case E_Stop:
		GPIO_Write(KILL_ALL, GPIO_LOW);
200005a8:	3c028000 	lui	v0,0x8000
200005ac:	34430500 	ori	v1,v0,0x500
200005b0:	8c650000 	lw	a1,0(v1)
200005b4:	3c04ff7f 	lui	a0,0xff7f
200005b8:	3484ffff 	ori	a0,a0,0xffff
200005bc:	00a42024 	and	a0,a1,a0
200005c0:	ac640000 	sw	a0,0(v1)
200005c4:	8c640000 	lw	a0,0(v1)
		//GPIO_Set_Direction(KILL_ALL, GPIO_INPUT);
		GPIO_Write(Error_Lamp, GPIO_HIGH);
200005c8:	34420200 	ori	v0,v0,0x200
	case Go:
		break;

	/* Signal E Stop */
	case E_Stop:
		GPIO_Write(KILL_ALL, GPIO_LOW);
200005cc:	ac640000 	sw	a0,0(v1)
		//GPIO_Set_Direction(KILL_ALL, GPIO_INPUT);
		GPIO_Write(Error_Lamp, GPIO_HIGH);
200005d0:	8c430000 	lw	v1,0(v0)
200005d4:	00000000 	nop
200005d8:	ac430000 	sw	v1,0(v0)
200005dc:	8c430000 	lw	v1,0(v0)
200005e0:	00000000 	nop
200005e4:	34630100 	ori	v1,v1,0x100
200005e8:	ac430000 	sw	v1,0(v0)
		GPIO_Write(Ready_Lamp_Rd, GPIO_HIGH);
200005ec:	8c430000 	lw	v1,0(v0)
200005f0:	00000000 	nop
200005f4:	ac430000 	sw	v1,0(v0)
200005f8:	8c430000 	lw	v1,0(v0)
200005fc:	00000000 	nop
20000600:	34630040 	ori	v1,v1,0x40
20000604:	ac430000 	sw	v1,0(v0)
		GPIO_Write(Ready_Lamp_Bl, GPIO_HIGH);
20000608:	8c430000 	lw	v1,0(v0)
2000060c:	00000000 	nop
20000610:	ac430000 	sw	v1,0(v0)
20000614:	8c430000 	lw	v1,0(v0)
20000618:	0800019d 	j	20000674 <System_Control_Update+0x2a8>
2000061c:	34630080 	ori	v1,v1,0x80
		break;

	/* Signal Game Over */
	case Game_Over:
		GPIO_Write(KILL_ALL, GPIO_LOW);
20000620:	8c650000 	lw	a1,0(v1)
20000624:	3c04ff7f 	lui	a0,0xff7f
20000628:	3484ffff 	ori	a0,a0,0xffff
2000062c:	00a42024 	and	a0,a1,a0
20000630:	ac640000 	sw	a0,0(v1)
20000634:	8c640000 	lw	a0,0(v1)
		//GPIO_Set_Direction(KILL_ALL, GPIO_INPUT);
		GPIO_Write(Ready_Lamp_Rd, GPIO_LOW);
20000638:	34420200 	ori	v0,v0,0x200
		GPIO_Write(Ready_Lamp_Bl, GPIO_HIGH);
		break;

	/* Signal Game Over */
	case Game_Over:
		GPIO_Write(KILL_ALL, GPIO_LOW);
2000063c:	ac640000 	sw	a0,0(v1)
		//GPIO_Set_Direction(KILL_ALL, GPIO_INPUT);
		GPIO_Write(Ready_Lamp_Rd, GPIO_LOW);
20000640:	8c440000 	lw	a0,0(v0)
20000644:	2403ffbf 	li	v1,-65
20000648:	00831824 	and	v1,a0,v1
2000064c:	ac430000 	sw	v1,0(v0)
20000650:	8c430000 	lw	v1,0(v0)
		GPIO_Write(Ready_Lamp_Bl, GPIO_LOW);
		System_Mode_G = Ready; // TODO: Remove!
20000654:	af8000f8 	sw	zero,248(gp)

	/* Signal Game Over */
	case Game_Over:
		GPIO_Write(KILL_ALL, GPIO_LOW);
		//GPIO_Set_Direction(KILL_ALL, GPIO_INPUT);
		GPIO_Write(Ready_Lamp_Rd, GPIO_LOW);
20000658:	ac430000 	sw	v1,0(v0)
		GPIO_Write(Ready_Lamp_Bl, GPIO_LOW);
2000065c:	8c440000 	lw	a0,0(v0)
20000660:	2403ff7f 	li	v1,-129
20000664:	00831824 	and	v1,a0,v1
20000668:	ac430000 	sw	v1,0(v0)
2000066c:	8c430000 	lw	v1,0(v0)
20000670:	00000000 	nop
20000674:	ac430000 	sw	v1,0(v0)
		System_Mode_G = Ready; // TODO: Remove!
		break;
20000678:	03e00008 	jr	ra
2000067c:	00000000 	nop

	default:
		GPIO_Write(KILL_ALL, GPIO_LOW);
20000680:	3c028000 	lui	v0,0x8000
20000684:	34430500 	ori	v1,v0,0x500
20000688:	8c650000 	lw	a1,0(v1)
2000068c:	3c04ff7f 	lui	a0,0xff7f
20000690:	3484ffff 	ori	a0,a0,0xffff
20000694:	00a42024 	and	a0,a1,a0
20000698:	ac640000 	sw	a0,0(v1)
2000069c:	8c640000 	lw	a0,0(v1)
		//GPIO_Set_Direction(KILL_ALL, GPIO_INPUT);
		GPIO_Write(Ready_Lamp_Rd, GPIO_HIGH);
200006a0:	34420200 	ori	v0,v0,0x200
		GPIO_Write(Ready_Lamp_Bl, GPIO_LOW);
		System_Mode_G = Ready; // TODO: Remove!
		break;

	default:
		GPIO_Write(KILL_ALL, GPIO_LOW);
200006a4:	ac640000 	sw	a0,0(v1)
		//GPIO_Set_Direction(KILL_ALL, GPIO_INPUT);
		GPIO_Write(Ready_Lamp_Rd, GPIO_HIGH);
200006a8:	8c430000 	lw	v1,0(v0)
200006ac:	00000000 	nop
200006b0:	ac430000 	sw	v1,0(v0)
200006b4:	8c430000 	lw	v1,0(v0)
200006b8:	00000000 	nop
200006bc:	34630040 	ori	v1,v1,0x40
200006c0:	ac430000 	sw	v1,0(v0)
		GPIO_Write(Ready_Lamp_Bl, GPIO_HIGH);
200006c4:	8c430000 	lw	v1,0(v0)
200006c8:	00000000 	nop
200006cc:	ac430000 	sw	v1,0(v0)
200006d0:	8c430000 	lw	v1,0(v0)
200006d4:	00000000 	nop
200006d8:	34630080 	ori	v1,v1,0x80
200006dc:	ac430000 	sw	v1,0(v0)
200006e0:	03e00008 	jr	ra
200006e4:	00000000 	nop

200006e8 <Script_Keeper_Init>:
 */
void Script_Keeper_Init(void)
{
	/* Initialise the blank structure and counters */
	Script_count = 0;
	Script_no_G = 0;
200006e8:	3c024000 	lui	v0,0x4000

/**
 * Initialisation for the Script_Keeper package.
 * This will be called from Tasks_Init by default.
 */
void Script_Keeper_Init(void)
200006ec:	3c034000 	lui	v1,0x4000
{
	/* Initialise the blank structure and counters */
	Script_count = 0;
200006f0:	a38000fd 	sb	zero,253(gp)
	Script_no_G = 0;
200006f4:	a38000e0 	sb	zero,224(gp)
200006f8:	2442066c 	addiu	v0,v0,1644

/**
 * Initialisation for the Script_Keeper package.
 * This will be called from Tasks_Init by default.
 */
void Script_Keeper_Init(void)
200006fc:	2463076c 	addiu	v1,v1,1900
	/* Initialise the blank structure and counters */
	Script_count = 0;
	Script_no_G = 0;
	for(uint8_t i = 0; i < SCRIPT_MAX; i++)
	{
		Script_G.Movement[i] = Stp;
20000700:	ac400000 	sw	zero,0(v0)
		Script_G.Enc_counts[i] = 0;
20000704:	ac400100 	sw	zero,256(v0)
20000708:	24420004 	addiu	v0,v0,4
void Script_Keeper_Init(void)
{
	/* Initialise the blank structure and counters */
	Script_count = 0;
	Script_no_G = 0;
	for(uint8_t i = 0; i < SCRIPT_MAX; i++)
2000070c:	1443fffc 	bne	v0,v1,20000700 <Script_Keeper_Init+0x18>
20000710:	00000000 	nop
		Script_G.Movement[i] = Stp;
		Script_G.Enc_counts[i] = 0;
	}

	Script_update = False;
}
20000714:	03e00008 	jr	ra
20000718:	af8000dc 	sw	zero,220(gp)

2000071c <aboutTurn>:
 * Insert a 180 deg rotation and forward movement.
 * @param path_pointer The Path pointer
 */
void aboutTurn(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Lf;
2000071c:	938500fd 	lbu	a1,253(gp)
	Script_count++;
	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;
	Script_G.Movement[Script_count] = Fd;
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000720:	24840010 	addiu	a0,a0,16
 */
void aboutTurn(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;
20000724:	24a30001 	addiu	v1,a1,1
	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;
	Script_G.Movement[Script_count] = Fd;
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000728:	3c024000 	lui	v0,0x4000
/**
 * Insert a 180 deg rotation and forward movement.
 * @param path_pointer The Path pointer
 */
void aboutTurn(uint32_t path_pointer)
{
2000072c:	27bdffe0 	addiu	sp,sp,-32
	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;
20000730:	306300ff 	andi	v1,v1,0xff
	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;
	Script_G.Movement[Script_count] = Fd;
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000734:	244205c0 	addiu	v0,v0,1472
20000738:	00042080 	sll	a0,a0,0x2
/**
 * Insert a 180 deg rotation and forward movement.
 * @param path_pointer The Path pointer
 */
void aboutTurn(uint32_t path_pointer)
{
2000073c:	afb00014 	sw	s0,20(sp)
	Script_count++;
	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;
	Script_G.Movement[Script_count] = Fd;
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000740:	00822021 	addu	a0,a0,v0
	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;
	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;
20000744:	24700001 	addiu	s0,v1,1
 * Insert a 180 deg rotation and forward movement.
 * @param path_pointer The Path pointer
 */
void aboutTurn(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Lf;
20000748:	3c024000 	lui	v0,0x4000
2000074c:	2442066c 	addiu	v0,v0,1644
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;
	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;
20000750:	321000ff 	andi	s0,s0,0xff
 * @param path_pointer The Path pointer
 */
void aboutTurn(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
20000754:	24a90040 	addiu	t1,a1,64
	Script_count++;
	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
20000758:	24680040 	addiu	t0,v1,64
 * Insert a 180 deg rotation and forward movement.
 * @param path_pointer The Path pointer
 */
void aboutTurn(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Lf;
2000075c:	00052880 	sll	a1,a1,0x2
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;
	Script_G.Movement[Script_count] = Lf;
20000760:	00031880 	sll	v1,v1,0x2
 * Insert a 180 deg rotation and forward movement.
 * @param path_pointer The Path pointer
 */
void aboutTurn(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Lf;
20000764:	24070003 	li	a3,3
20000768:	00a22821 	addu	a1,a1,v0
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;
	Script_G.Movement[Script_count] = Lf;
2000076c:	00621821 	addu	v1,v1,v0
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;
	Script_G.Movement[Script_count] = Fd;
20000770:	00105080 	sll	t2,s0,0x2
 * @param path_pointer The Path pointer
 */
void aboutTurn(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
20000774:	00094880 	sll	t1,t1,0x2
	Script_count++;
	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
20000778:	00084080 	sll	t0,t0,0x2
 * Insert a 180 deg rotation and forward movement.
 * @param path_pointer The Path pointer
 */
void aboutTurn(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Lf;
2000077c:	aca70000 	sw	a3,0(a1)
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
20000780:	01224821 	addu	t1,t1,v0
	Script_count++;
	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
20000784:	01024021 	addu	t0,t0,v0
	Script_count++;
	Script_G.Movement[Script_count] = Fd;
20000788:	01425021 	addu	t2,t2,v0
 * @param path_pointer The Path pointer
 */
void aboutTurn(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
2000078c:	240600d3 	li	a2,211
	Script_count++;
	Script_G.Movement[Script_count] = Lf;
20000790:	ac670000 	sw	a3,0(v1)
/**
 * Insert a 180 deg rotation and forward movement.
 * @param path_pointer The Path pointer
 */
void aboutTurn(uint32_t path_pointer)
{
20000794:	afb10018 	sw	s1,24(sp)
	Script_count++;
	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;
	Script_G.Movement[Script_count] = Fd;
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000798:	8c840000 	lw	a0,0(a0)
2000079c:	26110040 	addiu	s1,s0,64
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;
	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;
	Script_G.Movement[Script_count] = Fd;
200007a0:	24030001 	li	v1,1
 * @param path_pointer The Path pointer
 */
void aboutTurn(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
200007a4:	ad260000 	sw	a2,0(t1)
	Script_count++;
	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;
	Script_G.Movement[Script_count] = Fd;
200007a8:	ad430000 	sw	v1,0(t2)
{
	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;
	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
200007ac:	ad060000 	sw	a2,0(t0)
	Script_count++;
	Script_G.Movement[Script_count] = Fd;
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
200007b0:	00118880 	sll	s1,s1,0x2
/**
 * Insert a 180 deg rotation and forward movement.
 * @param path_pointer The Path pointer
 */
void aboutTurn(uint32_t path_pointer)
{
200007b4:	afbf001c 	sw	ra,28(sp)
	Script_count++;
	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;
	Script_G.Movement[Script_count] = Fd;
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
200007b8:	0c00123d 	jal	200048f4 <__floatsidf>
200007bc:	02228821 	addu	s1,s1,v0
200007c0:	8f86ffac 	lw	a2,-84(gp)
200007c4:	8f87ffb0 	lw	a3,-80(gp)
200007c8:	00402021 	move	a0,v0
200007cc:	0c001139 	jal	200044e4 <__adddf3>
200007d0:	00602821 	move	a1,v1
200007d4:	00402021 	move	a0,v0
200007d8:	0c000fc7 	jal	20003f1c <__fixunsdfsi>
200007dc:	00602821 	move	a1,v1
	Script_count++;
}
200007e0:	8fbf001c 	lw	ra,28(sp)
	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;
	Script_G.Movement[Script_count] = Fd;
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
	Script_count++;
200007e4:	26100001 	addiu	s0,s0,1
	Script_count++;
	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;
	Script_G.Movement[Script_count] = Fd;
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
200007e8:	ae220000 	sw	v0,0(s1)
	Script_count++;
200007ec:	a39000fd 	sb	s0,253(gp)
}
200007f0:	8fb10018 	lw	s1,24(sp)
200007f4:	8fb00014 	lw	s0,20(sp)
200007f8:	03e00008 	jr	ra
200007fc:	27bd0020 	addiu	sp,sp,32

20000800 <leftTurn>:

	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;

	if(Path_G.Distance[path_pointer] < 0)
20000800:	24840010 	addiu	a0,a0,16
20000804:	3c024000 	lui	v0,0x4000
 */
void leftTurn(uint32_t path_pointer)
{
	int32_t pathDistance;

	Script_G.Movement[Script_count] = Lf;
20000808:	938300fd 	lbu	v1,253(gp)
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;

	if(Path_G.Distance[path_pointer] < 0)
2000080c:	244205c0 	addiu	v0,v0,1472
20000810:	00042080 	sll	a0,a0,0x2
/**
 * Insert a left turn into the script with forward movement.
 * @param path_pointer The Path pointer
 */
void leftTurn(uint32_t path_pointer)
{
20000814:	27bdffe0 	addiu	sp,sp,-32

	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;

	if(Path_G.Distance[path_pointer] < 0)
20000818:	00822021 	addu	a0,a0,v0
 */
void leftTurn(uint32_t path_pointer)
{
	int32_t pathDistance;

	Script_G.Movement[Script_count] = Lf;
2000081c:	3c024000 	lui	v0,0x4000
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
20000820:	24650040 	addiu	a1,v1,64
 */
void leftTurn(uint32_t path_pointer)
{
	int32_t pathDistance;

	Script_G.Movement[Script_count] = Lf;
20000824:	2442066c 	addiu	v0,v0,1644
/**
 * Insert a left turn into the script with forward movement.
 * @param path_pointer The Path pointer
 */
void leftTurn(uint32_t path_pointer)
{
20000828:	afb00014 	sw	s0,20(sp)
	int32_t pathDistance;

	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;
2000082c:	24700001 	addiu	s0,v1,1
 */
void leftTurn(uint32_t path_pointer)
{
	int32_t pathDistance;

	Script_G.Movement[Script_count] = Lf;
20000830:	00031880 	sll	v1,v1,0x2
20000834:	00621821 	addu	v1,v1,v0
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
20000838:	00052880 	sll	a1,a1,0x2
 */
void leftTurn(uint32_t path_pointer)
{
	int32_t pathDistance;

	Script_G.Movement[Script_count] = Lf;
2000083c:	24060003 	li	a2,3
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;

	if(Path_G.Distance[path_pointer] < 0)
20000840:	8c840000 	lw	a0,0(a0)
{
	int32_t pathDistance;

	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;
20000844:	321000ff 	andi	s0,s0,0xff
void leftTurn(uint32_t path_pointer)
{
	int32_t pathDistance;

	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
20000848:	00a22821 	addu	a1,a1,v0
 */
void leftTurn(uint32_t path_pointer)
{
	int32_t pathDistance;

	Script_G.Movement[Script_count] = Lf;
2000084c:	ac660000 	sw	a2,0(v1)
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
20000850:	240300d3 	li	v1,211
/**
 * Insert a left turn into the script with forward movement.
 * @param path_pointer The Path pointer
 */
void leftTurn(uint32_t path_pointer)
{
20000854:	afb10018 	sw	s1,24(sp)
	int32_t pathDistance;

	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
20000858:	aca30000 	sw	v1,0(a1)
/**
 * Insert a left turn into the script with forward movement.
 * @param path_pointer The Path pointer
 */
void leftTurn(uint32_t path_pointer)
{
2000085c:	afbf001c 	sw	ra,28(sp)
20000860:	00101880 	sll	v1,s0,0x2

	Script_G.Movement[Script_count] = Lf;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;

	if(Path_G.Distance[path_pointer] < 0)
20000864:	04810006 	bgez	a0,20000880 <leftTurn+0x80>
20000868:	26110040 	addiu	s1,s0,64
	{
		Script_G.Movement[Script_count] = Bd;
2000086c:	00431821 	addu	v1,v0,v1
		pathDistance = -Path_G.Distance[path_pointer];
		Script_G.Enc_counts[Script_count] = (uint32_t)(((pathDistance) * ENC_PER_GRID) + 0.5);
20000870:	00118880 	sll	s1,s1,0x2
20000874:	00042023 	negu	a0,a0
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;

	if(Path_G.Distance[path_pointer] < 0)
	{
		Script_G.Movement[Script_count] = Bd;
20000878:	08000223 	j	2000088c <leftTurn+0x8c>
2000087c:	24050002 	li	a1,2
		pathDistance = -Path_G.Distance[path_pointer];
		Script_G.Enc_counts[Script_count] = (uint32_t)(((pathDistance) * ENC_PER_GRID) + 0.5);
	}
	else if(Path_G.Distance[path_pointer] >= 0)
	{
		Script_G.Movement[Script_count] = Fd;
20000880:	00431821 	addu	v1,v0,v1
		Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000884:	00118880 	sll	s1,s1,0x2
		pathDistance = -Path_G.Distance[path_pointer];
		Script_G.Enc_counts[Script_count] = (uint32_t)(((pathDistance) * ENC_PER_GRID) + 0.5);
	}
	else if(Path_G.Distance[path_pointer] >= 0)
	{
		Script_G.Movement[Script_count] = Fd;
20000888:	24050001 	li	a1,1
2000088c:	ac650000 	sw	a1,0(v1)
		Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000890:	0c00123d 	jal	200048f4 <__floatsidf>
20000894:	02228821 	addu	s1,s1,v0
20000898:	8f86ffac 	lw	a2,-84(gp)
2000089c:	8f87ffb0 	lw	a3,-80(gp)
200008a0:	00402021 	move	a0,v0
200008a4:	0c001139 	jal	200044e4 <__adddf3>
200008a8:	00602821 	move	a1,v1
200008ac:	00402021 	move	a0,v0
200008b0:	0c000fc7 	jal	20003f1c <__fixunsdfsi>
200008b4:	00602821 	move	a1,v1
	}
	Script_count++;
}
200008b8:	8fbf001c 	lw	ra,28(sp)
	else if(Path_G.Distance[path_pointer] >= 0)
	{
		Script_G.Movement[Script_count] = Fd;
		Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
	}
	Script_count++;
200008bc:	26100001 	addiu	s0,s0,1
		Script_G.Enc_counts[Script_count] = (uint32_t)(((pathDistance) * ENC_PER_GRID) + 0.5);
	}
	else if(Path_G.Distance[path_pointer] >= 0)
	{
		Script_G.Movement[Script_count] = Fd;
		Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
200008c0:	ae220000 	sw	v0,0(s1)
	}
	Script_count++;
200008c4:	a39000fd 	sb	s0,253(gp)
}
200008c8:	8fb10018 	lw	s1,24(sp)
200008cc:	8fb00014 	lw	s0,20(sp)
200008d0:	03e00008 	jr	ra
200008d4:	27bd0020 	addiu	sp,sp,32

200008d8 <rightTurn>:

	Script_G.Movement[Script_count] = Rt;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;

	if(Path_G.Distance[path_pointer] < 0)
200008d8:	24840010 	addiu	a0,a0,16
200008dc:	3c024000 	lui	v0,0x4000
 */
void rightTurn(uint32_t path_pointer)
{
	int32_t pathDistance;

	Script_G.Movement[Script_count] = Rt;
200008e0:	938300fd 	lbu	v1,253(gp)
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;

	if(Path_G.Distance[path_pointer] < 0)
200008e4:	244205c0 	addiu	v0,v0,1472
200008e8:	00042080 	sll	a0,a0,0x2
/**
 * Insert a right turn into the script with forward movement.
 * @param path_pointer The path pointer
 */
void rightTurn(uint32_t path_pointer)
{
200008ec:	27bdffe0 	addiu	sp,sp,-32

	Script_G.Movement[Script_count] = Rt;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;

	if(Path_G.Distance[path_pointer] < 0)
200008f0:	00822021 	addu	a0,a0,v0
 */
void rightTurn(uint32_t path_pointer)
{
	int32_t pathDistance;

	Script_G.Movement[Script_count] = Rt;
200008f4:	3c024000 	lui	v0,0x4000
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
200008f8:	24650040 	addiu	a1,v1,64
 */
void rightTurn(uint32_t path_pointer)
{
	int32_t pathDistance;

	Script_G.Movement[Script_count] = Rt;
200008fc:	2442066c 	addiu	v0,v0,1644
/**
 * Insert a right turn into the script with forward movement.
 * @param path_pointer The path pointer
 */
void rightTurn(uint32_t path_pointer)
{
20000900:	afb00014 	sw	s0,20(sp)
	int32_t pathDistance;

	Script_G.Movement[Script_count] = Rt;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;
20000904:	24700001 	addiu	s0,v1,1
 */
void rightTurn(uint32_t path_pointer)
{
	int32_t pathDistance;

	Script_G.Movement[Script_count] = Rt;
20000908:	00031880 	sll	v1,v1,0x2
2000090c:	00621821 	addu	v1,v1,v0
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
20000910:	00052880 	sll	a1,a1,0x2
 */
void rightTurn(uint32_t path_pointer)
{
	int32_t pathDistance;

	Script_G.Movement[Script_count] = Rt;
20000914:	24060004 	li	a2,4
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;

	if(Path_G.Distance[path_pointer] < 0)
20000918:	8c840000 	lw	a0,0(a0)
{
	int32_t pathDistance;

	Script_G.Movement[Script_count] = Rt;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;
2000091c:	321000ff 	andi	s0,s0,0xff
void rightTurn(uint32_t path_pointer)
{
	int32_t pathDistance;

	Script_G.Movement[Script_count] = Rt;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
20000920:	00a22821 	addu	a1,a1,v0
 */
void rightTurn(uint32_t path_pointer)
{
	int32_t pathDistance;

	Script_G.Movement[Script_count] = Rt;
20000924:	ac660000 	sw	a2,0(v1)
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
20000928:	240300d3 	li	v1,211
/**
 * Insert a right turn into the script with forward movement.
 * @param path_pointer The path pointer
 */
void rightTurn(uint32_t path_pointer)
{
2000092c:	afb10018 	sw	s1,24(sp)
	int32_t pathDistance;

	Script_G.Movement[Script_count] = Rt;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
20000930:	aca30000 	sw	v1,0(a1)
/**
 * Insert a right turn into the script with forward movement.
 * @param path_pointer The path pointer
 */
void rightTurn(uint32_t path_pointer)
{
20000934:	afbf001c 	sw	ra,28(sp)
20000938:	00101880 	sll	v1,s0,0x2

	Script_G.Movement[Script_count] = Rt;
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;

	if(Path_G.Distance[path_pointer] < 0)
2000093c:	04810006 	bgez	a0,20000958 <rightTurn+0x80>
20000940:	26110040 	addiu	s1,s0,64
	{
		Script_G.Movement[Script_count] = Bd;
20000944:	00431821 	addu	v1,v0,v1
		pathDistance = -Path_G.Distance[path_pointer];
		Script_G.Enc_counts[Script_count] = (uint32_t)(((pathDistance) * ENC_PER_GRID) + 0.5);
20000948:	00118880 	sll	s1,s1,0x2
2000094c:	00042023 	negu	a0,a0
	Script_G.Enc_counts[Script_count] = TURN_ENC_COUNT;
	Script_count++;

	if(Path_G.Distance[path_pointer] < 0)
	{
		Script_G.Movement[Script_count] = Bd;
20000950:	08000259 	j	20000964 <rightTurn+0x8c>
20000954:	24050002 	li	a1,2
		pathDistance = -Path_G.Distance[path_pointer];
		Script_G.Enc_counts[Script_count] = (uint32_t)(((pathDistance) * ENC_PER_GRID) + 0.5);
	}
	else if(Path_G.Distance[path_pointer] >= 0)
	{
		Script_G.Movement[Script_count] = Fd;
20000958:	00431821 	addu	v1,v0,v1
		Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
2000095c:	00118880 	sll	s1,s1,0x2
		pathDistance = -Path_G.Distance[path_pointer];
		Script_G.Enc_counts[Script_count] = (uint32_t)(((pathDistance) * ENC_PER_GRID) + 0.5);
	}
	else if(Path_G.Distance[path_pointer] >= 0)
	{
		Script_G.Movement[Script_count] = Fd;
20000960:	24050001 	li	a1,1
20000964:	ac650000 	sw	a1,0(v1)
		Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000968:	0c00123d 	jal	200048f4 <__floatsidf>
2000096c:	02228821 	addu	s1,s1,v0
20000970:	8f86ffac 	lw	a2,-84(gp)
20000974:	8f87ffb0 	lw	a3,-80(gp)
20000978:	00402021 	move	a0,v0
2000097c:	0c001139 	jal	200044e4 <__adddf3>
20000980:	00602821 	move	a1,v1
20000984:	00402021 	move	a0,v0
20000988:	0c000fc7 	jal	20003f1c <__fixunsdfsi>
2000098c:	00602821 	move	a1,v1
	}
	Script_count++;
}
20000990:	8fbf001c 	lw	ra,28(sp)
	else if(Path_G.Distance[path_pointer] >= 0)
	{
		Script_G.Movement[Script_count] = Fd;
		Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
	}
	Script_count++;
20000994:	26100001 	addiu	s0,s0,1
		Script_G.Enc_counts[Script_count] = (uint32_t)(((pathDistance) * ENC_PER_GRID) + 0.5);
	}
	else if(Path_G.Distance[path_pointer] >= 0)
	{
		Script_G.Movement[Script_count] = Fd;
		Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000998:	ae220000 	sw	v0,0(s1)
	}
	Script_count++;
2000099c:	a39000fd 	sb	s0,253(gp)
}
200009a0:	8fb10018 	lw	s1,24(sp)
200009a4:	8fb00014 	lw	s0,20(sp)
200009a8:	03e00008 	jr	ra
200009ac:	27bd0020 	addiu	sp,sp,32

200009b0 <Script_Keeper_Update>:
 * Converts the Path into a Script and monitors the Script state.
 */
void Script_Keeper_Update(void)
{
	/* Check an update is required*/
	if(Script_update == True)
200009b0:	8f8200dc 	lw	v0,220(gp)

/**
 * Converts the Path into a Script and monitors the Script state.
 */
void Script_Keeper_Update(void)
{
200009b4:	27bdff88 	addiu	sp,sp,-120
	/* Check an update is required*/
	if(Script_update == True)
200009b8:	24030001 	li	v1,1

/**
 * Converts the Path into a Script and monitors the Script state.
 */
void Script_Keeper_Update(void)
{
200009bc:	afbf0074 	sw	ra,116(sp)
200009c0:	afbe0070 	sw	s8,112(sp)
200009c4:	afb7006c 	sw	s7,108(sp)
200009c8:	afb60068 	sw	s6,104(sp)
200009cc:	afb50064 	sw	s5,100(sp)
200009d0:	afb40060 	sw	s4,96(sp)
200009d4:	afb3005c 	sw	s3,92(sp)
200009d8:	afb20058 	sw	s2,88(sp)
200009dc:	afb10054 	sw	s1,84(sp)
	/* Check an update is required*/
	if(Script_update == True)
200009e0:	144301bc 	bne	v0,v1,200010d4 <Script_Keeper_Update+0x724>
200009e4:	afb00050 	sw	s0,80(sp)
 * @param path_pointer The Path pointer
 */
void ahead(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Fd;
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
200009e8:	8f9effac 	lw	s8,-84(gp)
200009ec:	8f97ffb0 	lw	s7,-80(gp)
/**
 * Insert the Stop command into the Script.
 */
void stopScript(void)
{
	Script_G.Movement[Script_count] = Stp;
200009f0:	3c104000 	lui	s0,0x4000
200009f4:	2610066c 	addiu	s0,s0,1644
 * Converts the Path into a Script and monitors the Script state.
 */
void Script_Keeper_Update(void)
{
	/* Check an update is required*/
	if(Script_update == True)
200009f8:	3c154000 	lui	s5,0x4000
200009fc:	26b50600 	addiu	s5,s5,1536
20000a00:	00009021 	move	s2,zero
					break;
				}
				Orientation_G = East;
				break;
			case West:
				switch(Previous_Direction)
20000a04:	24140002 	li	s4,2
 * Insert the Forward command for a set distance.
 * @param path_pointer The Path pointer
 */
void ahead(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Fd;
20000a08:	24130001 	li	s3,1
 * @param path_pointer The Path pointer
 */
void backOff(uint32_t path_pointer)
{
	int32_t pathDistance;
	Script_G.Movement[Script_count] = Bd;
20000a0c:	0200b021 	move	s6,s0
	pathDistance = -Path_G.Distance[path_pointer];
	if(pathDistance >= 0)
	{
		Script_G.Enc_counts[Script_count] = (uint32_t)(((pathDistance) * ENC_PER_GRID) + 0.5);
20000a10:	afbe0010 	sw	s8,16(sp)
20000a14:	afb70014 	sw	s7,20(sp)
 * @param path_pointer The Path pointer
 */
void ahead(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Fd;
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000a18:	afbe0018 	sw	s8,24(sp)
20000a1c:	afb7001c 	sw	s7,28(sp)
	int32_t pathDistance;
	Script_G.Movement[Script_count] = Bd;
	pathDistance = -Path_G.Distance[path_pointer];
	if(pathDistance >= 0)
	{
		Script_G.Enc_counts[Script_count] = (uint32_t)(((pathDistance) * ENC_PER_GRID) + 0.5);
20000a20:	afbe0020 	sw	s8,32(sp)
20000a24:	afb70024 	sw	s7,36(sp)
 * @param path_pointer The Path pointer
 */
void ahead(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Fd;
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000a28:	afbe0028 	sw	s8,40(sp)
20000a2c:	afb7002c 	sw	s7,44(sp)
	int32_t pathDistance;
	Script_G.Movement[Script_count] = Bd;
	pathDistance = -Path_G.Distance[path_pointer];
	if(pathDistance >= 0)
	{
		Script_G.Enc_counts[Script_count] = (uint32_t)(((pathDistance) * ENC_PER_GRID) + 0.5);
20000a30:	afbe0030 	sw	s8,48(sp)
20000a34:	afb70034 	sw	s7,52(sp)
 * @param path_pointer The Path pointer
 */
void ahead(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Fd;
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000a38:	afbe0038 	sw	s8,56(sp)
20000a3c:	afb7003c 	sw	s7,60(sp)
	int32_t pathDistance;
	Script_G.Movement[Script_count] = Bd;
	pathDistance = -Path_G.Distance[path_pointer];
	if(pathDistance >= 0)
	{
		Script_G.Enc_counts[Script_count] = (uint32_t)(((pathDistance) * ENC_PER_GRID) + 0.5);
20000a40:	afbe0040 	sw	s8,64(sp)
20000a44:	afb70044 	sw	s7,68(sp)
			/* Track the previous direction */
			Compass Previous_Direction;
			Previous_Direction = Orientation_G;

			/* Generate the Script based on the previous and "this" heading */
			switch(Path_G.Heading[i])
20000a48:	8ea3ffc0 	lw	v1,-64(s5)
20000a4c:	24040004 	li	a0,4
		/* Analyse the Path_G to generate the Script */
		for(uint8_t i = 0; i < PATH_MAX; i++)
		{
			/* Track the previous direction */
			Compass Previous_Direction;
			Previous_Direction = Orientation_G;
20000a50:	8f820050 	lw	v0,80(gp)

			/* Generate the Script based on the previous and "this" heading */
			switch(Path_G.Heading[i])
20000a54:	10640118 	beq	v1,a0,20000eb8 <Script_Keeper_Update+0x508>
20000a58:	2c640005 	sltiu	a0,v1,5
20000a5c:	10800009 	beqz	a0,20000a84 <Script_Keeper_Update+0xd4>
20000a60:	00000000 	nop
20000a64:	10740068 	beq	v1,s4,20000c08 <Script_Keeper_Update+0x258>
20000a68:	2c640003 	sltiu	a0,v1,3
20000a6c:	108000bc 	beqz	a0,20000d60 <Script_Keeper_Update+0x3b0>
20000a70:	00000000 	nop
20000a74:	14730188 	bne	v1,s3,20001098 <Script_Keeper_Update+0x6e8>
20000a78:	00000000 	nop
20000a7c:	080002ab 	j	20000aac <Script_Keeper_Update+0xfc>
20000a80:	00000000 	nop
20000a84:	24020006 	li	v0,6
20000a88:	1062016b 	beq	v1,v0,20001038 <Script_Keeper_Update+0x688>
20000a8c:	00000000 	nop
20000a90:	2c620006 	sltiu	v0,v1,6
20000a94:	14400173 	bnez	v0,20001064 <Script_Keeper_Update+0x6b4>
20000a98:	24040007 	li	a0,7
20000a9c:	1464017e 	bne	v1,a0,20001098 <Script_Keeper_Update+0x6e8>
20000aa0:	00000000 	nop
20000aa4:	08000403 	j	2000100c <Script_Keeper_Update+0x65c>
20000aa8:	00000000 	nop
			{
			case North:
				/* TODO: Reverse manoeuvre based on NEGATIVE Path distances. Recommend using if(Path.distance < 0) */
				switch(Previous_Direction)
20000aac:	1054003f 	beq	v0,s4,20000bac <Script_Keeper_Update+0x1fc>
20000ab0:	2c430003 	sltiu	v1,v0,3
20000ab4:	10600005 	beqz	v1,20000acc <Script_Keeper_Update+0x11c>
20000ab8:	00000000 	nop
20000abc:	14530047 	bne	v0,s3,20000bdc <Script_Keeper_Update+0x22c>
20000ac0:	00000000 	nop
20000ac4:	080002ba 	j	20000ae8 <Script_Keeper_Update+0x138>
20000ac8:	00000000 	nop
20000acc:	24030003 	li	v1,3
20000ad0:	1043003e 	beq	v0,v1,20000bcc <Script_Keeper_Update+0x21c>
20000ad4:	24040004 	li	a0,4
20000ad8:	14440040 	bne	v0,a0,20000bdc <Script_Keeper_Update+0x22c>
20000adc:	00000000 	nop
20000ae0:	080002ef 	j	20000bbc <Script_Keeper_Update+0x20c>
20000ae4:	00000000 	nop
				{
				case North:
					if(Path_G.Distance[i] < 0)
20000ae8:	8ea40000 	lw	a0,0(s5)
20000aec:	939100fd 	lbu	s1,253(gp)
20000af0:	0481001a 	bgez	a0,20000b5c <Script_Keeper_Update+0x1ac>
20000af4:	00111080 	sll	v0,s1,0x2
 * @param path_pointer The Path pointer
 */
void backOff(uint32_t path_pointer)
{
	int32_t pathDistance;
	Script_G.Movement[Script_count] = Bd;
20000af8:	02021021 	addu	v0,s0,v0
	pathDistance = -Path_G.Distance[path_pointer];
20000afc:	00042023 	negu	a0,a0
 * @param path_pointer The Path pointer
 */
void backOff(uint32_t path_pointer)
{
	int32_t pathDistance;
	Script_G.Movement[Script_count] = Bd;
20000b00:	ac540000 	sw	s4,0(v0)
	pathDistance = -Path_G.Distance[path_pointer];
	if(pathDistance >= 0)
20000b04:	04800010 	bltz	a0,20000b48 <Script_Keeper_Update+0x198>
20000b08:	26280040 	addiu	t0,s1,64
	{
		Script_G.Enc_counts[Script_count] = (uint32_t)(((pathDistance) * ENC_PER_GRID) + 0.5);
20000b0c:	00084080 	sll	t0,t0,0x2
20000b10:	02084021 	addu	t0,s0,t0
20000b14:	0c00123d 	jal	200048f4 <__floatsidf>
20000b18:	afa80048 	sw	t0,72(sp)
20000b1c:	8fa60040 	lw	a2,64(sp)
20000b20:	8fa70044 	lw	a3,68(sp)
20000b24:	00402021 	move	a0,v0
20000b28:	0c001139 	jal	200044e4 <__adddf3>
20000b2c:	00602821 	move	a1,v1
20000b30:	00402021 	move	a0,v0
20000b34:	0c000fc7 	jal	20003f1c <__fixunsdfsi>
20000b38:	00602821 	move	a1,v1
20000b3c:	8fa80048 	lw	t0,72(sp)
20000b40:	080002d5 	j	20000b54 <Script_Keeper_Update+0x1a4>
20000b44:	ad020000 	sw	v0,0(t0)
	}
	else
	{
		Script_G.Enc_counts[Script_count] = 0;
20000b48:	00084080 	sll	t0,t0,0x2
20000b4c:	02084021 	addu	t0,s0,t0
20000b50:	ad000000 	sw	zero,0(t0)
	}
	Script_count++;
20000b54:	080002e9 	j	20000ba4 <Script_Keeper_Update+0x1f4>
20000b58:	26310001 	addiu	s1,s1,1
 * @param path_pointer The Path pointer
 */
void ahead(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Fd;
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000b5c:	26280040 	addiu	t0,s1,64
 * Insert the Forward command for a set distance.
 * @param path_pointer The Path pointer
 */
void ahead(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Fd;
20000b60:	02021021 	addu	v0,s0,v0
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000b64:	00084080 	sll	t0,t0,0x2
20000b68:	02084021 	addu	t0,s0,t0
 * Insert the Forward command for a set distance.
 * @param path_pointer The Path pointer
 */
void ahead(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Fd;
20000b6c:	ac530000 	sw	s3,0(v0)
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000b70:	0c00123d 	jal	200048f4 <__floatsidf>
20000b74:	afa80048 	sw	t0,72(sp)
20000b78:	8fa60038 	lw	a2,56(sp)
20000b7c:	8fa7003c 	lw	a3,60(sp)
20000b80:	00402021 	move	a0,v0
20000b84:	0c001139 	jal	200044e4 <__adddf3>
20000b88:	00602821 	move	a1,v1
20000b8c:	00402021 	move	a0,v0
20000b90:	0c000fc7 	jal	20003f1c <__fixunsdfsi>
20000b94:	00602821 	move	a1,v1
20000b98:	8fa80048 	lw	t0,72(sp)
	Script_count++;
20000b9c:	26310001 	addiu	s1,s1,1
 * @param path_pointer The Path pointer
 */
void ahead(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Fd;
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000ba0:	ad020000 	sw	v0,0(t0)
	Script_count++;
20000ba4:	08000300 	j	20000c00 <Script_Keeper_Update+0x250>
20000ba8:	a39100fd 	sb	s1,253(gp)
					{
						ahead(i);
					}
					break;
				case South:
					aboutTurn(i);
20000bac:	0c0001c7 	jal	2000071c <aboutTurn>
20000bb0:	02402021 	move	a0,s2
					break;
20000bb4:	0800042f 	j	200010bc <Script_Keeper_Update+0x70c>
20000bb8:	af930050 	sw	s3,80(gp)
				case West:
					rightTurn(i);
20000bbc:	0c000236 	jal	200008d8 <rightTurn>
20000bc0:	02402021 	move	a0,s2
					break;
20000bc4:	0800042f 	j	200010bc <Script_Keeper_Update+0x70c>
20000bc8:	af930050 	sw	s3,80(gp)
				case East:
					leftTurn(i);
20000bcc:	0c000200 	jal	20000800 <leftTurn>
20000bd0:	02402021 	move	a0,s2
					break;
20000bd4:	0800042f 	j	200010bc <Script_Keeper_Update+0x70c>
20000bd8:	af930050 	sw	s3,80(gp)
/**
 * Insert the Stop command into the Script.
 */
void stopScript(void)
{
	Script_G.Movement[Script_count] = Stp;
20000bdc:	938200fd 	lbu	v0,253(gp)
20000be0:	00000000 	nop
	Script_G.Enc_counts[Script_count] = 0;
20000be4:	24430040 	addiu	v1,v0,64
20000be8:	00031880 	sll	v1,v1,0x2
/**
 * Insert the Stop command into the Script.
 */
void stopScript(void)
{
	Script_G.Movement[Script_count] = Stp;
20000bec:	00021080 	sll	v0,v0,0x2
20000bf0:	00501021 	addu	v0,v0,s0
	Script_G.Enc_counts[Script_count] = 0;
20000bf4:	00701821 	addu	v1,v1,s0
/**
 * Insert the Stop command into the Script.
 */
void stopScript(void)
{
	Script_G.Movement[Script_count] = Stp;
20000bf8:	ac400000 	sw	zero,0(v0)
	Script_G.Enc_counts[Script_count] = 0;
20000bfc:	ac600000 	sw	zero,0(v1)
				default:
					stopScript();
					break;
				}
				Orientation_G = North;
				break;
20000c00:	0800042f 	j	200010bc <Script_Keeper_Update+0x70c>
20000c04:	af930050 	sw	s3,80(gp)
			case South:
				switch(Previous_Direction)
20000c08:	1054000d 	beq	v0,s4,20000c40 <Script_Keeper_Update+0x290>
20000c0c:	2c430003 	sltiu	v1,v0,3
20000c10:	10600005 	beqz	v1,20000c28 <Script_Keeper_Update+0x278>
20000c14:	24030003 	li	v1,3
20000c18:	14530046 	bne	v0,s3,20000d34 <Script_Keeper_Update+0x384>
20000c1c:	00000000 	nop
20000c20:	08000341 	j	20000d04 <Script_Keeper_Update+0x354>
20000c24:	00000000 	nop
20000c28:	1043003a 	beq	v0,v1,20000d14 <Script_Keeper_Update+0x364>
20000c2c:	24040004 	li	a0,4
20000c30:	14440040 	bne	v0,a0,20000d34 <Script_Keeper_Update+0x384>
20000c34:	00000000 	nop
20000c38:	08000349 	j	20000d24 <Script_Keeper_Update+0x374>
20000c3c:	00000000 	nop
				{
				case South:
					if(Path_G.Distance[i] < 0)
20000c40:	8ea40000 	lw	a0,0(s5)
20000c44:	939100fd 	lbu	s1,253(gp)
20000c48:	0481001a 	bgez	a0,20000cb4 <Script_Keeper_Update+0x304>
20000c4c:	00111080 	sll	v0,s1,0x2
 * @param path_pointer The Path pointer
 */
void backOff(uint32_t path_pointer)
{
	int32_t pathDistance;
	Script_G.Movement[Script_count] = Bd;
20000c50:	02c21021 	addu	v0,s6,v0
	pathDistance = -Path_G.Distance[path_pointer];
20000c54:	00042023 	negu	a0,a0
 * @param path_pointer The Path pointer
 */
void backOff(uint32_t path_pointer)
{
	int32_t pathDistance;
	Script_G.Movement[Script_count] = Bd;
20000c58:	ac540000 	sw	s4,0(v0)
	pathDistance = -Path_G.Distance[path_pointer];
	if(pathDistance >= 0)
20000c5c:	04800010 	bltz	a0,20000ca0 <Script_Keeper_Update+0x2f0>
20000c60:	26280040 	addiu	t0,s1,64
	{
		Script_G.Enc_counts[Script_count] = (uint32_t)(((pathDistance) * ENC_PER_GRID) + 0.5);
20000c64:	00084080 	sll	t0,t0,0x2
20000c68:	01164021 	addu	t0,t0,s6
20000c6c:	0c00123d 	jal	200048f4 <__floatsidf>
20000c70:	afa80048 	sw	t0,72(sp)
20000c74:	8fa60020 	lw	a2,32(sp)
20000c78:	8fa70024 	lw	a3,36(sp)
20000c7c:	00402021 	move	a0,v0
20000c80:	0c001139 	jal	200044e4 <__adddf3>
20000c84:	00602821 	move	a1,v1
20000c88:	00402021 	move	a0,v0
20000c8c:	0c000fc7 	jal	20003f1c <__fixunsdfsi>
20000c90:	00602821 	move	a1,v1
20000c94:	8fa80048 	lw	t0,72(sp)
20000c98:	0800032b 	j	20000cac <Script_Keeper_Update+0x2fc>
20000c9c:	ad020000 	sw	v0,0(t0)
	}
	else
	{
		Script_G.Enc_counts[Script_count] = 0;
20000ca0:	00084080 	sll	t0,t0,0x2
20000ca4:	01164021 	addu	t0,t0,s6
20000ca8:	ad000000 	sw	zero,0(t0)
	}
	Script_count++;
20000cac:	0800033f 	j	20000cfc <Script_Keeper_Update+0x34c>
20000cb0:	26310001 	addiu	s1,s1,1
 * @param path_pointer The Path pointer
 */
void ahead(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Fd;
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000cb4:	26280040 	addiu	t0,s1,64
 * Insert the Forward command for a set distance.
 * @param path_pointer The Path pointer
 */
void ahead(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Fd;
20000cb8:	02021021 	addu	v0,s0,v0
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000cbc:	00084080 	sll	t0,t0,0x2
20000cc0:	02084021 	addu	t0,s0,t0
 * Insert the Forward command for a set distance.
 * @param path_pointer The Path pointer
 */
void ahead(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Fd;
20000cc4:	ac530000 	sw	s3,0(v0)
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000cc8:	0c00123d 	jal	200048f4 <__floatsidf>
20000ccc:	afa80048 	sw	t0,72(sp)
20000cd0:	8fa60018 	lw	a2,24(sp)
20000cd4:	8fa7001c 	lw	a3,28(sp)
20000cd8:	00402021 	move	a0,v0
20000cdc:	0c001139 	jal	200044e4 <__adddf3>
20000ce0:	00602821 	move	a1,v1
20000ce4:	00402021 	move	a0,v0
20000ce8:	0c000fc7 	jal	20003f1c <__fixunsdfsi>
20000cec:	00602821 	move	a1,v1
20000cf0:	8fa80048 	lw	t0,72(sp)
	Script_count++;
20000cf4:	26310001 	addiu	s1,s1,1
 * @param path_pointer The Path pointer
 */
void ahead(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Fd;
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000cf8:	ad020000 	sw	v0,0(t0)
	Script_count++;
20000cfc:	08000356 	j	20000d58 <Script_Keeper_Update+0x3a8>
20000d00:	a39100fd 	sb	s1,253(gp)
					{
						ahead(i);
					}
					break;
				case North:
					aboutTurn(i);
20000d04:	0c0001c7 	jal	2000071c <aboutTurn>
20000d08:	02402021 	move	a0,s2
					break;
20000d0c:	0800042f 	j	200010bc <Script_Keeper_Update+0x70c>
20000d10:	af940050 	sw	s4,80(gp)
				case East:
					rightTurn(i);
20000d14:	0c000236 	jal	200008d8 <rightTurn>
20000d18:	02402021 	move	a0,s2
					break;
20000d1c:	0800042f 	j	200010bc <Script_Keeper_Update+0x70c>
20000d20:	af940050 	sw	s4,80(gp)
				case West:
					leftTurn(i);
20000d24:	0c000200 	jal	20000800 <leftTurn>
20000d28:	02402021 	move	a0,s2
					break;
20000d2c:	0800042f 	j	200010bc <Script_Keeper_Update+0x70c>
20000d30:	af940050 	sw	s4,80(gp)
/**
 * Insert the Stop command into the Script.
 */
void stopScript(void)
{
	Script_G.Movement[Script_count] = Stp;
20000d34:	938200fd 	lbu	v0,253(gp)
20000d38:	00000000 	nop
	Script_G.Enc_counts[Script_count] = 0;
20000d3c:	24430040 	addiu	v1,v0,64
20000d40:	00031880 	sll	v1,v1,0x2
/**
 * Insert the Stop command into the Script.
 */
void stopScript(void)
{
	Script_G.Movement[Script_count] = Stp;
20000d44:	00021080 	sll	v0,v0,0x2
20000d48:	00501021 	addu	v0,v0,s0
	Script_G.Enc_counts[Script_count] = 0;
20000d4c:	00701821 	addu	v1,v1,s0
/**
 * Insert the Stop command into the Script.
 */
void stopScript(void)
{
	Script_G.Movement[Script_count] = Stp;
20000d50:	ac400000 	sw	zero,0(v0)
	Script_G.Enc_counts[Script_count] = 0;
20000d54:	ac600000 	sw	zero,0(v1)
				default:
					stopScript();
					break;
				}
				Orientation_G = South;
				break;
20000d58:	0800042f 	j	200010bc <Script_Keeper_Update+0x70c>
20000d5c:	af940050 	sw	s4,80(gp)
			case East:
				switch(Previous_Direction)
20000d60:	10540046 	beq	v0,s4,20000e7c <Script_Keeper_Update+0x4cc>
20000d64:	2c430003 	sltiu	v1,v0,3
20000d68:	10600005 	beqz	v1,20000d80 <Script_Keeper_Update+0x3d0>
20000d6c:	24030003 	li	v1,3
20000d70:	14530046 	bne	v0,s3,20000e8c <Script_Keeper_Update+0x4dc>
20000d74:	00000000 	nop
20000d78:	0800039b 	j	20000e6c <Script_Keeper_Update+0x4bc>
20000d7c:	00000000 	nop
20000d80:	10430005 	beq	v0,v1,20000d98 <Script_Keeper_Update+0x3e8>
20000d84:	24040004 	li	a0,4
20000d88:	14440040 	bne	v0,a0,20000e8c <Script_Keeper_Update+0x4dc>
20000d8c:	00000000 	nop
20000d90:	08000397 	j	20000e5c <Script_Keeper_Update+0x4ac>
20000d94:	00000000 	nop
				{
				case East:
					if(Path_G.Distance[i] < 0)
20000d98:	8ea40000 	lw	a0,0(s5)
20000d9c:	939100fd 	lbu	s1,253(gp)
20000da0:	0481001a 	bgez	a0,20000e0c <Script_Keeper_Update+0x45c>
20000da4:	00111080 	sll	v0,s1,0x2
 * @param path_pointer The Path pointer
 */
void backOff(uint32_t path_pointer)
{
	int32_t pathDistance;
	Script_G.Movement[Script_count] = Bd;
20000da8:	02c21021 	addu	v0,s6,v0
	pathDistance = -Path_G.Distance[path_pointer];
20000dac:	00042023 	negu	a0,a0
 * @param path_pointer The Path pointer
 */
void backOff(uint32_t path_pointer)
{
	int32_t pathDistance;
	Script_G.Movement[Script_count] = Bd;
20000db0:	ac540000 	sw	s4,0(v0)
	pathDistance = -Path_G.Distance[path_pointer];
	if(pathDistance >= 0)
20000db4:	04800010 	bltz	a0,20000df8 <Script_Keeper_Update+0x448>
20000db8:	26280040 	addiu	t0,s1,64
	{
		Script_G.Enc_counts[Script_count] = (uint32_t)(((pathDistance) * ENC_PER_GRID) + 0.5);
20000dbc:	00084080 	sll	t0,t0,0x2
20000dc0:	01164021 	addu	t0,t0,s6
20000dc4:	0c00123d 	jal	200048f4 <__floatsidf>
20000dc8:	afa80048 	sw	t0,72(sp)
20000dcc:	8fa60030 	lw	a2,48(sp)
20000dd0:	8fa70034 	lw	a3,52(sp)
20000dd4:	00402021 	move	a0,v0
20000dd8:	0c001139 	jal	200044e4 <__adddf3>
20000ddc:	00602821 	move	a1,v1
20000de0:	00402021 	move	a0,v0
20000de4:	0c000fc7 	jal	20003f1c <__fixunsdfsi>
20000de8:	00602821 	move	a1,v1
20000dec:	8fa80048 	lw	t0,72(sp)
20000df0:	08000381 	j	20000e04 <Script_Keeper_Update+0x454>
20000df4:	ad020000 	sw	v0,0(t0)
	}
	else
	{
		Script_G.Enc_counts[Script_count] = 0;
20000df8:	00084080 	sll	t0,t0,0x2
20000dfc:	01164021 	addu	t0,t0,s6
20000e00:	ad000000 	sw	zero,0(t0)
	}
	Script_count++;
20000e04:	08000395 	j	20000e54 <Script_Keeper_Update+0x4a4>
20000e08:	26310001 	addiu	s1,s1,1
 * @param path_pointer The Path pointer
 */
void ahead(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Fd;
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000e0c:	26280040 	addiu	t0,s1,64
 * Insert the Forward command for a set distance.
 * @param path_pointer The Path pointer
 */
void ahead(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Fd;
20000e10:	02021021 	addu	v0,s0,v0
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000e14:	00084080 	sll	t0,t0,0x2
20000e18:	02084021 	addu	t0,s0,t0
 * Insert the Forward command for a set distance.
 * @param path_pointer The Path pointer
 */
void ahead(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Fd;
20000e1c:	ac530000 	sw	s3,0(v0)
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000e20:	0c00123d 	jal	200048f4 <__floatsidf>
20000e24:	afa80048 	sw	t0,72(sp)
20000e28:	8fa60028 	lw	a2,40(sp)
20000e2c:	8fa7002c 	lw	a3,44(sp)
20000e30:	00402021 	move	a0,v0
20000e34:	0c001139 	jal	200044e4 <__adddf3>
20000e38:	00602821 	move	a1,v1
20000e3c:	00402021 	move	a0,v0
20000e40:	0c000fc7 	jal	20003f1c <__fixunsdfsi>
20000e44:	00602821 	move	a1,v1
20000e48:	8fa80048 	lw	t0,72(sp)
	Script_count++;
20000e4c:	26310001 	addiu	s1,s1,1
 * @param path_pointer The Path pointer
 */
void ahead(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Fd;
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000e50:	ad020000 	sw	v0,0(t0)
	Script_count++;
20000e54:	080003ac 	j	20000eb0 <Script_Keeper_Update+0x500>
20000e58:	a39100fd 	sb	s1,253(gp)
					{
						ahead(i);
					}
					break;
				case West:
					aboutTurn(i);
20000e5c:	0c0001c7 	jal	2000071c <aboutTurn>
20000e60:	02402021 	move	a0,s2
					break;
20000e64:	08000401 	j	20001004 <Script_Keeper_Update+0x654>
20000e68:	24020003 	li	v0,3
				case North:
					rightTurn(i);
20000e6c:	0c000236 	jal	200008d8 <rightTurn>
20000e70:	02402021 	move	a0,s2
					break;
20000e74:	08000401 	j	20001004 <Script_Keeper_Update+0x654>
20000e78:	24020003 	li	v0,3
				case South:
					leftTurn(i);
20000e7c:	0c000200 	jal	20000800 <leftTurn>
20000e80:	02402021 	move	a0,s2
					break;
20000e84:	08000401 	j	20001004 <Script_Keeper_Update+0x654>
20000e88:	24020003 	li	v0,3
/**
 * Insert the Stop command into the Script.
 */
void stopScript(void)
{
	Script_G.Movement[Script_count] = Stp;
20000e8c:	938200fd 	lbu	v0,253(gp)
20000e90:	00000000 	nop
	Script_G.Enc_counts[Script_count] = 0;
20000e94:	24430040 	addiu	v1,v0,64
20000e98:	00031880 	sll	v1,v1,0x2
/**
 * Insert the Stop command into the Script.
 */
void stopScript(void)
{
	Script_G.Movement[Script_count] = Stp;
20000e9c:	00021080 	sll	v0,v0,0x2
20000ea0:	00501021 	addu	v0,v0,s0
	Script_G.Enc_counts[Script_count] = 0;
20000ea4:	00701821 	addu	v1,v1,s0
/**
 * Insert the Stop command into the Script.
 */
void stopScript(void)
{
	Script_G.Movement[Script_count] = Stp;
20000ea8:	ac400000 	sw	zero,0(v0)
	Script_G.Enc_counts[Script_count] = 0;
20000eac:	ac600000 	sw	zero,0(v1)
				case X:
				default:
					stopScript();
					break;
				}
				Orientation_G = East;
20000eb0:	08000401 	j	20001004 <Script_Keeper_Update+0x654>
20000eb4:	24020003 	li	v0,3
				break;
			case West:
				switch(Previous_Direction)
20000eb8:	10540040 	beq	v0,s4,20000fbc <Script_Keeper_Update+0x60c>
20000ebc:	2c430003 	sltiu	v1,v0,3
20000ec0:	10600005 	beqz	v1,20000ed8 <Script_Keeper_Update+0x528>
20000ec4:	24030003 	li	v1,3
20000ec8:	14530044 	bne	v0,s3,20000fdc <Script_Keeper_Update+0x62c>
20000ecc:	00000000 	nop
20000ed0:	080003f3 	j	20000fcc <Script_Keeper_Update+0x61c>
20000ed4:	00000000 	nop
20000ed8:	10430034 	beq	v0,v1,20000fac <Script_Keeper_Update+0x5fc>
20000edc:	24040004 	li	a0,4
20000ee0:	1444003e 	bne	v0,a0,20000fdc <Script_Keeper_Update+0x62c>
20000ee4:	00000000 	nop
				{
				case West:
					if(Path_G.Distance[i] < 0)
20000ee8:	8ea40000 	lw	a0,0(s5)
20000eec:	939100fd 	lbu	s1,253(gp)
20000ef0:	0481001a 	bgez	a0,20000f5c <Script_Keeper_Update+0x5ac>
20000ef4:	00111080 	sll	v0,s1,0x2
 * @param path_pointer The Path pointer
 */
void backOff(uint32_t path_pointer)
{
	int32_t pathDistance;
	Script_G.Movement[Script_count] = Bd;
20000ef8:	02c21021 	addu	v0,s6,v0
	pathDistance = -Path_G.Distance[path_pointer];
20000efc:	00042023 	negu	a0,a0
 * @param path_pointer The Path pointer
 */
void backOff(uint32_t path_pointer)
{
	int32_t pathDistance;
	Script_G.Movement[Script_count] = Bd;
20000f00:	ac540000 	sw	s4,0(v0)
	pathDistance = -Path_G.Distance[path_pointer];
	if(pathDistance >= 0)
20000f04:	04800010 	bltz	a0,20000f48 <Script_Keeper_Update+0x598>
20000f08:	26280040 	addiu	t0,s1,64
	{
		Script_G.Enc_counts[Script_count] = (uint32_t)(((pathDistance) * ENC_PER_GRID) + 0.5);
20000f0c:	00084080 	sll	t0,t0,0x2
20000f10:	01164021 	addu	t0,t0,s6
20000f14:	0c00123d 	jal	200048f4 <__floatsidf>
20000f18:	afa80048 	sw	t0,72(sp)
20000f1c:	8fa60010 	lw	a2,16(sp)
20000f20:	8fa70014 	lw	a3,20(sp)
20000f24:	00402021 	move	a0,v0
20000f28:	0c001139 	jal	200044e4 <__adddf3>
20000f2c:	00602821 	move	a1,v1
20000f30:	00402021 	move	a0,v0
20000f34:	0c000fc7 	jal	20003f1c <__fixunsdfsi>
20000f38:	00602821 	move	a1,v1
20000f3c:	8fa80048 	lw	t0,72(sp)
20000f40:	080003d5 	j	20000f54 <Script_Keeper_Update+0x5a4>
20000f44:	ad020000 	sw	v0,0(t0)
	}
	else
	{
		Script_G.Enc_counts[Script_count] = 0;
20000f48:	00084080 	sll	t0,t0,0x2
20000f4c:	01164021 	addu	t0,t0,s6
20000f50:	ad000000 	sw	zero,0(t0)
	}
	Script_count++;
20000f54:	080003e9 	j	20000fa4 <Script_Keeper_Update+0x5f4>
20000f58:	26310001 	addiu	s1,s1,1
 * @param path_pointer The Path pointer
 */
void ahead(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Fd;
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000f5c:	26280040 	addiu	t0,s1,64
 * Insert the Forward command for a set distance.
 * @param path_pointer The Path pointer
 */
void ahead(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Fd;
20000f60:	02021021 	addu	v0,s0,v0
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000f64:	00084080 	sll	t0,t0,0x2
20000f68:	02084021 	addu	t0,s0,t0
 * Insert the Forward command for a set distance.
 * @param path_pointer The Path pointer
 */
void ahead(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Fd;
20000f6c:	ac530000 	sw	s3,0(v0)
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000f70:	0c00123d 	jal	200048f4 <__floatsidf>
20000f74:	afa80048 	sw	t0,72(sp)
20000f78:	00402021 	move	a0,v0
20000f7c:	00602821 	move	a1,v1
20000f80:	03c03021 	move	a2,s8
20000f84:	0c001139 	jal	200044e4 <__adddf3>
20000f88:	02e03821 	move	a3,s7
20000f8c:	00402021 	move	a0,v0
20000f90:	0c000fc7 	jal	20003f1c <__fixunsdfsi>
20000f94:	00602821 	move	a1,v1
20000f98:	8fa80048 	lw	t0,72(sp)
	Script_count++;
20000f9c:	26310001 	addiu	s1,s1,1
 * @param path_pointer The Path pointer
 */
void ahead(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Fd;
	Script_G.Enc_counts[Script_count] = (uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20000fa0:	ad020000 	sw	v0,0(t0)
	Script_count++;
20000fa4:	08000400 	j	20001000 <Script_Keeper_Update+0x650>
20000fa8:	a39100fd 	sb	s1,253(gp)
					{
						ahead(i);
					}
					break;
				case East:
					aboutTurn(i);
20000fac:	0c0001c7 	jal	2000071c <aboutTurn>
20000fb0:	02402021 	move	a0,s2
					break;
20000fb4:	08000401 	j	20001004 <Script_Keeper_Update+0x654>
20000fb8:	24020004 	li	v0,4
				case South:
					rightTurn(i);
20000fbc:	0c000236 	jal	200008d8 <rightTurn>
20000fc0:	02402021 	move	a0,s2
					break;
20000fc4:	08000401 	j	20001004 <Script_Keeper_Update+0x654>
20000fc8:	24020004 	li	v0,4
				case North:
					leftTurn(i);
20000fcc:	0c000200 	jal	20000800 <leftTurn>
20000fd0:	02402021 	move	a0,s2
					break;
20000fd4:	08000401 	j	20001004 <Script_Keeper_Update+0x654>
20000fd8:	24020004 	li	v0,4
/**
 * Insert the Stop command into the Script.
 */
void stopScript(void)
{
	Script_G.Movement[Script_count] = Stp;
20000fdc:	938200fd 	lbu	v0,253(gp)
20000fe0:	00000000 	nop
	Script_G.Enc_counts[Script_count] = 0;
20000fe4:	24430040 	addiu	v1,v0,64
20000fe8:	00031880 	sll	v1,v1,0x2
/**
 * Insert the Stop command into the Script.
 */
void stopScript(void)
{
	Script_G.Movement[Script_count] = Stp;
20000fec:	00021080 	sll	v0,v0,0x2
20000ff0:	00501021 	addu	v0,v0,s0
	Script_G.Enc_counts[Script_count] = 0;
20000ff4:	00701821 	addu	v1,v1,s0
/**
 * Insert the Stop command into the Script.
 */
void stopScript(void)
{
	Script_G.Movement[Script_count] = Stp;
20000ff8:	ac400000 	sw	zero,0(v0)
	Script_G.Enc_counts[Script_count] = 0;
20000ffc:	ac600000 	sw	zero,0(v1)
				case X:
				default:
					stopScript();
					break;
				}
				Orientation_G = West;
20001000:	24020004 	li	v0,4
				break;
20001004:	0800042f 	j	200010bc <Script_Keeper_Update+0x70c>
20001008:	af820050 	sw	v0,80(gp)
	Script_count++;
}

void bottleBash(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Press;
2000100c:	938200fd 	lbu	v0,253(gp)
	Script_G.Enc_counts[Script_count] = Path_G.Distance[path_pointer];//(uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20001010:	8ea50000 	lw	a1,0(s5)
20001014:	24440040 	addiu	a0,v0,64
20001018:	00042080 	sll	a0,a0,0x2
	Script_count++;
}

void bottleBash(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Press;
2000101c:	00021880 	sll	v1,v0,0x2
	Script_G.Enc_counts[Script_count] = Path_G.Distance[path_pointer];//(uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
20001020:	00902021 	addu	a0,a0,s0
20001024:	ac850000 	sw	a1,0(a0)
	Script_count++;
}

void bottleBash(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Press;
20001028:	00701821 	addu	v1,v1,s0
	Script_G.Enc_counts[Script_count] = Path_G.Distance[path_pointer];//(uint32_t)((Path_G.Distance[path_pointer] * ENC_PER_GRID) + 0.5);
	Script_count++;
2000102c:	24420001 	addiu	v0,v0,1
	Script_count++;
}

void bottleBash(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = Press;
20001030:	08000423 	j	2000108c <Script_Keeper_Update+0x6dc>
20001034:	24040007 	li	a0,7
	Script_count++;
}

void deployRight(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = DeployRt;
20001038:	938200fd 	lbu	v0,253(gp)
	Script_G.Enc_counts[Script_count] = Path_G.Distance[path_pointer];
2000103c:	8ea50000 	lw	a1,0(s5)
20001040:	24440040 	addiu	a0,v0,64
20001044:	00042080 	sll	a0,a0,0x2
	Script_count++;
}

void deployRight(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = DeployRt;
20001048:	00021880 	sll	v1,v0,0x2
	Script_G.Enc_counts[Script_count] = Path_G.Distance[path_pointer];
2000104c:	00902021 	addu	a0,a0,s0
20001050:	ac850000 	sw	a1,0(a0)
	Script_count++;
}

void deployRight(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = DeployRt;
20001054:	00701821 	addu	v1,v1,s0
	Script_G.Enc_counts[Script_count] = Path_G.Distance[path_pointer];
	Script_count++;
20001058:	24420001 	addiu	v0,v0,1
	Script_count++;
}

void deployRight(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = DeployRt;
2000105c:	08000423 	j	2000108c <Script_Keeper_Update+0x6dc>
20001060:	24040006 	li	a0,6
	Script_count++;
}

void deployLeft(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = DeployLf;
20001064:	938200fd 	lbu	v0,253(gp)
	Script_G.Enc_counts[Script_count] = Path_G.Distance[path_pointer];
20001068:	8ea50000 	lw	a1,0(s5)
2000106c:	24440040 	addiu	a0,v0,64
20001070:	00042080 	sll	a0,a0,0x2
	Script_count++;
}

void deployLeft(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = DeployLf;
20001074:	00021880 	sll	v1,v0,0x2
	Script_G.Enc_counts[Script_count] = Path_G.Distance[path_pointer];
20001078:	00902021 	addu	a0,a0,s0
2000107c:	ac850000 	sw	a1,0(a0)
	Script_count++;
}

void deployLeft(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = DeployLf;
20001080:	00701821 	addu	v1,v1,s0
	Script_G.Enc_counts[Script_count] = Path_G.Distance[path_pointer];
	Script_count++;
20001084:	24420001 	addiu	v0,v0,1
	Script_count++;
}

void deployLeft(uint32_t path_pointer)
{
	Script_G.Movement[Script_count] = DeployLf;
20001088:	24040005 	li	a0,5
2000108c:	ac640000 	sw	a0,0(v1)
	Script_G.Enc_counts[Script_count] = Path_G.Distance[path_pointer];
	Script_count++;
20001090:	0800042f 	j	200010bc <Script_Keeper_Update+0x70c>
20001094:	a38200fd 	sb	v0,253(gp)
/**
 * Insert the Stop command into the Script.
 */
void stopScript(void)
{
	Script_G.Movement[Script_count] = Stp;
20001098:	938200fd 	lbu	v0,253(gp)
2000109c:	00000000 	nop
	Script_G.Enc_counts[Script_count] = 0;
200010a0:	24430040 	addiu	v1,v0,64
200010a4:	00031880 	sll	v1,v1,0x2
/**
 * Insert the Stop command into the Script.
 */
void stopScript(void)
{
	Script_G.Movement[Script_count] = Stp;
200010a8:	00021080 	sll	v0,v0,0x2
200010ac:	00501021 	addu	v0,v0,s0
	Script_G.Enc_counts[Script_count] = 0;
200010b0:	00701821 	addu	v1,v1,s0
/**
 * Insert the Stop command into the Script.
 */
void stopScript(void)
{
	Script_G.Movement[Script_count] = Stp;
200010b4:	ac400000 	sw	zero,0(v0)
	Script_G.Enc_counts[Script_count] = 0;
200010b8:	ac600000 	sw	zero,0(v1)
200010bc:	26520001 	addiu	s2,s2,1
{
	/* Check an update is required*/
	if(Script_update == True)
	{
		/* Analyse the Path_G to generate the Script */
		for(uint8_t i = 0; i < PATH_MAX; i++)
200010c0:	24020010 	li	v0,16
200010c4:	1642fe60 	bne	s2,v0,20000a48 <Script_Keeper_Update+0x98>
200010c8:	26b50004 	addiu	s5,s5,4
				Script_G.Enc_counts[i] = 0;
			}*/
		}
		else
		{
			Script_update = False;
200010cc:	0800045a 	j	20001168 <Script_Keeper_Update+0x7b8>
200010d0:	af8000dc 	sw	zero,220(gp)
	else
	{
		/* Check that both motor tasks have stopped their motors */
		if(
				End_Of_MoveLf == True
				&& End_Of_MoveRt == True
200010d4:	8f820068 	lw	v0,104(gp)
200010d8:	00000000 	nop
	}
	/* Monitor the script stage */
	else
	{
		/* Check that both motor tasks have stopped their motors */
		if(
200010dc:	1443000a 	bne	v0,v1,20001108 <Script_Keeper_Update+0x758>
200010e0:	00000000 	nop
200010e4:	8f8300e4 	lw	v1,228(gp)
200010e8:	00000000 	nop
200010ec:	1462001d 	bne	v1,v0,20001164 <Script_Keeper_Update+0x7b4>
200010f0:	00000000 	nop
				End_Of_MoveLf == True
				&& End_Of_MoveRt == True
			)
		{
			Script_no_G++;
200010f4:	938200e0 	lbu	v0,224(gp)
200010f8:	00000000 	nop
200010fc:	24420001 	addiu	v0,v0,1
	}
	/* Monitor the script stage */
	else
	{
		/* Check that both motor tasks have stopped their motors */
		if(
20001100:	0800045a 	j	20001168 <Script_Keeper_Update+0x7b8>
20001104:	a38200e0 	sb	v0,224(gp)
			)
		{
			Script_no_G++;
		}
		/* Check that both motor tasks have stopped their motors and the Script command is to Stop */
		else if(
20001108:	14400016 	bnez	v0,20001164 <Script_Keeper_Update+0x7b4>
2000110c:	00000000 	nop
20001110:	978200b0 	lhu	v0,176(gp)
20001114:	00000000 	nop
20001118:	14400012 	bnez	v0,20001164 <Script_Keeper_Update+0x7b4>
2000111c:	00000000 	nop
20001120:	8f8200e4 	lw	v0,228(gp)
20001124:	00000000 	nop
20001128:	1440000e 	bnez	v0,20001164 <Script_Keeper_Update+0x7b4>
2000112c:	00000000 	nop
20001130:	978200b2 	lhu	v0,178(gp)
20001134:	00000000 	nop
20001138:	1440000a 	bnez	v0,20001164 <Script_Keeper_Update+0x7b4>
2000113c:	3c024000 	lui	v0,0x4000
				End_Of_MoveLf == False
				&& Left_motor_speed_G == 0
				&& End_Of_MoveRt == False
				&& Right_motor_speed_G == 0
				&& Script_G.Movement[Script_no_G] == Stp
20001140:	938300e0 	lbu	v1,224(gp)
20001144:	00000000 	nop
20001148:	00031880 	sll	v1,v1,0x2
2000114c:	2442066c 	addiu	v0,v0,1644
20001150:	00621021 	addu	v0,v1,v0
20001154:	8c420000 	lw	v0,0(v0)
20001158:	00000000 	nop
2000115c:	10400002 	beqz	v0,20001168 <Script_Keeper_Update+0x7b8>
20001160:	00000000 	nop
				Script_G.Enc_counts[i] = 0;
			}*/
		}
		else
		{
			Script_update = False;
20001164:	af8000dc 	sw	zero,220(gp)
		}
	}
}
20001168:	8fbf0074 	lw	ra,116(sp)
2000116c:	8fbe0070 	lw	s8,112(sp)
20001170:	8fb7006c 	lw	s7,108(sp)
20001174:	8fb60068 	lw	s6,104(sp)
20001178:	8fb50064 	lw	s5,100(sp)
2000117c:	8fb40060 	lw	s4,96(sp)
20001180:	8fb3005c 	lw	s3,92(sp)
20001184:	8fb20058 	lw	s2,88(sp)
20001188:	8fb10054 	lw	s1,84(sp)
2000118c:	8fb00050 	lw	s0,80(sp)
20001190:	03e00008 	jr	ra
20001194:	27bd0078 	addiu	sp,sp,120

20001198 <Read_Enc_Init>:
 * Initialisation for the Read_Enc package.
 * This will be called from Tasks_Init by default.
 */
void Read_Enc_Init(void)
{
	GPIO_Set_Direction(EncL_CH_A, GPIO_INPUT);
20001198:	3c028000 	lui	v0,0x8000
2000119c:	34420500 	ori	v0,v0,0x500
200011a0:	8c440004 	lw	a0,4(v0)
200011a4:	2403fbff 	li	v1,-1025
200011a8:	00831824 	and	v1,a0,v1
200011ac:	ac430004 	sw	v1,4(v0)
200011b0:	8c430004 	lw	v1,4(v0)
	GPIO_Set_Direction(EncR_CH_B, GPIO_INPUT);

	WheelCounts_Left_G = 0;
	WheelCounts_Right_G = 0;

	EncSignal_A[0] = 0;								/* Signal A from left encoder */
200011b4:	af800108 	sw	zero,264(gp)
 * Initialisation for the Read_Enc package.
 * This will be called from Tasks_Init by default.
 */
void Read_Enc_Init(void)
{
	GPIO_Set_Direction(EncL_CH_A, GPIO_INPUT);
200011b8:	ac430004 	sw	v1,4(v0)
	GPIO_Set_Direction(EncL_CH_B, GPIO_INPUT);
200011bc:	8c440004 	lw	a0,4(v0)
200011c0:	2403f7ff 	li	v1,-2049
200011c4:	00831824 	and	v1,a0,v1
200011c8:	ac430004 	sw	v1,4(v0)
200011cc:	8c430004 	lw	v1,4(v0)

	WheelCounts_Left_G = 0;
	WheelCounts_Right_G = 0;

	EncSignal_A[0] = 0;								/* Signal A from left encoder */
	EncSignal_B[0] = 0;								/* Signal B from left encoder */
200011d0:	af800118 	sw	zero,280(gp)
 * This will be called from Tasks_Init by default.
 */
void Read_Enc_Init(void)
{
	GPIO_Set_Direction(EncL_CH_A, GPIO_INPUT);
	GPIO_Set_Direction(EncL_CH_B, GPIO_INPUT);
200011d4:	ac430004 	sw	v1,4(v0)
	GPIO_Set_Direction(EncR_CH_A, GPIO_INPUT);
200011d8:	8c440004 	lw	a0,4(v0)
200011dc:	3c03fff7 	lui	v1,0xfff7
200011e0:	3463ffff 	ori	v1,v1,0xffff
200011e4:	00831824 	and	v1,a0,v1
200011e8:	ac430004 	sw	v1,4(v0)
200011ec:	8c430004 	lw	v1,4(v0)
	WheelCounts_Right_G = 0;

	EncSignal_A[0] = 0;								/* Signal A from left encoder */
	EncSignal_B[0] = 0;								/* Signal B from left encoder */

	EncSignal_A[1] = 0;								/* Signal A from right encoder */
200011f0:	af80010c 	sw	zero,268(gp)
 */
void Read_Enc_Init(void)
{
	GPIO_Set_Direction(EncL_CH_A, GPIO_INPUT);
	GPIO_Set_Direction(EncL_CH_B, GPIO_INPUT);
	GPIO_Set_Direction(EncR_CH_A, GPIO_INPUT);
200011f4:	ac430004 	sw	v1,4(v0)
	GPIO_Set_Direction(EncR_CH_B, GPIO_INPUT);
200011f8:	8c440004 	lw	a0,4(v0)
200011fc:	3c03fffb 	lui	v1,0xfffb
20001200:	3463ffff 	ori	v1,v1,0xffff
20001204:	00831824 	and	v1,a0,v1

	WheelCounts_Left_G = 0;
20001208:	af800088 	sw	zero,136(gp)
void Read_Enc_Init(void)
{
	GPIO_Set_Direction(EncL_CH_A, GPIO_INPUT);
	GPIO_Set_Direction(EncL_CH_B, GPIO_INPUT);
	GPIO_Set_Direction(EncR_CH_A, GPIO_INPUT);
	GPIO_Set_Direction(EncR_CH_B, GPIO_INPUT);
2000120c:	ac430004 	sw	v1,4(v0)
20001210:	8c430004 	lw	v1,4(v0)

	EncSignal_A[0] = 0;								/* Signal A from left encoder */
	EncSignal_B[0] = 0;								/* Signal B from left encoder */

	EncSignal_A[1] = 0;								/* Signal A from right encoder */
	EncSignal_B[1] = 0;								/* Signal B from right encoder */
20001214:	af80011c 	sw	zero,284(gp)
	GPIO_Set_Direction(EncL_CH_B, GPIO_INPUT);
	GPIO_Set_Direction(EncR_CH_A, GPIO_INPUT);
	GPIO_Set_Direction(EncR_CH_B, GPIO_INPUT);

	WheelCounts_Left_G = 0;
	WheelCounts_Right_G = 0;
20001218:	af8000c8 	sw	zero,200(gp)
void Read_Enc_Init(void)
{
	GPIO_Set_Direction(EncL_CH_A, GPIO_INPUT);
	GPIO_Set_Direction(EncL_CH_B, GPIO_INPUT);
	GPIO_Set_Direction(EncR_CH_A, GPIO_INPUT);
	GPIO_Set_Direction(EncR_CH_B, GPIO_INPUT);
2000121c:	ac430004 	sw	v1,4(v0)

	EncSignal_A[1] = 0;								/* Signal A from right encoder */
	EncSignal_B[1] = 0;								/* Signal B from right encoder */

	/* Left */
	RevCount[0] = 0;
20001220:	af800110 	sw	zero,272(gp)
	EncoderCount[0] = 0;
20001224:	af800120 	sw	zero,288(gp)
	WheelCount[0] = 0;
20001228:	af800100 	sw	zero,256(gp)

	/* Right */
	RevCount[1] = 0;
2000122c:	af800114 	sw	zero,276(gp)
	EncoderCount[1] = 0;
20001230:	af800124 	sw	zero,292(gp)
	WheelCount[1] = 0;
20001234:	af800104 	sw	zero,260(gp)

	bufferTime = 0;
}
20001238:	03e00008 	jr	ra
2000123c:	a3800128 	sb	zero,296(gp)

20001240 <Read_Enc_Update>:
/**
 * Reads the value of the Encoders
 */
void Read_Enc_Update(void)
{
	if(System_Mode_G == Go)
20001240:	8f8300f8 	lw	v1,248(gp)
20001244:	24020002 	li	v0,2
20001248:	1462005d 	bne	v1,v0,200013c0 <Read_Enc_Update+0x180>
2000124c:	3c028000 	lui	v0,0x8000
	{
		/* Read signals from encoders */
		EncSignal_A[0] = GPIO_Get(EncL_CH_A);	/* Left_A;	Signal A from left encoder */
20001250:	34420500 	ori	v0,v0,0x500
20001254:	8c450000 	lw	a1,0(v0)
		EncSignal_B[0] = GPIO_Get(EncL_CH_B);	/* Left_B;	Signal B from left encoder */
20001258:	8c440000 	lw	a0,0(v0)

		EncSignal_A[1] = GPIO_Get(EncR_CH_A);	/* Right_A;	Signal A from right encoder */
2000125c:	8c430000 	lw	v1,0(v0)
		EncSignal_B[1] = GPIO_Get(EncR_CH_B);	/* Right_B;	Signal B from right encoder */
20001260:	8c420000 	lw	v0,0(v0)
void Read_Enc_Update(void)
{
	if(System_Mode_G == Go)
	{
		/* Read signals from encoders */
		EncSignal_A[0] = GPIO_Get(EncL_CH_A);	/* Left_A;	Signal A from left encoder */
20001264:	00052a82 	srl	a1,a1,0xa
		EncSignal_B[0] = GPIO_Get(EncL_CH_B);	/* Left_B;	Signal B from left encoder */
20001268:	000422c2 	srl	a0,a0,0xb

		EncSignal_A[1] = GPIO_Get(EncR_CH_A);	/* Right_A;	Signal A from right encoder */
2000126c:	00031cc2 	srl	v1,v1,0x13
		EncSignal_B[1] = GPIO_Get(EncR_CH_B);	/* Right_B;	Signal B from right encoder */
20001270:	00021482 	srl	v0,v0,0x12
void Read_Enc_Update(void)
{
	if(System_Mode_G == Go)
	{
		/* Read signals from encoders */
		EncSignal_A[0] = GPIO_Get(EncL_CH_A);	/* Left_A;	Signal A from left encoder */
20001274:	30a50001 	andi	a1,a1,0x1
		EncSignal_B[0] = GPIO_Get(EncL_CH_B);	/* Left_B;	Signal B from left encoder */
20001278:	30840001 	andi	a0,a0,0x1

		EncSignal_A[1] = GPIO_Get(EncR_CH_A);	/* Right_A;	Signal A from right encoder */
2000127c:	30630001 	andi	v1,v1,0x1
		EncSignal_B[1] = GPIO_Get(EncR_CH_B);	/* Right_B;	Signal B from right encoder */
20001280:	30420001 	andi	v0,v0,0x1
void Read_Enc_Update(void)
{
	if(System_Mode_G == Go)
	{
		/* Read signals from encoders */
		EncSignal_A[0] = GPIO_Get(EncL_CH_A);	/* Left_A;	Signal A from left encoder */
20001284:	af850108 	sw	a1,264(gp)
		EncSignal_B[0] = GPIO_Get(EncL_CH_B);	/* Left_B;	Signal B from left encoder */
20001288:	af840118 	sw	a0,280(gp)

		EncSignal_A[1] = GPIO_Get(EncR_CH_A);	/* Right_A;	Signal A from right encoder */
2000128c:	af83010c 	sw	v1,268(gp)
		EncSignal_B[1] = GPIO_Get(EncR_CH_B);	/* Right_B;	Signal B from right encoder */
20001290:	af82011c 	sw	v0,284(gp)
20001294:	27840134 	addiu	a0,gp,308
20001298:	27830120 	addiu	v1,gp,288
2000129c:	2786012c 	addiu	a2,gp,300
200012a0:	27890108 	addiu	t1,gp,264
200012a4:	27880118 	addiu	t0,gp,280
200012a8:	00002821 	move	a1,zero

		/* Loop through both sides */
		for(uint8_t i = 0; i <= 1; i ++)
		{
			if(Pulse_Flag[i] == High)
200012ac:	24020001 	li	v0,1
				}

				/* Full cycle detection when both signals dropped off */
				else if((EncSignal_A[i] == Low) && (EncSignal_B[i] == Low))
				{
					switch(WheelDirection[i])
200012b0:	240a0002 	li	t2,2
				WheelDirection[i] = WheelDirection[i];
				Pulse_Flag[i] = Pulse_Flag[i];
			}

			/* Calculate total counts for wheel */
			WheelCount[i] = ((RevCount[i] * ROBOT_ENC_COUNTS_PER_REV) + EncoderCount[i]);
200012b4:	278e0100 	addiu	t6,gp,256
200012b8:	278d0110 	addiu	t5,gp,272

		EncSignal_A[1] = GPIO_Get(EncR_CH_A);	/* Right_A;	Signal A from right encoder */
		EncSignal_B[1] = GPIO_Get(EncR_CH_B);	/* Right_B;	Signal B from right encoder */

		/* Loop through both sides */
		for(uint8_t i = 0; i <= 1; i ++)
200012bc:	240c0008 	li	t4,8
		{
			if(Pulse_Flag[i] == High)
200012c0:	8c8b0000 	lw	t3,0(a0)
200012c4:	8d270000 	lw	a3,0(t1)
200012c8:	15620020 	bne	t3,v0,2000134c <Read_Enc_Update+0x10c>
200012cc:	00000000 	nop
			{
				/* Direction detection on single signal drop-off */
				if(EncSignal_A[i] != EncSignal_B[i])
200012d0:	8d0b0000 	lw	t3,0(t0)
200012d4:	00000000 	nop
200012d8:	10eb0009 	beq	a3,t3,20001300 <Read_Enc_Update+0xc0>
200012dc:	00000000 	nop
				{
					switch(EncSignal_A[i])
200012e0:	10e00005 	beqz	a3,200012f8 <Read_Enc_Update+0xb8>
200012e4:	00000000 	nop
200012e8:	14e20022 	bne	a3,v0,20001374 <Read_Enc_Update+0x134>
200012ec:	00ad3821 	addu	a3,a1,t5
					{
						case High:
							WheelDirection[i] = Reverse;
							break;
200012f0:	080004dd 	j	20001374 <Read_Enc_Update+0x134>
200012f4:	acca0000 	sw	t2,0(a2)
						case Low:
							WheelDirection[i] = Forwards;
200012f8:	080004dc 	j	20001370 <Read_Enc_Update+0x130>
200012fc:	acc20000 	sw	v0,0(a2)
							break;
					}
				}

				/* Full cycle detection when both signals dropped off */
				else if((EncSignal_A[i] == Low) && (EncSignal_B[i] == Low))
20001300:	14e0001c 	bnez	a3,20001374 <Read_Enc_Update+0x134>
20001304:	00ad3821 	addu	a3,a1,t5
				{
					switch(WheelDirection[i])
20001308:	8cc70000 	lw	a3,0(a2)
2000130c:	00000000 	nop
20001310:	10e20005 	beq	a3,v0,20001328 <Read_Enc_Update+0xe8>
20001314:	00000000 	nop
20001318:	14ea000a 	bne	a3,t2,20001344 <Read_Enc_Update+0x104>
2000131c:	00000000 	nop
20001320:	080004cd 	j	20001334 <Read_Enc_Update+0xf4>
20001324:	00000000 	nop
					{
						case Forwards:
							EncoderCount[i] ++;
20001328:	8c670000 	lw	a3,0(v1)
2000132c:	080004d0 	j	20001340 <Read_Enc_Update+0x100>
20001330:	24e70001 	addiu	a3,a3,1
							break;
						case Reverse:
							EncoderCount[i] --;
20001334:	8c670000 	lw	a3,0(v1)
20001338:	00000000 	nop
2000133c:	24e7ffff 	addiu	a3,a3,-1
20001340:	ac670000 	sw	a3,0(v1)
						case Off:
							break;
						default:
							break;
					}
					Pulse_Flag[i] = Low;
20001344:	080004dc 	j	20001370 <Read_Enc_Update+0x130>
20001348:	ac800000 	sw	zero,0(a0)
				}
			}
			/* Wait for both A and B to be high to raise Pulse_Flag */
			else if((EncSignal_A[i] == High) && (EncSignal_B[i] == High))
2000134c:	14e20007 	bne	a3,v0,2000136c <Read_Enc_Update+0x12c>
20001350:	00000000 	nop
20001354:	8d070000 	lw	a3,0(t0)
20001358:	00000000 	nop
2000135c:	14e20003 	bne	a3,v0,2000136c <Read_Enc_Update+0x12c>
20001360:	00000000 	nop
20001364:	080004dc 	j	20001370 <Read_Enc_Update+0x130>
20001368:	ac820000 	sw	v0,0(a0)
			/* ET Padding to reduce jitter */
			else
			{
				EncoderCount[i] = EncoderCount[i];
				WheelDirection[i] = WheelDirection[i];
				Pulse_Flag[i] = Pulse_Flag[i];
2000136c:	ac8b0000 	sw	t3,0(a0)
			}

			/* Calculate total counts for wheel */
			WheelCount[i] = ((RevCount[i] * ROBOT_ENC_COUNTS_PER_REV) + EncoderCount[i]);
20001370:	00ad3821 	addu	a3,a1,t5
20001374:	8ceb0000 	lw	t3,0(a3)
20001378:	8c670000 	lw	a3,0(v1)
2000137c:	000b59c0 	sll	t3,t3,0x7
20001380:	01675821 	addu	t3,t3,a3
20001384:	00ae3821 	addu	a3,a1,t6
20001388:	24a50004 	addiu	a1,a1,4
2000138c:	aceb0000 	sw	t3,0(a3)
20001390:	24840004 	addiu	a0,a0,4
20001394:	24630004 	addiu	v1,v1,4
20001398:	24c60004 	addiu	a2,a2,4
2000139c:	25290004 	addiu	t1,t1,4

		EncSignal_A[1] = GPIO_Get(EncR_CH_A);	/* Right_A;	Signal A from right encoder */
		EncSignal_B[1] = GPIO_Get(EncR_CH_B);	/* Right_B;	Signal B from right encoder */

		/* Loop through both sides */
		for(uint8_t i = 0; i <= 1; i ++)
200013a0:	14acffc7 	bne	a1,t4,200012c0 <Read_Enc_Update+0x80>
200013a4:	25080004 	addiu	t0,t0,4
			/* Calculate total counts for wheel */
			WheelCount[i] = ((RevCount[i] * ROBOT_ENC_COUNTS_PER_REV) + EncoderCount[i]);
		}

		/* Output distance wheels have travelled to global variable */
		WheelCounts_Left_G = WheelCount[0];
200013a8:	8f820100 	lw	v0,256(gp)
200013ac:	00000000 	nop
200013b0:	af820088 	sw	v0,136(gp)
		WheelCounts_Right_G = WheelCount[1];
200013b4:	8f820104 	lw	v0,260(gp)
200013b8:	03e00008 	jr	ra
200013bc:	af8200c8 	sw	v0,200(gp)
	}
	else
	{
		WheelCount[0] = 0;
200013c0:	af800100 	sw	zero,256(gp)
		WheelCount[1] = 0;
200013c4:	03e00008 	jr	ra
200013c8:	af800104 	sw	zero,260(gp)

200013cc <PathFinder_Init>:


void PathFinder_Init(void)
{
	/* Default Strategy */
	Strategy_G = Defensive;
200013cc:	3c024000 	lui	v0,0x4000
		{West, South, East, East, South, South, West, North, Bottle, X},
		{ 395,   475,  320, -330,   760,  -256,  950,    -1,   1200, 0}
};


void PathFinder_Init(void)
200013d0:	3c034000 	lui	v1,0x4000
{
	/* Default Strategy */
	Strategy_G = Defensive;
200013d4:	af8000d0 	sw	zero,208(gp)
200013d8:	244205c0 	addiu	v0,v0,1472
		{West, South, East, East, South, South, West, North, Bottle, X},
		{ 395,   475,  320, -330,   760,  -256,  950,    -1,   1200, 0}
};


void PathFinder_Init(void)
200013dc:	24630600 	addiu	v1,v1,1536
	Strategy_G = Defensive;

	/* Clear Path */
	for(uint8_t i = 0; i < PATH_MAX; i++)
	{
		Path_G.Heading[i] = X;
200013e0:	ac400000 	sw	zero,0(v0)
		Path_G.Distance[i] = 0;
200013e4:	ac400040 	sw	zero,64(v0)
200013e8:	24420004 	addiu	v0,v0,4
{
	/* Default Strategy */
	Strategy_G = Defensive;

	/* Clear Path */
	for(uint8_t i = 0; i < PATH_MAX; i++)
200013ec:	1443fffc 	bne	v0,v1,200013e0 <PathFinder_Init+0x14>
200013f0:	00000000 	nop
		Path_G.Heading[i] = X;
		Path_G.Distance[i] = 0;
	}

	/* Initialise Switch IOs */
	GPIO_Set_Direction(Strategy0, GPIO_INPUT);
200013f4:	3c028000 	lui	v0,0x8000
200013f8:	34430300 	ori	v1,v0,0x300
200013fc:	8c650004 	lw	a1,4(v1)
20001400:	2404fffe 	li	a0,-2
20001404:	00a42024 	and	a0,a1,a0
20001408:	ac640004 	sw	a0,4(v1)
2000140c:	8c640004 	lw	a0,4(v1)
	GPIO_Set_Direction(Strategy1, GPIO_INPUT);
	GPIO_Set_Direction(Strategy2, GPIO_INPUT);

	GPIO_Set_Direction(LED_Pin_SC, GPIO_OUTPUT);
20001410:	34420200 	ori	v0,v0,0x200
		Path_G.Heading[i] = X;
		Path_G.Distance[i] = 0;
	}

	/* Initialise Switch IOs */
	GPIO_Set_Direction(Strategy0, GPIO_INPUT);
20001414:	ac640004 	sw	a0,4(v1)
	GPIO_Set_Direction(Strategy1, GPIO_INPUT);
20001418:	8c650004 	lw	a1,4(v1)
2000141c:	2404fffd 	li	a0,-3
20001420:	00a42024 	and	a0,a1,a0
20001424:	ac640004 	sw	a0,4(v1)
20001428:	8c640004 	lw	a0,4(v1)
	GPIO_Set_Direction(Strategy2, GPIO_INPUT);
2000142c:	2405fffb 	li	a1,-5
		Path_G.Distance[i] = 0;
	}

	/* Initialise Switch IOs */
	GPIO_Set_Direction(Strategy0, GPIO_INPUT);
	GPIO_Set_Direction(Strategy1, GPIO_INPUT);
20001430:	ac640004 	sw	a0,4(v1)
	GPIO_Set_Direction(Strategy2, GPIO_INPUT);
20001434:	8c660004 	lw	a2,4(v1)

	GPIO_Set_Direction(LED_Pin_SC, GPIO_OUTPUT);
20001438:	2404ffdf 	li	a0,-33
	}

	/* Initialise Switch IOs */
	GPIO_Set_Direction(Strategy0, GPIO_INPUT);
	GPIO_Set_Direction(Strategy1, GPIO_INPUT);
	GPIO_Set_Direction(Strategy2, GPIO_INPUT);
2000143c:	00c52824 	and	a1,a2,a1
20001440:	ac650004 	sw	a1,4(v1)
20001444:	8c650004 	lw	a1,4(v1)
20001448:	00000000 	nop
2000144c:	ac650004 	sw	a1,4(v1)

	GPIO_Set_Direction(LED_Pin_SC, GPIO_OUTPUT);
20001450:	8c430004 	lw	v1,4(v0)
20001454:	00000000 	nop
20001458:	00641824 	and	v1,v1,a0
2000145c:	ac430004 	sw	v1,4(v0)
20001460:	8c430004 	lw	v1,4(v0)
20001464:	00000000 	nop
20001468:	34630020 	ori	v1,v1,0x20
2000146c:	ac430004 	sw	v1,4(v0)
	GPIO_Write(LED_Pin_SC, GPIO_LOW);
20001470:	8c430000 	lw	v1,0(v0)
20001474:	00000000 	nop
20001478:	00641824 	and	v1,v1,a0
2000147c:	ac430000 	sw	v1,0(v0)
20001480:	8c430000 	lw	v1,0(v0)
20001484:	00000000 	nop
20001488:	ac430000 	sw	v1,0(v0)
	GPIO_Set_Direction(LED_Pin_Opponent, GPIO_OUTPUT);
2000148c:	8c450004 	lw	a1,4(v0)
20001490:	2403ffef 	li	v1,-17
20001494:	00a31824 	and	v1,a1,v1
20001498:	ac430004 	sw	v1,4(v0)
2000149c:	8c430004 	lw	v1,4(v0)
200014a0:	00000000 	nop
200014a4:	34630010 	ori	v1,v1,0x10
200014a8:	ac430004 	sw	v1,4(v0)
	GPIO_Write(LED_Pin_SC, GPIO_LOW);
200014ac:	8c430000 	lw	v1,0(v0)
200014b0:	00000000 	nop
200014b4:	00642024 	and	a0,v1,a0
200014b8:	ac440000 	sw	a0,0(v0)
200014bc:	8c430000 	lw	v1,0(v0)
200014c0:	00000000 	nop
200014c4:	ac430000 	sw	v1,0(v0)
}
200014c8:	03e00008 	jr	ra
200014cc:	00000000 	nop

200014d0 <PathFinder_Update>:

void PathFinder_Update(void)
{
	if(System_Mode_G == Ready)
200014d0:	8f8200f8 	lw	v0,248(gp)
	GPIO_Set_Direction(LED_Pin_Opponent, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_SC, GPIO_LOW);
}

void PathFinder_Update(void)
{
200014d4:	27bdffe8 	addiu	sp,sp,-24
200014d8:	afbf0014 	sw	ra,20(sp)
	if(System_Mode_G == Ready)
200014dc:	14400016 	bnez	v0,20001538 <PathFinder_Update+0x68>
200014e0:	afb00010 	sw	s0,16(sp)
	{
		if(GPIO_Get(Strategy0) == GPIO_HIGH)
200014e4:	3c028000 	lui	v0,0x8000
200014e8:	34420300 	ori	v0,v0,0x300
200014ec:	8c430000 	lw	v1,0(v0)
200014f0:	00000000 	nop
200014f4:	30630001 	andi	v1,v1,0x1
200014f8:	1460000e 	bnez	v1,20001534 <PathFinder_Update+0x64>
200014fc:	00000000 	nop
		{
			Strategy_G = Defensive;
		}
		else if(GPIO_Get(Strategy1) == GPIO_HIGH)
20001500:	8c430000 	lw	v1,0(v0)
20001504:	00000000 	nop
20001508:	30630002 	andi	v1,v1,0x2
2000150c:	10600004 	beqz	v1,20001520 <PathFinder_Update+0x50>
20001510:	00000000 	nop
		{
			Strategy_G = Agressive;
20001514:	24020001 	li	v0,1
20001518:	0800054e 	j	20001538 <PathFinder_Update+0x68>
2000151c:	af8200d0 	sw	v0,208(gp)
		}
		else if(GPIO_Get(Strategy2) == GPIO_HIGH)
20001520:	8c420000 	lw	v0,0(v0)
20001524:	00000000 	nop
20001528:	30420004 	andi	v0,v0,0x4
2000152c:	10400002 	beqz	v0,20001538 <PathFinder_Update+0x68>
20001530:	00000000 	nop
		{
			Strategy_G = Defensive;
20001534:	af8000d0 	sw	zero,208(gp)
		}
	}

	if(Opponent_detected == True)
20001538:	8f900040 	lw	s0,64(gp)
2000153c:	24020001 	li	v0,1
20001540:	16020008 	bne	s0,v0,20001564 <PathFinder_Update+0x94>
20001544:	3c028000 	lui	v0,0x8000
	{
		GPIO_Write(LED_Pin_Opponent, GPIO_HIGH);
20001548:	34420200 	ori	v0,v0,0x200
2000154c:	8c430000 	lw	v1,0(v0)
20001550:	00000000 	nop
20001554:	ac430000 	sw	v1,0(v0)
20001558:	8c430000 	lw	v1,0(v0)
2000155c:	08000560 	j	20001580 <PathFinder_Update+0xb0>
20001560:	34630010 	ori	v1,v1,0x10
	}
	else
	{
		GPIO_Write(LED_Pin_Opponent, GPIO_LOW);
20001564:	34420200 	ori	v0,v0,0x200
20001568:	8c440000 	lw	a0,0(v0)
2000156c:	2403ffef 	li	v1,-17
20001570:	00831824 	and	v1,a0,v1
20001574:	ac430000 	sw	v1,0(v0)
20001578:	8c430000 	lw	v1,0(v0)
2000157c:	00000000 	nop
20001580:	ac430000 	sw	v1,0(v0)
	}

	switch(Strategy_G)
20001584:	8f8200d0 	lw	v0,208(gp)
20001588:	24030001 	li	v1,1
2000158c:	14430018 	bne	v0,v1,200015f0 <PathFinder_Update+0x120>
20001590:	00000000 	nop
	{
	case Agressive:
		if((Opponent_detected == True && Script_no_G == 0))
20001594:	1602001a 	bne	s0,v0,20001600 <PathFinder_Update+0x130>
20001598:	3c044000 	lui	a0,0x4000
2000159c:	938200e0 	lbu	v0,224(gp)
200015a0:	00000000 	nop
200015a4:	14400017 	bnez	v0,20001604 <PathFinder_Update+0x134>
200015a8:	3c054000 	lui	a1,0x4000
		{
			Strategy_G = Defensive;
			Path_G = BlueBottle;
200015ac:	3c044000 	lui	a0,0x4000
200015b0:	248405c0 	addiu	a0,a0,1472
200015b4:	24a50278 	addiu	a1,a1,632
200015b8:	24060080 	li	a2,128
200015bc:	0c000fbb 	jal	20003eec <memcpy>
200015c0:	af8000d0 	sw	zero,208(gp)
			Script_update = True;
			GPIO_Write(LED_Pin_SC, GPIO_HIGH);
200015c4:	3c028000 	lui	v0,0x8000
200015c8:	34420200 	ori	v0,v0,0x200
200015cc:	8c430000 	lw	v1,0(v0)
	case Agressive:
		if((Opponent_detected == True && Script_no_G == 0))
		{
			Strategy_G = Defensive;
			Path_G = BlueBottle;
			Script_update = True;
200015d0:	af9000dc 	sw	s0,220(gp)
			GPIO_Write(LED_Pin_SC, GPIO_HIGH);
200015d4:	ac430000 	sw	v1,0(v0)
200015d8:	8c430000 	lw	v1,0(v0)
200015dc:	00000000 	nop
200015e0:	34630020 	ori	v1,v1,0x20
200015e4:	ac430000 	sw	v1,0(v0)
	}

	switch(Strategy_G)
	{
	case Agressive:
		if((Opponent_detected == True && Script_no_G == 0))
200015e8:	0800058a 	j	20001628 <PathFinder_Update+0x158>
200015ec:	00000000 	nop
			Path_G = BlueBottle;
		}
		break;
	case Defensive:
	default:
		if(Team_Colour == Blue)
200015f0:	8f8200c0 	lw	v0,192(gp)
200015f4:	00000000 	nop
200015f8:	14430005 	bne	v0,v1,20001610 <PathFinder_Update+0x140>
200015fc:	3c044000 	lui	a0,0x4000
		{
			Path_G = BlueBottle;
20001600:	3c054000 	lui	a1,0x4000
20001604:	248405c0 	addiu	a0,a0,1472
20001608:	08000588 	j	20001620 <PathFinder_Update+0x150>
2000160c:	24a50278 	addiu	a1,a1,632
		}
		if(Team_Colour == Red)
20001610:	14400005 	bnez	v0,20001628 <PathFinder_Update+0x158>
20001614:	3c054000 	lui	a1,0x4000
		{
			Path_G = RedBottle;
20001618:	248405c0 	addiu	a0,a0,1472
2000161c:	24a502f8 	addiu	a1,a1,760
20001620:	0c000fbb 	jal	20003eec <memcpy>
20001624:	24060080 	li	a2,128
		}
		break;
	}
}
20001628:	8fbf0014 	lw	ra,20(sp)
2000162c:	8fb00010 	lw	s0,16(sp)
20001630:	03e00008 	jr	ra
20001634:	27bd0018 	addiu	sp,sp,24

20001638 <Opponent_Tracker_Init>:
 * Initialisation for the Opponent_Tracker package.
 * This will be called from Tasks_Init by default.
 */
void Opponent_Tracker_Init(void)
{
	Opponent_detected = False;
20001638:	af800040 	sw	zero,64(gp)
	sensorDebounce = 0;
}
2000163c:	03e00008 	jr	ra
20001640:	a3800144 	sb	zero,324(gp)

20001644 <Opponent_Tracker_Update>:
	uint32_t reversible;

	/* Check to see messages received from forward Proximity sensor */
	if(
			(
					(sensorReadings.USFwd < US_THRESHOLD)
20001644:	3c044000 	lui	a0,0x4000

/**
 * Analyse the Sensor Readings to determine if an opponent is present
 */
void Opponent_Tracker_Update(void)
{
20001648:	27bdffe8 	addiu	sp,sp,-24
	uint32_t reversible;

	/* Check to see messages received from forward Proximity sensor */
	if(
			(
					(sensorReadings.USFwd < US_THRESHOLD)
2000164c:	24820660 	addiu	v0,a0,1632

/**
 * Analyse the Sensor Readings to determine if an opponent is present
 */
void Opponent_Tracker_Update(void)
{
20001650:	afb00010 	sw	s0,16(sp)
	uint32_t reversible;

	/* Check to see messages received from forward Proximity sensor */
	if(
			(
					(sensorReadings.USFwd < US_THRESHOLD)
20001654:	8c500008 	lw	s0,8(v0)
20001658:	00000000 	nop
2000165c:	2603ffff 	addiu	v1,s0,-1
void Opponent_Tracker_Update(void)
{
	uint32_t reversible;

	/* Check to see messages received from forward Proximity sensor */
	if(
20001660:	2c65000f 	sltiu	a1,v1,15
20001664:	14a0000b 	bnez	a1,20001694 <Opponent_Tracker_Update+0x50>
20001668:	afbf0014 	sw	ra,20(sp)
2000166c:	8c840660 	lw	a0,1632(a0)
20001670:	00000000 	nop
20001674:	2c840091 	sltiu	a0,a0,145
20001678:	10800006 	beqz	a0,20001694 <Opponent_Tracker_Update+0x50>
2000167c:	00000000 	nop
20001680:	8c420004 	lw	v0,4(v0)
20001684:	00000000 	nop
20001688:	2c420091 	sltiu	v0,v0,145
2000168c:	1440002e 	bnez	v0,20001748 <Opponent_Tracker_Update+0x104>
20001690:	00000000 	nop
			(sensorReadings.IRLeft > IR_THRESHOLD)
			||
			(sensorReadings.IRRight > IR_THRESHOLD)
		)
	{
		switch(Script_G.Movement[Script_no_G])
20001694:	938400e0 	lbu	a0,224(gp)
20001698:	3c024000 	lui	v0,0x4000
2000169c:	00042080 	sll	a0,a0,0x2
200016a0:	2442066c 	addiu	v0,v0,1644
200016a4:	00821021 	addu	v0,a0,v0
200016a8:	8c420000 	lw	v0,0(v0)
200016ac:	24040002 	li	a0,2
200016b0:	1044000e 	beq	v0,a0,200016ec <Opponent_Tracker_Update+0xa8>
200016b4:	2c440003 	sltiu	a0,v0,3
200016b8:	10800007 	beqz	a0,200016d8 <Opponent_Tracker_Update+0x94>
200016bc:	00000000 	nop
200016c0:	10400021 	beqz	v0,20001748 <Opponent_Tracker_Update+0x104>
200016c4:	24040001 	li	a0,1
200016c8:	1444001a 	bne	v0,a0,20001734 <Opponent_Tracker_Update+0xf0>
200016cc:	2c63000f 	sltiu	v1,v1,15
200016d0:	080005c9 	j	20001724 <Opponent_Tracker_Update+0xe0>
200016d4:	00000000 	nop
200016d8:	2c420008 	sltiu	v0,v0,8
200016dc:	10400016 	beqz	v0,20001738 <Opponent_Tracker_Update+0xf4>
200016e0:	24020001 	li	v0,1
			break;
		}
	}
	else
	{
		Opponent_detected = False;
200016e4:	080005d3 	j	2000174c <Opponent_Tracker_Update+0x108>
200016e8:	af800040 	sw	zero,64(gp)
		case Lf:
		case Rt:
			Opponent_detected = False;
			break;
		case Bd:
			if(
200016ec:	3c024000 	lui	v0,0x4000
200016f0:	8c430660 	lw	v1,1632(v0)
200016f4:	00000000 	nop
200016f8:	2c630091 	sltiu	v1,v1,145
200016fc:	1060000d 	beqz	v1,20001734 <Opponent_Tracker_Update+0xf0>
20001700:	24420660 	addiu	v0,v0,1632
20001704:	8c420004 	lw	v0,4(v0)
20001708:	00000000 	nop
2000170c:	2c420091 	sltiu	v0,v0,145
20001710:	10400009 	beqz	v0,20001738 <Opponent_Tracker_Update+0xf4>
20001714:	24020001 	li	v0,1
				Right_motor_direction_G = Off;
				Opponent_detected = True;
			}
			else
			{
				Opponent_detected = False;
20001718:	af800040 	sw	zero,64(gp)
				sensorDebounce = 0;
2000171c:	080005d3 	j	2000174c <Opponent_Tracker_Update+0x108>
20001720:	a3800144 	sb	zero,324(gp)
			}
			break;
		case Fd:
			if(
20001724:	14600004 	bnez	v1,20001738 <Opponent_Tracker_Update+0xf4>
20001728:	00000000 	nop
				Right_motor_direction_G = Off;
				Opponent_detected = True;
			}
			else
			{
				sensorDebounce = 0;
2000172c:	080005d2 	j	20001748 <Opponent_Tracker_Update+0x104>
20001730:	a3800144 	sb	zero,324(gp)
			}
			break;
		default:
			Left_motor_direction_G = Off;
			Right_motor_direction_G = Off;
			Opponent_detected = True;
20001734:	24020001 	li	v0,1
20001738:	af820040 	sw	v0,64(gp)
				sensorDebounce = 0;
				Opponent_detected = False;
			}
			break;
		default:
			Left_motor_direction_G = Off;
2000173c:	af800094 	sw	zero,148(gp)
			Right_motor_direction_G = Off;
20001740:	080005d3 	j	2000174c <Opponent_Tracker_Update+0x108>
20001744:	af800084 	sw	zero,132(gp)
			break;
		}
	}
	else
	{
		Opponent_detected = False;
20001748:	af800040 	sw	zero,64(gp)
	}

	reversible = sensorReadings.USFwd;

	Segment_Write(displayA, (reversible & 0x000F) >> 0);
2000174c:	8f84ffb4 	lw	a0,-76(gp)
20001750:	0c000f5f 	jal	20003d7c <Segment_Write>
20001754:	3205000f 	andi	a1,s0,0xf
	Segment_Write(displayB, (reversible & 0x00F0) >> 4);
20001758:	8f84ffb8 	lw	a0,-72(gp)
2000175c:	320500f0 	andi	a1,s0,0xf0
20001760:	0c000f5f 	jal	20003d7c <Segment_Write>
20001764:	00052902 	srl	a1,a1,0x4
	Segment_Write(displayC, (reversible & 0x0F00) >> 8);
20001768:	8f84ffbc 	lw	a0,-68(gp)
2000176c:	32050f00 	andi	a1,s0,0xf00
20001770:	0c000f5f 	jal	20003d7c <Segment_Write>
20001774:	00052a02 	srl	a1,a1,0x8
	Segment_Write(displayD, (reversible & 0xF000) >> 12);
20001778:	3205f000 	andi	a1,s0,0xf000
2000177c:	8f84ffc0 	lw	a0,-64(gp)

}
20001780:	8fbf0014 	lw	ra,20(sp)
20001784:	8fb00010 	lw	s0,16(sp)
	reversible = sensorReadings.USFwd;

	Segment_Write(displayA, (reversible & 0x000F) >> 0);
	Segment_Write(displayB, (reversible & 0x00F0) >> 4);
	Segment_Write(displayC, (reversible & 0x0F00) >> 8);
	Segment_Write(displayD, (reversible & 0xF000) >> 12);
20001788:	00052b02 	srl	a1,a1,0xc
2000178c:	08000f5f 	j	20003d7c <Segment_Write>
20001790:	27bd0018 	addiu	sp,sp,24

20001794 <rampDownRight>:

	visualsRt();
}

uint16_t rampDownRight(int32_t scriptCount, int32_t currentCount, Bool correction)
{
20001794:	27bdffe8 	addiu	sp,sp,-24
	double posDelta;
	int16_t speed;
	uint16_t result;

	if(scriptCount > currentCount)
20001798:	00a4102a 	slt	v0,a1,a0

	visualsRt();
}

uint16_t rampDownRight(int32_t scriptCount, int32_t currentCount, Bool correction)
{
2000179c:	afb00010 	sw	s0,16(sp)
200017a0:	afbf0014 	sw	ra,20(sp)
	double posDelta;
	int16_t speed;
	uint16_t result;

	if(scriptCount > currentCount)
200017a4:	10400003 	beqz	v0,200017b4 <rampDownRight+0x20>
200017a8:	00c08021 	move	s0,a2
	{
		posDelta = scriptCount - currentCount;
200017ac:	080005f3 	j	200017cc <rampDownRight+0x38>
200017b0:	00852023 	subu	a0,a0,a1
	}
	else if(scriptCount < currentCount)
200017b4:	0085102a 	slt	v0,a0,a1
200017b8:	14400004 	bnez	v0,200017cc <rampDownRight+0x38>
200017bc:	00a42023 	subu	a0,a1,a0
200017c0:	00001021 	move	v0,zero
200017c4:	080005f5 	j	200017d4 <rampDownRight+0x40>
200017c8:	00001821 	move	v1,zero
	{
		posDelta = currentCount - scriptCount;
200017cc:	0c00123d 	jal	200048f4 <__floatsidf>
200017d0:	00000000 	nop
	else
	{
		posDelta = 0.0;
	}

	speed = (RPM_FACTOR * posDelta) + RPM_FLOOR;
200017d4:	8f86ffcc 	lw	a2,-52(gp)
200017d8:	8f87ffd0 	lw	a3,-48(gp)
200017dc:	00402021 	move	a0,v0
200017e0:	0c001154 	jal	20004550 <__muldf3>
200017e4:	00602821 	move	a1,v1
200017e8:	8f86ffd4 	lw	a2,-44(gp)
200017ec:	8f87ffd8 	lw	a3,-40(gp)
200017f0:	00402021 	move	a0,v0
200017f4:	0c001139 	jal	200044e4 <__adddf3>
200017f8:	00602821 	move	a1,v1
200017fc:	00602821 	move	a1,v1
20001800:	0c001272 	jal	200049c8 <__fixdfsi>
20001804:	00402021 	move	a0,v0
20001808:	00021400 	sll	v0,v0,0x10
2000180c:	00021403 	sra	v0,v0,0x10

	if(speed >= RPM_LIMIT)
20001810:	28430030 	slti	v1,v0,48
20001814:	14600002 	bnez	v1,20001820 <rampDownRight+0x8c>
20001818:	24030001 	li	v1,1
2000181c:	24020030 	li	v0,48
	{
		speed = RPM_LIMIT;
	}

	if(correction == True && speed > CORRECTION_THRESHOLD)
20001820:	16030008 	bne	s0,v1,20001844 <rampDownRight+0xb0>
20001824:	2843000c 	slti	v1,v0,12
20001828:	28430019 	slti	v1,v0,25
2000182c:	14600005 	bnez	v1,20001844 <rampDownRight+0xb0>
20001830:	2843000c 	slti	v1,v0,12
	{
		speed -= CORRECTION_VALUE;
20001834:	2442fffc 	addiu	v0,v0,-4
20001838:	00021400 	sll	v0,v0,0x10
2000183c:	00021403 	sra	v0,v0,0x10
20001840:	2843000c 	slti	v1,v0,12
20001844:	10600002 	beqz	v1,20001850 <rampDownRight+0xbc>
20001848:	00000000 	nop
2000184c:	2402000c 	li	v0,12
		speed = CRAWL_SPEED;
	}

	result = (uint16_t)(speed);
	return result;
}
20001850:	8fbf0014 	lw	ra,20(sp)
20001854:	3042ffff 	andi	v0,v0,0xffff
20001858:	8fb00010 	lw	s0,16(sp)
2000185c:	03e00008 	jr	ra
20001860:	27bd0018 	addiu	sp,sp,24

20001864 <visualsRt>:

void visualsRt(void)
{
	if(System_Mode_G == Go || System_Mode_G == Game_Over)
20001864:	8f8200f8 	lw	v0,248(gp)
	result = (uint16_t)(speed);
	return result;
}

void visualsRt(void)
{
20001868:	27bdffe8 	addiu	sp,sp,-24
	if(System_Mode_G == Go || System_Mode_G == Game_Over)
2000186c:	24030002 	li	v1,2
20001870:	10430004 	beq	v0,v1,20001884 <visualsRt+0x20>
20001874:	afbf0014 	sw	ra,20(sp)
20001878:	24030004 	li	v1,4
2000187c:	14430009 	bne	v0,v1,200018a4 <visualsRt+0x40>
20001880:	00000000 	nop
	{
		Segment_Set_Decimal(displayA);
20001884:	8f84ffc4 	lw	a0,-60(gp)
20001888:	0c000f76 	jal	20003dd8 <Segment_Set_Decimal>
2000188c:	00000000 	nop
		Segment_Set_Decimal(displayB);
20001890:	8f84ffc8 	lw	a0,-56(gp)
20001894:	0c000f76 	jal	20003dd8 <Segment_Set_Decimal>
20001898:	00000000 	nop
	return result;
}

void visualsRt(void)
{
	if(System_Mode_G == Go || System_Mode_G == Game_Over)
2000189c:	0800062f 	j	200018bc <visualsRt+0x58>
200018a0:	00000000 	nop
		Segment_Set_Decimal(displayA);
		Segment_Set_Decimal(displayB);
	}
	else
	{
		Segment_Clear_Decimal(displayA);
200018a4:	8f84ffc4 	lw	a0,-60(gp)
200018a8:	0c000f88 	jal	20003e20 <Segment_Clear_Decimal>
200018ac:	00000000 	nop
		Segment_Clear_Decimal(displayB);
200018b0:	8f84ffc8 	lw	a0,-56(gp)
200018b4:	0c000f88 	jal	20003e20 <Segment_Clear_Decimal>
200018b8:	00000000 	nop
	}

	if(
		Right_motor_direction_G == Forwards
		&& Right_motor_speed_G != 0
200018bc:	8f830084 	lw	v1,132(gp)
	{
		Segment_Clear_Decimal(displayA);
		Segment_Clear_Decimal(displayB);
	}

	if(
200018c0:	24020001 	li	v0,1
200018c4:	1462000f 	bne	v1,v0,20001904 <visualsRt+0xa0>
200018c8:	3c028000 	lui	v0,0x8000
200018cc:	978200b2 	lhu	v0,178(gp)
200018d0:	00000000 	nop
200018d4:	1040000b 	beqz	v0,20001904 <visualsRt+0xa0>
200018d8:	3c028000 	lui	v0,0x8000
		Right_motor_direction_G == Forwards
		&& Right_motor_speed_G != 0
		)
	{
		GPIO_Write(LED_Pin_RtFd, GPIO_HIGH);
200018dc:	34420200 	ori	v0,v0,0x200
200018e0:	8c430000 	lw	v1,0(v0)
200018e4:	00000000 	nop
200018e8:	ac430000 	sw	v1,0(v0)
200018ec:	8c430000 	lw	v1,0(v0)
200018f0:	00000000 	nop
200018f4:	34630002 	ori	v1,v1,0x2
200018f8:	ac430000 	sw	v1,0(v0)
	{
		GPIO_Write(LED_Pin_RtBd, GPIO_HIGH);
	}
	else
	{
		GPIO_Write(LED_Pin_RtBd, GPIO_LOW);
200018fc:	08000657 	j	2000195c <visualsRt+0xf8>
20001900:	3c028000 	lui	v0,0x8000
	{
		GPIO_Write(LED_Pin_RtFd, GPIO_HIGH);
	}
	else
	{
		GPIO_Write(LED_Pin_RtFd, GPIO_LOW);
20001904:	34420200 	ori	v0,v0,0x200
20001908:	8c450000 	lw	a1,0(v0)
2000190c:	2404fffd 	li	a0,-3
20001910:	00a42024 	and	a0,a1,a0
20001914:	ac440000 	sw	a0,0(v0)
20001918:	8c440000 	lw	a0,0(v0)
2000191c:	00000000 	nop
20001920:	ac440000 	sw	a0,0(v0)
	}

	if(
20001924:	24040002 	li	a0,2
20001928:	1464000b 	bne	v1,a0,20001958 <visualsRt+0xf4>
2000192c:	00000000 	nop
20001930:	978300b2 	lhu	v1,178(gp)
20001934:	00000000 	nop
20001938:	10600007 	beqz	v1,20001958 <visualsRt+0xf4>
2000193c:	00000000 	nop
		Right_motor_direction_G == Reverse
		&& Right_motor_speed_G != 0
		)
	{
		GPIO_Write(LED_Pin_RtBd, GPIO_HIGH);
20001940:	8c430000 	lw	v1,0(v0)
20001944:	00000000 	nop
20001948:	ac430000 	sw	v1,0(v0)
2000194c:	8c430000 	lw	v1,0(v0)
20001950:	0800065d 	j	20001974 <visualsRt+0x110>
20001954:	34630001 	ori	v1,v1,0x1
	}
	else
	{
		GPIO_Write(LED_Pin_RtBd, GPIO_LOW);
20001958:	3c028000 	lui	v0,0x8000
2000195c:	34420200 	ori	v0,v0,0x200
20001960:	8c440000 	lw	a0,0(v0)
20001964:	2403fffe 	li	v1,-2
20001968:	00831824 	and	v1,a0,v1
2000196c:	ac430000 	sw	v1,0(v0)
20001970:	8c430000 	lw	v1,0(v0)
	}

	//Segment_Write(displayA, (Motor_Rt_Enc_Track & 0x000F) >> 0);
	//Segment_Write(displayB, (Motor_Rt_Enc_Track & 0x00F0) >> 4);
}
20001974:	8fbf0014 	lw	ra,20(sp)
	{
		GPIO_Write(LED_Pin_RtBd, GPIO_HIGH);
	}
	else
	{
		GPIO_Write(LED_Pin_RtBd, GPIO_LOW);
20001978:	ac430000 	sw	v1,0(v0)
	}

	//Segment_Write(displayA, (Motor_Rt_Enc_Track & 0x000F) >> 0);
	//Segment_Write(displayB, (Motor_Rt_Enc_Track & 0x00F0) >> 4);
}
2000197c:	03e00008 	jr	ra
20001980:	27bd0018 	addiu	sp,sp,24

20001984 <Motor_Right_Update>:
 */
void Motor_Right_Update(void)
{
	Bearing moveRt;

	if(System_Mode_G == Go)
20001984:	8f8600f8 	lw	a2,248(gp)

/**
 * Motor_Right controller operation
 */
void Motor_Right_Update(void)
{
20001988:	27bdffe8 	addiu	sp,sp,-24
	Bearing moveRt;

	if(System_Mode_G == Go)
2000198c:	24020002 	li	v0,2
20001990:	14c20082 	bne	a2,v0,20001b9c <Motor_Right_Update+0x218>
20001994:	afbf0014 	sw	ra,20(sp)
	{
		moveRt = Script_G.Movement[Script_no_G];
20001998:	938300e0 	lbu	v1,224(gp)
2000199c:	3c024000 	lui	v0,0x4000
200019a0:	00032080 	sll	a0,v1,0x2
200019a4:	2442066c 	addiu	v0,v0,1644
200019a8:	00821021 	addu	v0,a0,v0

		/* Calculate the absolute value of encoder counts since previous update */
		Enc_Rt_Diff = (WheelCounts_Right_G - Enc_Rt_Old);
200019ac:	8f8500c8 	lw	a1,200(gp)
200019b0:	8f840148 	lw	a0,328(gp)
{
	Bearing moveRt;

	if(System_Mode_G == Go)
	{
		moveRt = Script_G.Movement[Script_no_G];
200019b4:	8c420000 	lw	v0,0(v0)

		/* Calculate the absolute value of encoder counts since previous update */
		Enc_Rt_Diff = (WheelCounts_Right_G - Enc_Rt_Old);
200019b8:	00a42023 	subu	a0,a1,a0

		/* Encoder counting */
		if(moveRt == Fd || moveRt == Lf)
200019bc:	24070001 	li	a3,1
200019c0:	10470004 	beq	v0,a3,200019d4 <Motor_Right_Update+0x50>
200019c4:	af840150 	sw	a0,336(gp)
200019c8:	24070003 	li	a3,3
200019cc:	14470004 	bne	v0,a3,200019e0 <Motor_Right_Update+0x5c>
200019d0:	00000000 	nop
		{
			Motor_Rt_Enc_Track += Enc_Rt_Diff;
200019d4:	8f8600d8 	lw	a2,216(gp)
200019d8:	0800067f 	j	200019fc <Motor_Right_Update+0x78>
200019dc:	00c42021 	addu	a0,a2,a0
		}
		else if(moveRt == Bd || moveRt == Rt)
200019e0:	10460003 	beq	v0,a2,200019f0 <Motor_Right_Update+0x6c>
200019e4:	24060004 	li	a2,4
200019e8:	14460005 	bne	v0,a2,20001a00 <Motor_Right_Update+0x7c>
200019ec:	00000000 	nop
		{
			Motor_Rt_Enc_Track -= Enc_Rt_Diff;
200019f0:	8f8600d8 	lw	a2,216(gp)
200019f4:	00000000 	nop
200019f8:	00c42023 	subu	a0,a2,a0
200019fc:	af8400d8 	sw	a0,216(gp)
		}

		Enc_Rt_Old = WheelCounts_Right_G;

		/* Check to see if the next step in the Script is to be executed */
		if(Script_no_check_Rt != Script_no_G)
20001a00:	93840154 	lbu	a0,340(gp)
20001a04:	00000000 	nop
20001a08:	10830005 	beq	a0,v1,20001a20 <Motor_Right_Update+0x9c>
20001a0c:	af850148 	sw	a1,328(gp)
		{
			Script_no_check_Rt = Script_no_G;
20001a10:	a3830154 	sb	v1,340(gp)
			Motor_Rt_Enc_Track = 0;
20001a14:	af8000d8 	sw	zero,216(gp)
			scriptTimeoutRt = 0;
20001a18:	0800068c 	j	20001a30 <Motor_Right_Update+0xac>
20001a1c:	a780014c 	sh	zero,332(gp)
		}
		else
		{
			Script_no_check_Rt = Script_no_G;
			scriptTimeoutRt++;
20001a20:	9784014c 	lhu	a0,332(gp)
			Motor_Rt_Enc_Track = 0;
			scriptTimeoutRt = 0;
		}
		else
		{
			Script_no_check_Rt = Script_no_G;
20001a24:	a3830154 	sb	v1,340(gp)
			scriptTimeoutRt++;
20001a28:	24840001 	addiu	a0,a0,1
20001a2c:	a784014c 	sh	a0,332(gp)
		}

		if(scriptTimeoutRt > 5000)
20001a30:	9784014c 	lhu	a0,332(gp)
20001a34:	00000000 	nop
20001a38:	2c841389 	sltiu	a0,a0,5001
20001a3c:	10800051 	beqz	a0,20001b84 <Motor_Right_Update+0x200>
20001a40:	24040004 	li	a0,4
		{
			moveRt = DeployLf;
		}

		/* Script reader */
		switch(moveRt)
20001a44:	10440022 	beq	v0,a0,20001ad0 <Motor_Right_Update+0x14c>
20001a48:	2c440005 	sltiu	a0,v0,5
20001a4c:	1080000a 	beqz	a0,20001a78 <Motor_Right_Update+0xf4>
20001a50:	2c440007 	sltiu	a0,v0,7
20001a54:	24040002 	li	a0,2
20001a58:	1044001d 	beq	v0,a0,20001ad0 <Motor_Right_Update+0x14c>
20001a5c:	2c440003 	sltiu	a0,v0,3
20001a60:	1080000b 	beqz	a0,20001a90 <Motor_Right_Update+0x10c>
20001a64:	24040001 	li	a0,1
20001a68:	14440049 	bne	v0,a0,20001b90 <Motor_Right_Update+0x20c>
20001a6c:	24630040 	addiu	v1,v1,64
		{
		case Fd:
		case Lf:
			/* Check the encoder tracker has reached the target count */
			if(Motor_Rt_Enc_Track < (Script_G.Enc_counts[Script_no_G] - BUFFER_COUNT))
20001a70:	080006a6 	j	20001a98 <Motor_Right_Update+0x114>
20001a74:	3c024000 	lui	v0,0x4000
		{
			moveRt = DeployLf;
		}

		/* Script reader */
		switch(moveRt)
20001a78:	14800042 	bnez	a0,20001b84 <Motor_Right_Update+0x200>
20001a7c:	24040007 	li	a0,7
20001a80:	14440043 	bne	v0,a0,20001b90 <Motor_Right_Update+0x20c>
20001a84:	24630040 	addiu	v1,v1,64
			Right_motor_direction_G = Reverse;
			Right_motor_speed_G = BOTTLE_SPEED;
			if(
					//(Motor_Rt_Enc_Track > Script_G.Enc_counts[Script_no_G])
					//||
					(++bottleTimeoutRt > Script_G.Enc_counts[Script_no_G])
20001a88:	080006d2 	j	20001b48 <Motor_Right_Update+0x1c4>
20001a8c:	3c024000 	lui	v0,0x4000
		switch(moveRt)
		{
		case Fd:
		case Lf:
			/* Check the encoder tracker has reached the target count */
			if(Motor_Rt_Enc_Track < (Script_G.Enc_counts[Script_no_G] - BUFFER_COUNT))
20001a90:	24630040 	addiu	v1,v1,64
20001a94:	3c024000 	lui	v0,0x4000
20001a98:	2442066c 	addiu	v0,v0,1644
20001a9c:	00031880 	sll	v1,v1,0x2
20001aa0:	00621821 	addu	v1,v1,v0
20001aa4:	8c640000 	lw	a0,0(v1)
20001aa8:	8f8500d8 	lw	a1,216(gp)
20001aac:	2482fffe 	addiu	v0,a0,-2
20001ab0:	00a2102a 	slt	v0,a1,v0
20001ab4:	14400018 	bnez	v0,20001b18 <Motor_Right_Update+0x194>
20001ab8:	24820002 	addiu	v0,a0,2
				End_Of_MoveRt = False;
				Right_motor_direction_G = Forwards;
				Right_motor_speed_G = rampDownRight(Script_G.Enc_counts[Script_no_G], Motor_Rt_Enc_Track, Course_correction_Rt);
			}
			/* Check for overshoot */
			else if(Motor_Rt_Enc_Track > (Script_G.Enc_counts[Script_no_G] + BUFFER_COUNT))
20001abc:	0045102a 	slt	v0,v0,a1
20001ac0:	1040001c 	beqz	v0,20001b34 <Motor_Right_Update+0x1b0>
20001ac4:	00000000 	nop
20001ac8:	080006bf 	j	20001afc <Motor_Right_Update+0x178>
20001acc:	00000000 	nop
			}
			break;
		case Bd:
		case Rt:
			if(
					Motor_Rt_Enc_Track < (Script_G.Enc_counts[Script_no_G] - BUFFER_COUNT)
20001ad0:	24630040 	addiu	v1,v1,64
20001ad4:	3c024000 	lui	v0,0x4000
20001ad8:	2442066c 	addiu	v0,v0,1644
20001adc:	00031880 	sll	v1,v1,0x2
20001ae0:	00621821 	addu	v1,v1,v0
20001ae4:	8c640000 	lw	a0,0(v1)
20001ae8:	8f8500d8 	lw	a1,216(gp)
				bottleTimeoutRt = 0;
			}
			break;
		case Bd:
		case Rt:
			if(
20001aec:	2482fffe 	addiu	v0,a0,-2
20001af0:	00a2102a 	slt	v0,a1,v0
20001af4:	10400004 	beqz	v0,20001b08 <Motor_Right_Update+0x184>
20001af8:	00000000 	nop
					//(GPIO_Get(Right_SW) != GPIO_LOW)
				)
			{
				End_Of_MoveRt = False;
				Right_motor_direction_G = Reverse;
				Right_motor_speed_G = rampDownRight(Script_G.Enc_counts[Script_no_G], Motor_Rt_Enc_Track, Course_correction_Rt);
20001afc:	8f860060 	lw	a2,96(gp)
					//&&
					//(GPIO_Get(Right_SW) != GPIO_LOW)
				)
			{
				End_Of_MoveRt = False;
				Right_motor_direction_G = Reverse;
20001b00:	080006c8 	j	20001b20 <Motor_Right_Update+0x19c>
20001b04:	24020002 	li	v0,2
				Right_motor_speed_G = rampDownRight(Script_G.Enc_counts[Script_no_G], Motor_Rt_Enc_Track, Course_correction_Rt);
			}
			else if(Motor_Rt_Enc_Track > (Script_G.Enc_counts[Script_no_G] + BUFFER_COUNT))
20001b08:	24820002 	addiu	v0,a0,2
20001b0c:	0045102a 	slt	v0,v0,a1
20001b10:	10400009 	beqz	v0,20001b38 <Motor_Right_Update+0x1b4>
20001b14:	24020001 	li	v0,1
			{
				End_Of_MoveRt = False;
				Right_motor_direction_G = Forwards;
				Right_motor_speed_G = rampDownRight(Script_G.Enc_counts[Script_no_G], Motor_Rt_Enc_Track, Course_correction_Rt);
20001b18:	8f860060 	lw	a2,96(gp)
				Right_motor_speed_G = rampDownRight(Script_G.Enc_counts[Script_no_G], Motor_Rt_Enc_Track, Course_correction_Rt);
			}
			else if(Motor_Rt_Enc_Track > (Script_G.Enc_counts[Script_no_G] + BUFFER_COUNT))
			{
				End_Of_MoveRt = False;
				Right_motor_direction_G = Forwards;
20001b1c:	24020001 	li	v0,1
20001b20:	af820084 	sw	v0,132(gp)
				Right_motor_speed_G = rampDownRight(Script_G.Enc_counts[Script_no_G], Motor_Rt_Enc_Track, Course_correction_Rt);
20001b24:	0c0005e5 	jal	20001794 <rampDownRight>
20001b28:	af8000e4 	sw	zero,228(gp)
20001b2c:	080006ec 	j	20001bb0 <Motor_Right_Update+0x22c>
20001b30:	a78200b2 	sh	v0,178(gp)
			}
			else
			{
				End_Of_MoveRt = True;
20001b34:	24020001 	li	v0,1
20001b38:	af8200e4 	sw	v0,228(gp)
				Right_motor_speed_G = 0x0;
20001b3c:	a78000b2 	sh	zero,178(gp)
				bottleTimeoutRt = 0;
20001b40:	080006ec 	j	20001bb0 <Motor_Right_Update+0x22c>
20001b44:	a7800156 	sh	zero,342(gp)
			Right_motor_direction_G = Reverse;
			Right_motor_speed_G = BOTTLE_SPEED;
			if(
					//(Motor_Rt_Enc_Track > Script_G.Enc_counts[Script_no_G])
					//||
					(++bottleTimeoutRt > Script_G.Enc_counts[Script_no_G])
20001b48:	2442066c 	addiu	v0,v0,1644
20001b4c:	00031880 	sll	v1,v1,0x2
20001b50:	00621821 	addu	v1,v1,v0
20001b54:	97820156 	lhu	v0,342(gp)
20001b58:	8c630000 	lw	v1,0(v1)
20001b5c:	24420001 	addiu	v0,v0,1
20001b60:	3042ffff 	andi	v0,v0,0xffff
				bottleTimeoutRt = 0;
			}
			break;
		case Press:
			End_Of_MoveRt = False;
			Right_motor_direction_G = Reverse;
20001b64:	24040002 	li	a0,2
20001b68:	af840084 	sw	a0,132(gp)
			Right_motor_speed_G = BOTTLE_SPEED;
			if(
					//(Motor_Rt_Enc_Track > Script_G.Enc_counts[Script_no_G])
					//||
					(++bottleTimeoutRt > Script_G.Enc_counts[Script_no_G])
20001b6c:	0062182a 	slt	v1,v1,v0
			}
			break;
		case Press:
			End_Of_MoveRt = False;
			Right_motor_direction_G = Reverse;
			Right_motor_speed_G = BOTTLE_SPEED;
20001b70:	24040018 	li	a0,24
20001b74:	a78400b2 	sh	a0,178(gp)
				Right_motor_speed_G = 0x0;
				bottleTimeoutRt = 0;
			}
			break;
		case Press:
			End_Of_MoveRt = False;
20001b78:	af8000e4 	sw	zero,228(gp)
			Right_motor_direction_G = Reverse;
			Right_motor_speed_G = BOTTLE_SPEED;
			if(
					//(Motor_Rt_Enc_Track > Script_G.Enc_counts[Script_no_G])
					//||
					(++bottleTimeoutRt > Script_G.Enc_counts[Script_no_G])
20001b7c:	1060000c 	beqz	v1,20001bb0 <Motor_Right_Update+0x22c>
20001b80:	a7820156 	sh	v0,342(gp)
				Right_motor_speed_G = 0x0;
			}
			break;
		case DeployRt:
		case DeployLf:
			End_Of_MoveRt = True;
20001b84:	24020001 	li	v0,1
20001b88:	080006e5 	j	20001b94 <Motor_Right_Update+0x210>
20001b8c:	af8200e4 	sw	v0,228(gp)
			Right_motor_speed_G = 0x0;
			break;
		case Stp:
		default:
			End_Of_MoveRt = False;
20001b90:	af8000e4 	sw	zero,228(gp)
			Right_motor_speed_G = 0;
20001b94:	080006ec 	j	20001bb0 <Motor_Right_Update+0x22c>
20001b98:	a78000b2 	sh	zero,178(gp)
			break;
		}
	}
	else
	{
		Right_motor_direction_G = Off;
20001b9c:	af800084 	sw	zero,132(gp)
		Right_motor_speed_G = 0;
20001ba0:	a78000b2 	sh	zero,178(gp)
		Motor_Rt_Enc_Track = 0;
20001ba4:	af8000d8 	sw	zero,216(gp)
		Enc_Rt_Diff = 0;
20001ba8:	af800150 	sw	zero,336(gp)
		Enc_Rt_Old = 0;
20001bac:	af800148 	sw	zero,328(gp)
	}

	visualsRt();
}
20001bb0:	8fbf0014 	lw	ra,20(sp)
		Motor_Rt_Enc_Track = 0;
		Enc_Rt_Diff = 0;
		Enc_Rt_Old = 0;
	}

	visualsRt();
20001bb4:	08000619 	j	20001864 <visualsRt>
20001bb8:	27bd0018 	addiu	sp,sp,24

20001bbc <Motor_Right_Init>:

	End_Of_MoveRt = False;
	bottleTimeoutRt = 0;
	scriptTimeoutRt = 0;

	GPIO_Set_Direction(LED_Pin_RtFd, GPIO_OUTPUT);
20001bbc:	3c038000 	lui	v1,0x8000
20001bc0:	34620200 	ori	v0,v1,0x200
20001bc4:	8c450004 	lw	a1,4(v0)
20001bc8:	2404fffd 	li	a0,-3
20001bcc:	00a42824 	and	a1,a1,a0
20001bd0:	ac450004 	sw	a1,4(v0)
20001bd4:	8c460004 	lw	a2,4(v0)
	GPIO_Write(LED_Pin_RtFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_RtBd, GPIO_OUTPUT);
20001bd8:	2405fffe 	li	a1,-2

	End_Of_MoveRt = False;
	bottleTimeoutRt = 0;
	scriptTimeoutRt = 0;

	GPIO_Set_Direction(LED_Pin_RtFd, GPIO_OUTPUT);
20001bdc:	34c60002 	ori	a2,a2,0x2
20001be0:	ac460004 	sw	a2,4(v0)
	GPIO_Write(LED_Pin_RtFd, GPIO_LOW);
20001be4:	8c460000 	lw	a2,0(v0)
	GPIO_Set_Direction(LED_Pin_RtBd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_RtBd, GPIO_LOW);
	GPIO_Set_Direction(Right_SW, GPIO_INPUT);
20001be8:	34630500 	ori	v1,v1,0x500
	End_Of_MoveRt = False;
	bottleTimeoutRt = 0;
	scriptTimeoutRt = 0;

	GPIO_Set_Direction(LED_Pin_RtFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_RtFd, GPIO_LOW);
20001bec:	00c42024 	and	a0,a2,a0
20001bf0:	ac440000 	sw	a0,0(v0)
20001bf4:	8c440000 	lw	a0,0(v0)
/**
 * Initialisation for the Motor_Right package.
 * This will be called from Tasks_Init by default.
 */
void Motor_Right_Init(void)
{
20001bf8:	27bdffe8 	addiu	sp,sp,-24
	End_Of_MoveRt = False;
	bottleTimeoutRt = 0;
	scriptTimeoutRt = 0;

	GPIO_Set_Direction(LED_Pin_RtFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_RtFd, GPIO_LOW);
20001bfc:	ac440000 	sw	a0,0(v0)
	GPIO_Set_Direction(LED_Pin_RtBd, GPIO_OUTPUT);
20001c00:	8c460004 	lw	a2,4(v0)
	GPIO_Write(LED_Pin_RtBd, GPIO_LOW);
	GPIO_Set_Direction(Right_SW, GPIO_INPUT);

	Segment_Enable(displayA);
20001c04:	8f84ffc4 	lw	a0,-60(gp)
	bottleTimeoutRt = 0;
	scriptTimeoutRt = 0;

	GPIO_Set_Direction(LED_Pin_RtFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_RtFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_RtBd, GPIO_OUTPUT);
20001c08:	00c53024 	and	a2,a2,a1
20001c0c:	ac460004 	sw	a2,4(v0)
20001c10:	8c460004 	lw	a2,4(v0)
/**
 * Initialisation for the Motor_Right package.
 * This will be called from Tasks_Init by default.
 */
void Motor_Right_Init(void)
{
20001c14:	afbf0014 	sw	ra,20(sp)
	bottleTimeoutRt = 0;
	scriptTimeoutRt = 0;

	GPIO_Set_Direction(LED_Pin_RtFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_RtFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_RtBd, GPIO_OUTPUT);
20001c18:	34c60001 	ori	a2,a2,0x1
20001c1c:	ac460004 	sw	a2,4(v0)
	GPIO_Write(LED_Pin_RtBd, GPIO_LOW);
20001c20:	8c460000 	lw	a2,0(v0)
 * This will be called from Tasks_Init by default.
 */
void Motor_Right_Init(void)
{
	/* Task initialisation */
	Right_motor_direction_G = Off;
20001c24:	af800084 	sw	zero,132(gp)
	scriptTimeoutRt = 0;

	GPIO_Set_Direction(LED_Pin_RtFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_RtFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_RtBd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_RtBd, GPIO_LOW);
20001c28:	00c52824 	and	a1,a2,a1
20001c2c:	ac450000 	sw	a1,0(v0)
20001c30:	8c450000 	lw	a1,0(v0)
void Motor_Right_Init(void)
{
	/* Task initialisation */
	Right_motor_direction_G = Off;
	Right_motor_speed_G = 0;
	Motor_Rt_Enc_Track = 0;
20001c34:	af8000d8 	sw	zero,216(gp)
	scriptTimeoutRt = 0;

	GPIO_Set_Direction(LED_Pin_RtFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_RtFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_RtBd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_RtBd, GPIO_LOW);
20001c38:	ac450000 	sw	a1,0(v0)
	GPIO_Set_Direction(Right_SW, GPIO_INPUT);
20001c3c:	8c650004 	lw	a1,4(v1)
20001c40:	2402ffdf 	li	v0,-33
20001c44:	00a21024 	and	v0,a1,v0
{
	/* Task initialisation */
	Right_motor_direction_G = Off;
	Right_motor_speed_G = 0;
	Motor_Rt_Enc_Track = 0;
	Script_no_check_Rt = 0;
20001c48:	a3800154 	sb	zero,340(gp)

	GPIO_Set_Direction(LED_Pin_RtFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_RtFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_RtBd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_RtBd, GPIO_LOW);
	GPIO_Set_Direction(Right_SW, GPIO_INPUT);
20001c4c:	ac620004 	sw	v0,4(v1)
20001c50:	8c620004 	lw	v0,4(v1)
 */
void Motor_Right_Init(void)
{
	/* Task initialisation */
	Right_motor_direction_G = Off;
	Right_motor_speed_G = 0;
20001c54:	a78000b2 	sh	zero,178(gp)

	GPIO_Set_Direction(LED_Pin_RtFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_RtFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_RtBd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_RtBd, GPIO_LOW);
	GPIO_Set_Direction(Right_SW, GPIO_INPUT);
20001c58:	ac620004 	sw	v0,4(v1)
	Right_motor_direction_G = Off;
	Right_motor_speed_G = 0;
	Motor_Rt_Enc_Track = 0;
	Script_no_check_Rt = 0;

	End_Of_MoveRt = False;
20001c5c:	af8000e4 	sw	zero,228(gp)
	bottleTimeoutRt = 0;
20001c60:	a7800156 	sh	zero,342(gp)
	GPIO_Write(LED_Pin_RtFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_RtBd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_RtBd, GPIO_LOW);
	GPIO_Set_Direction(Right_SW, GPIO_INPUT);

	Segment_Enable(displayA);
20001c64:	0c000f4d 	jal	20003d34 <Segment_Enable>
20001c68:	a780014c 	sh	zero,332(gp)
	Segment_Write(displayA, 0x0);
20001c6c:	8f84ffc4 	lw	a0,-60(gp)
20001c70:	0c000f5f 	jal	20003d7c <Segment_Write>
20001c74:	00002821 	move	a1,zero
	Segment_Clear_Decimal(displayA);
20001c78:	8f84ffc4 	lw	a0,-60(gp)
20001c7c:	0c000f88 	jal	20003e20 <Segment_Clear_Decimal>
20001c80:	00000000 	nop
	Segment_Enable(displayB);
20001c84:	8f84ffc8 	lw	a0,-56(gp)
20001c88:	0c000f4d 	jal	20003d34 <Segment_Enable>
20001c8c:	00000000 	nop
	Segment_Write(displayB, 0x0);
20001c90:	8f84ffc8 	lw	a0,-56(gp)
20001c94:	0c000f5f 	jal	20003d7c <Segment_Write>
20001c98:	00002821 	move	a1,zero
	Segment_Clear_Decimal(displayB);
20001c9c:	8f84ffc8 	lw	a0,-56(gp)
}
20001ca0:	8fbf0014 	lw	ra,20(sp)
	Segment_Enable(displayA);
	Segment_Write(displayA, 0x0);
	Segment_Clear_Decimal(displayA);
	Segment_Enable(displayB);
	Segment_Write(displayB, 0x0);
	Segment_Clear_Decimal(displayB);
20001ca4:	08000f88 	j	20003e20 <Segment_Clear_Decimal>
20001ca8:	27bd0018 	addiu	sp,sp,24

20001cac <rampDownLeft>:

	visualsLf();
}

uint16_t rampDownLeft(int32_t scriptCount, int32_t currentCount, Bool correction)
{
20001cac:	27bdffe8 	addiu	sp,sp,-24
	double posDelta;
	int16_t speed;
	uint16_t result;

	if(scriptCount > currentCount)
20001cb0:	00a4102a 	slt	v0,a1,a0

	visualsLf();
}

uint16_t rampDownLeft(int32_t scriptCount, int32_t currentCount, Bool correction)
{
20001cb4:	afb00010 	sw	s0,16(sp)
20001cb8:	afbf0014 	sw	ra,20(sp)
	double posDelta;
	int16_t speed;
	uint16_t result;

	if(scriptCount > currentCount)
20001cbc:	10400003 	beqz	v0,20001ccc <rampDownLeft+0x20>
20001cc0:	00c08021 	move	s0,a2
	{
		posDelta = scriptCount - currentCount;
20001cc4:	08000739 	j	20001ce4 <rampDownLeft+0x38>
20001cc8:	00852023 	subu	a0,a0,a1
	}
	else if(scriptCount < currentCount)
20001ccc:	0085102a 	slt	v0,a0,a1
20001cd0:	14400004 	bnez	v0,20001ce4 <rampDownLeft+0x38>
20001cd4:	00a42023 	subu	a0,a1,a0
20001cd8:	00001021 	move	v0,zero
20001cdc:	0800073b 	j	20001cec <rampDownLeft+0x40>
20001ce0:	00001821 	move	v1,zero
	{
		posDelta = currentCount - scriptCount;
20001ce4:	0c00123d 	jal	200048f4 <__floatsidf>
20001ce8:	00000000 	nop
	else
	{
		posDelta = 0.0;
	}

	speed = (RPM_FACTOR * posDelta) + RPM_FLOOR;
20001cec:	8f86ffe4 	lw	a2,-28(gp)
20001cf0:	8f87ffe8 	lw	a3,-24(gp)
20001cf4:	00402021 	move	a0,v0
20001cf8:	0c001154 	jal	20004550 <__muldf3>
20001cfc:	00602821 	move	a1,v1
20001d00:	8f86ffec 	lw	a2,-20(gp)
20001d04:	8f87fff0 	lw	a3,-16(gp)
20001d08:	00402021 	move	a0,v0
20001d0c:	0c001139 	jal	200044e4 <__adddf3>
20001d10:	00602821 	move	a1,v1
20001d14:	00602821 	move	a1,v1
20001d18:	0c001272 	jal	200049c8 <__fixdfsi>
20001d1c:	00402021 	move	a0,v0
20001d20:	00021400 	sll	v0,v0,0x10
20001d24:	00021403 	sra	v0,v0,0x10

	if(speed >= RPM_LIMIT)
20001d28:	28430030 	slti	v1,v0,48
20001d2c:	14600002 	bnez	v1,20001d38 <rampDownLeft+0x8c>
20001d30:	24030001 	li	v1,1
20001d34:	24020030 	li	v0,48
	{
		speed = RPM_LIMIT;
	}

	if(correction == True && speed > CORRECTION_THRESHOLD)
20001d38:	16030008 	bne	s0,v1,20001d5c <rampDownLeft+0xb0>
20001d3c:	2843000c 	slti	v1,v0,12
20001d40:	28430019 	slti	v1,v0,25
20001d44:	14600005 	bnez	v1,20001d5c <rampDownLeft+0xb0>
20001d48:	2843000c 	slti	v1,v0,12
	{
		speed -= CORRECTION_VALUE;
20001d4c:	2442fffc 	addiu	v0,v0,-4
20001d50:	00021400 	sll	v0,v0,0x10
20001d54:	00021403 	sra	v0,v0,0x10
20001d58:	2843000c 	slti	v1,v0,12
20001d5c:	10600002 	beqz	v1,20001d68 <rampDownLeft+0xbc>
20001d60:	00000000 	nop
20001d64:	2402000c 	li	v0,12
		speed = CRAWL_SPEED;
	}

	result = (uint16_t)(speed);
	return result;
}
20001d68:	8fbf0014 	lw	ra,20(sp)
20001d6c:	3042ffff 	andi	v0,v0,0xffff
20001d70:	8fb00010 	lw	s0,16(sp)
20001d74:	03e00008 	jr	ra
20001d78:	27bd0018 	addiu	sp,sp,24

20001d7c <visualsLf>:

void visualsLf(void)
{
	if(System_Mode_G == Game_Over)
20001d7c:	8f8300f8 	lw	v1,248(gp)
	result = (uint16_t)(speed);
	return result;
}

void visualsLf(void)
{
20001d80:	27bdffe8 	addiu	sp,sp,-24
	if(System_Mode_G == Game_Over)
20001d84:	24020004 	li	v0,4
20001d88:	14620009 	bne	v1,v0,20001db0 <visualsLf+0x34>
20001d8c:	afbf0014 	sw	ra,20(sp)
	{
		Segment_Set_Decimal(displayC);
20001d90:	8f84ffdc 	lw	a0,-36(gp)
20001d94:	0c000f76 	jal	20003dd8 <Segment_Set_Decimal>
20001d98:	00000000 	nop
		Segment_Set_Decimal(displayD);
20001d9c:	8f84ffe0 	lw	a0,-32(gp)
20001da0:	0c000f76 	jal	20003dd8 <Segment_Set_Decimal>
20001da4:	00000000 	nop
20001da8:	08000772 	j	20001dc8 <visualsLf+0x4c>
20001dac:	00000000 	nop
	}
	else
	{
		Segment_Clear_Decimal(displayC);
20001db0:	8f84ffdc 	lw	a0,-36(gp)
20001db4:	0c000f88 	jal	20003e20 <Segment_Clear_Decimal>
20001db8:	00000000 	nop
		Segment_Clear_Decimal(displayD);
20001dbc:	8f84ffe0 	lw	a0,-32(gp)
20001dc0:	0c000f88 	jal	20003e20 <Segment_Clear_Decimal>
20001dc4:	00000000 	nop
	}

	if(
		Left_motor_direction_G == Forwards
		&& Left_motor_speed_G != 0
20001dc8:	8f830094 	lw	v1,148(gp)
	{
		Segment_Clear_Decimal(displayC);
		Segment_Clear_Decimal(displayD);
	}

	if(
20001dcc:	24020001 	li	v0,1
20001dd0:	1462000f 	bne	v1,v0,20001e10 <visualsLf+0x94>
20001dd4:	3c028000 	lui	v0,0x8000
20001dd8:	978200b0 	lhu	v0,176(gp)
20001ddc:	00000000 	nop
20001de0:	1040000b 	beqz	v0,20001e10 <visualsLf+0x94>
20001de4:	3c028000 	lui	v0,0x8000
		Left_motor_direction_G == Forwards
		&& Left_motor_speed_G != 0
		)
	{
		GPIO_Write(LED_Pin_LfFd, GPIO_HIGH);
20001de8:	34420200 	ori	v0,v0,0x200
20001dec:	8c430000 	lw	v1,0(v0)
20001df0:	00000000 	nop
20001df4:	ac430000 	sw	v1,0(v0)
20001df8:	8c430000 	lw	v1,0(v0)
20001dfc:	00000000 	nop
20001e00:	34630008 	ori	v1,v1,0x8
20001e04:	ac430000 	sw	v1,0(v0)
	{
		GPIO_Write(LED_Pin_LfBd, GPIO_HIGH);
	}
	else
	{
		GPIO_Write(LED_Pin_LfBd, GPIO_LOW);
20001e08:	0800079a 	j	20001e68 <visualsLf+0xec>
20001e0c:	3c028000 	lui	v0,0x8000
	{
		GPIO_Write(LED_Pin_LfFd, GPIO_HIGH);
	}
	else
	{
		GPIO_Write(LED_Pin_LfFd, GPIO_LOW);
20001e10:	34420200 	ori	v0,v0,0x200
20001e14:	8c450000 	lw	a1,0(v0)
20001e18:	2404fff7 	li	a0,-9
20001e1c:	00a42024 	and	a0,a1,a0
20001e20:	ac440000 	sw	a0,0(v0)
20001e24:	8c440000 	lw	a0,0(v0)
20001e28:	00000000 	nop
20001e2c:	ac440000 	sw	a0,0(v0)
	}

	if(
20001e30:	24040002 	li	a0,2
20001e34:	1464000b 	bne	v1,a0,20001e64 <visualsLf+0xe8>
20001e38:	00000000 	nop
20001e3c:	978300b0 	lhu	v1,176(gp)
20001e40:	00000000 	nop
20001e44:	10600007 	beqz	v1,20001e64 <visualsLf+0xe8>
20001e48:	00000000 	nop
		Left_motor_direction_G == Reverse
		&& Left_motor_speed_G != 0
		)
	{
		GPIO_Write(LED_Pin_LfBd, GPIO_HIGH);
20001e4c:	8c430000 	lw	v1,0(v0)
20001e50:	00000000 	nop
20001e54:	ac430000 	sw	v1,0(v0)
20001e58:	8c430000 	lw	v1,0(v0)
20001e5c:	080007a0 	j	20001e80 <visualsLf+0x104>
20001e60:	34630004 	ori	v1,v1,0x4
	}
	else
	{
		GPIO_Write(LED_Pin_LfBd, GPIO_LOW);
20001e64:	3c028000 	lui	v0,0x8000
20001e68:	34420200 	ori	v0,v0,0x200
20001e6c:	8c440000 	lw	a0,0(v0)
20001e70:	2403fffb 	li	v1,-5
20001e74:	00831824 	and	v1,a0,v1
20001e78:	ac430000 	sw	v1,0(v0)
20001e7c:	8c430000 	lw	v1,0(v0)
	}

	//Segment_Write(displayC, (Motor_Lf_Enc_Track & 0x000F) >> 0);
	//Segment_Write(displayD, (Motor_Lf_Enc_Track & 0x00F0) >> 4);

}
20001e80:	8fbf0014 	lw	ra,20(sp)
	{
		GPIO_Write(LED_Pin_LfBd, GPIO_HIGH);
	}
	else
	{
		GPIO_Write(LED_Pin_LfBd, GPIO_LOW);
20001e84:	ac430000 	sw	v1,0(v0)
	}

	//Segment_Write(displayC, (Motor_Lf_Enc_Track & 0x000F) >> 0);
	//Segment_Write(displayD, (Motor_Lf_Enc_Track & 0x00F0) >> 4);

}
20001e88:	03e00008 	jr	ra
20001e8c:	27bd0018 	addiu	sp,sp,24

20001e90 <Motor_Left_Update>:
 */
void Motor_Left_Update(void)
{
	Bearing moveLf;

	if(System_Mode_G == Go)
20001e90:	8f8300f8 	lw	v1,248(gp)

/**
 * Motor_Left controller operation.
 */
void Motor_Left_Update(void)
{
20001e94:	27bdffe8 	addiu	sp,sp,-24
	Bearing moveLf;

	if(System_Mode_G == Go)
20001e98:	24020002 	li	v0,2
20001e9c:	14620080 	bne	v1,v0,200020a0 <Motor_Left_Update+0x210>
20001ea0:	afbf0014 	sw	ra,20(sp)
	{
		moveLf = Script_G.Movement[Script_no_G];
20001ea4:	938400e0 	lbu	a0,224(gp)
20001ea8:	3c024000 	lui	v0,0x4000
20001eac:	00041880 	sll	v1,a0,0x2
20001eb0:	2442066c 	addiu	v0,v0,1644
20001eb4:	00621021 	addu	v0,v1,v0

		/* Calculate the absolute value of encoder counts since previous update */
		Enc_Lf_Diff = (WheelCounts_Left_G - Enc_Lf_Old);
20001eb8:	8f850088 	lw	a1,136(gp)
{
	Bearing moveLf;

	if(System_Mode_G == Go)
	{
		moveLf = Script_G.Movement[Script_no_G];
20001ebc:	8c430000 	lw	v1,0(v0)

		/* Calculate the absolute value of encoder counts since previous update */
		Enc_Lf_Diff = (WheelCounts_Left_G - Enc_Lf_Old);
20001ec0:	8f82015c 	lw	v0,348(gp)

		/* Encoder counting */
		if(moveLf == Fd || moveLf == Rt)
20001ec4:	24060001 	li	a2,1
	if(System_Mode_G == Go)
	{
		moveLf = Script_G.Movement[Script_no_G];

		/* Calculate the absolute value of encoder counts since previous update */
		Enc_Lf_Diff = (WheelCounts_Left_G - Enc_Lf_Old);
20001ec8:	00a21023 	subu	v0,a1,v0

		/* Encoder counting */
		if(moveLf == Fd || moveLf == Rt)
20001ecc:	10660004 	beq	v1,a2,20001ee0 <Motor_Left_Update+0x50>
20001ed0:	af820158 	sw	v0,344(gp)
20001ed4:	24060004 	li	a2,4
20001ed8:	14660004 	bne	v1,a2,20001eec <Motor_Left_Update+0x5c>
20001edc:	2466fffe 	addiu	a2,v1,-2
		{
			Motor_Lf_Enc_Track += Enc_Lf_Diff;
20001ee0:	8f86003c 	lw	a2,60(gp)
20001ee4:	080007c1 	j	20001f04 <Motor_Left_Update+0x74>
20001ee8:	00c21021 	addu	v0,a2,v0
		}
		else if(moveLf == Bd || moveLf == Lf)
20001eec:	2cc60002 	sltiu	a2,a2,2
20001ef0:	10c00005 	beqz	a2,20001f08 <Motor_Left_Update+0x78>
20001ef4:	00000000 	nop
		{
			Motor_Lf_Enc_Track -= Enc_Lf_Diff;
20001ef8:	8f86003c 	lw	a2,60(gp)
20001efc:	00000000 	nop
20001f00:	00c21023 	subu	v0,a2,v0
20001f04:	af82003c 	sw	v0,60(gp)
		}

		Enc_Lf_Old = WheelCounts_Left_G;

		/* Check to see if the next step in the Script is to be executed */
		if(Script_no_check_Lf != Script_no_G)
20001f08:	93820164 	lbu	v0,356(gp)
20001f0c:	00000000 	nop
20001f10:	10440005 	beq	v0,a0,20001f28 <Motor_Left_Update+0x98>
20001f14:	af85015c 	sw	a1,348(gp)
		{
			Script_no_check_Lf = Script_no_G;
20001f18:	a3840164 	sb	a0,356(gp)
			Motor_Lf_Enc_Track = 0;
20001f1c:	af80003c 	sw	zero,60(gp)
			scriptTimeoutLf = 0;
20001f20:	080007ce 	j	20001f38 <Motor_Left_Update+0xa8>
20001f24:	a7800162 	sh	zero,354(gp)
		}
		else
		{
			Script_no_check_Lf = Script_no_G;
			scriptTimeoutLf++;
20001f28:	97820162 	lhu	v0,354(gp)
			Motor_Lf_Enc_Track = 0;
			scriptTimeoutLf = 0;
		}
		else
		{
			Script_no_check_Lf = Script_no_G;
20001f2c:	a3840164 	sb	a0,356(gp)
			scriptTimeoutLf++;
20001f30:	24420001 	addiu	v0,v0,1
20001f34:	a7820162 	sh	v0,354(gp)
		}

		if(scriptTimeoutLf > 5000)
20001f38:	97820162 	lhu	v0,354(gp)
20001f3c:	00000000 	nop
20001f40:	2c421389 	sltiu	v0,v0,5001
20001f44:	10400051 	beqz	v0,2000208c <Motor_Left_Update+0x1fc>
20001f48:	24020001 	li	v0,1
		{
			moveLf = DeployLf;
		}

		/* Script reader */
		switch(moveLf)
20001f4c:	24020004 	li	v0,4
20001f50:	10620011 	beq	v1,v0,20001f98 <Motor_Left_Update+0x108>
20001f54:	2c620005 	sltiu	v0,v1,5
20001f58:	10400008 	beqz	v0,20001f7c <Motor_Left_Update+0xec>
20001f5c:	2c620007 	sltiu	v0,v1,7
20001f60:	24020001 	li	v0,1
20001f64:	1062000c 	beq	v1,v0,20001f98 <Motor_Left_Update+0x108>
20001f68:	00000000 	nop
20001f6c:	10600049 	beqz	v1,20002094 <Motor_Left_Update+0x204>
20001f70:	24840040 	addiu	a0,a0,64
			}
			break;
		case Bd:
		case Lf:
			if(
					(Motor_Lf_Enc_Track < (Script_G.Enc_counts[Script_no_G] - BUFFER_COUNT))
20001f74:	080007fa 	j	20001fe8 <Motor_Left_Update+0x158>
20001f78:	3c034000 	lui	v1,0x4000
		{
			moveLf = DeployLf;
		}

		/* Script reader */
		switch(moveLf)
20001f7c:	14400043 	bnez	v0,2000208c <Motor_Left_Update+0x1fc>
20001f80:	24020001 	li	v0,1
20001f84:	24020007 	li	v0,7
20001f88:	14620042 	bne	v1,v0,20002094 <Motor_Left_Update+0x204>
20001f8c:	24840040 	addiu	a0,a0,64
			Left_motor_direction_G = Reverse;
			Left_motor_speed_G = BOTTLE_SPEED;
			if(
					//(Motor_Lf_Enc_Track > Script_G.Enc_counts[Script_no_G])
					//||
					(++bottleTimeoutLf > Script_G.Enc_counts[Script_no_G])
20001f90:	08000813 	j	2000204c <Motor_Left_Update+0x1bc>
20001f94:	3c024000 	lui	v0,0x4000
		switch(moveLf)
		{
		case Fd:
		case Rt:
			/* Check the encoder tracker has reached the target count */
			if(Motor_Lf_Enc_Track < (Script_G.Enc_counts[Script_no_G] - BUFFER_COUNT))
20001f98:	24840040 	addiu	a0,a0,64
20001f9c:	3c024000 	lui	v0,0x4000
20001fa0:	2442066c 	addiu	v0,v0,1644
20001fa4:	00042080 	sll	a0,a0,0x2
20001fa8:	00822021 	addu	a0,a0,v0
20001fac:	8c840000 	lw	a0,0(a0)
20001fb0:	8f85003c 	lw	a1,60(gp)
20001fb4:	2482fffe 	addiu	v0,a0,-2
20001fb8:	00a2102a 	slt	v0,a1,v0
20001fbc:	10400004 	beqz	v0,20001fd0 <Motor_Left_Update+0x140>
20001fc0:	24020001 	li	v0,1
			{
				End_Of_MoveLf = False;
				Left_motor_direction_G = Forwards;
				Left_motor_speed_G = rampDownLeft(Script_G.Enc_counts[Script_no_G], Motor_Lf_Enc_Track, Course_correction_Lf);
20001fc4:	8f860074 	lw	a2,116(gp)
				Left_motor_speed_G = rampDownLeft(Script_G.Enc_counts[Script_no_G], Motor_Lf_Enc_Track, Course_correction_Lf);
			}
			else if(Motor_Lf_Enc_Track > (Script_G.Enc_counts[Script_no_G] + BUFFER_COUNT))
			{
				End_Of_MoveLf = False;
				Left_motor_direction_G = Forwards;
20001fc8:	0800080b 	j	2000202c <Motor_Left_Update+0x19c>
20001fcc:	af820094 	sw	v0,148(gp)
				End_Of_MoveLf = False;
				Left_motor_direction_G = Forwards;
				Left_motor_speed_G = rampDownLeft(Script_G.Enc_counts[Script_no_G], Motor_Lf_Enc_Track, Course_correction_Lf);
			}
			/* Check for overshoot */
			else if(Motor_Lf_Enc_Track > (Script_G.Enc_counts[Script_no_G] + BUFFER_COUNT))
20001fd0:	24820002 	addiu	v0,a0,2
20001fd4:	0045102a 	slt	v0,v0,a1
20001fd8:	1440000c 	bnez	v0,2000200c <Motor_Left_Update+0x17c>
20001fdc:	00000000 	nop
				Left_motor_speed_G = rampDownLeft(Script_G.Enc_counts[Script_no_G], Motor_Lf_Enc_Track, Course_correction_Lf);
			}
			/* Stop the motor once the target is reached */
			else
			{
				End_Of_MoveLf = True;
20001fe0:	0800080f 	j	2000203c <Motor_Left_Update+0x1ac>
20001fe4:	24020001 	li	v0,1
			}
			break;
		case Bd:
		case Lf:
			if(
					(Motor_Lf_Enc_Track < (Script_G.Enc_counts[Script_no_G] - BUFFER_COUNT))
20001fe8:	2463066c 	addiu	v1,v1,1644
20001fec:	00042080 	sll	a0,a0,0x2
20001ff0:	00832021 	addu	a0,a0,v1
20001ff4:	8c840000 	lw	a0,0(a0)
20001ff8:	8f85003c 	lw	a1,60(gp)
				bottleTimeoutLf = 0;
			}
			break;
		case Bd:
		case Lf:
			if(
20001ffc:	2483fffe 	addiu	v1,a0,-2
20002000:	00a3182a 	slt	v1,a1,v1
20002004:	10600004 	beqz	v1,20002018 <Motor_Left_Update+0x188>
20002008:	24830002 	addiu	v1,a0,2
					//(GPIO_Get(Left_SW) != GPIO_LOW)
			)
			{
				End_Of_MoveLf = False;
				Left_motor_direction_G = Reverse;
				Left_motor_speed_G = rampDownLeft(Script_G.Enc_counts[Script_no_G], Motor_Lf_Enc_Track, Course_correction_Lf);
2000200c:	8f860074 	lw	a2,116(gp)
					//&&
					//(GPIO_Get(Left_SW) != GPIO_LOW)
			)
			{
				End_Of_MoveLf = False;
				Left_motor_direction_G = Reverse;
20002010:	0800080a 	j	20002028 <Motor_Left_Update+0x198>
20002014:	24020002 	li	v0,2
				Left_motor_speed_G = rampDownLeft(Script_G.Enc_counts[Script_no_G], Motor_Lf_Enc_Track, Course_correction_Lf);
			}
			else if(Motor_Lf_Enc_Track > (Script_G.Enc_counts[Script_no_G] + BUFFER_COUNT))
20002018:	0065182a 	slt	v1,v1,a1
2000201c:	10600007 	beqz	v1,2000203c <Motor_Left_Update+0x1ac>
20002020:	00000000 	nop
			{
				End_Of_MoveLf = False;
				Left_motor_direction_G = Forwards;
				Left_motor_speed_G = rampDownLeft(Script_G.Enc_counts[Script_no_G], Motor_Lf_Enc_Track, Course_correction_Lf);
20002024:	8f860074 	lw	a2,116(gp)
				Left_motor_speed_G = rampDownLeft(Script_G.Enc_counts[Script_no_G], Motor_Lf_Enc_Track, Course_correction_Lf);
			}
			else if(Motor_Lf_Enc_Track > (Script_G.Enc_counts[Script_no_G] + BUFFER_COUNT))
			{
				End_Of_MoveLf = False;
				Left_motor_direction_G = Forwards;
20002028:	af820094 	sw	v0,148(gp)
				Left_motor_speed_G = rampDownLeft(Script_G.Enc_counts[Script_no_G], Motor_Lf_Enc_Track, Course_correction_Lf);
2000202c:	0c00072b 	jal	20001cac <rampDownLeft>
20002030:	af800068 	sw	zero,104(gp)
20002034:	0800082d 	j	200020b4 <Motor_Left_Update+0x224>
20002038:	a78200b0 	sh	v0,176(gp)
			}
			else // TODO: Timeout vs. buffer?
			{
				End_Of_MoveLf = True;
2000203c:	af820068 	sw	v0,104(gp)
				Left_motor_speed_G = 0x0;
20002040:	a78000b0 	sh	zero,176(gp)
				bottleTimeoutLf = 0;
20002044:	0800082d 	j	200020b4 <Motor_Left_Update+0x224>
20002048:	a7800160 	sh	zero,352(gp)
			Left_motor_direction_G = Reverse;
			Left_motor_speed_G = BOTTLE_SPEED;
			if(
					//(Motor_Lf_Enc_Track > Script_G.Enc_counts[Script_no_G])
					//||
					(++bottleTimeoutLf > Script_G.Enc_counts[Script_no_G])
2000204c:	2442066c 	addiu	v0,v0,1644
20002050:	00042080 	sll	a0,a0,0x2
20002054:	00822021 	addu	a0,a0,v0
20002058:	97820160 	lhu	v0,352(gp)
2000205c:	8c830000 	lw	v1,0(a0)
20002060:	24420001 	addiu	v0,v0,1
20002064:	3042ffff 	andi	v0,v0,0xffff
				bottleTimeoutLf = 0;
			}
			break;
		case Press:
			End_Of_MoveLf = False;
			Left_motor_direction_G = Reverse;
20002068:	24040002 	li	a0,2
2000206c:	af840094 	sw	a0,148(gp)
			Left_motor_speed_G = BOTTLE_SPEED;
			if(
					//(Motor_Lf_Enc_Track > Script_G.Enc_counts[Script_no_G])
					//||
					(++bottleTimeoutLf > Script_G.Enc_counts[Script_no_G])
20002070:	0062182a 	slt	v1,v1,v0
			}
			break;
		case Press:
			End_Of_MoveLf = False;
			Left_motor_direction_G = Reverse;
			Left_motor_speed_G = BOTTLE_SPEED;
20002074:	24040018 	li	a0,24
20002078:	a78400b0 	sh	a0,176(gp)
				Left_motor_speed_G = 0x0;
				bottleTimeoutLf = 0;
			}
			break;
		case Press:
			End_Of_MoveLf = False;
2000207c:	af800068 	sw	zero,104(gp)
			Left_motor_direction_G = Reverse;
			Left_motor_speed_G = BOTTLE_SPEED;
			if(
					//(Motor_Lf_Enc_Track > Script_G.Enc_counts[Script_no_G])
					//||
					(++bottleTimeoutLf > Script_G.Enc_counts[Script_no_G])
20002080:	1060000c 	beqz	v1,200020b4 <Motor_Left_Update+0x224>
20002084:	a7820160 	sh	v0,352(gp)
				Left_motor_speed_G = 0x0;
			}
			break;
		case DeployLf:
		case DeployRt:
			End_Of_MoveLf = True;
20002088:	24020001 	li	v0,1
2000208c:	08000826 	j	20002098 <Motor_Left_Update+0x208>
20002090:	af820068 	sw	v0,104(gp)
			Left_motor_speed_G = 0x0;
			break;
		case Stp:
		default:
			End_Of_MoveLf = False;
20002094:	af800068 	sw	zero,104(gp)
			Left_motor_speed_G = 0;
20002098:	0800082d 	j	200020b4 <Motor_Left_Update+0x224>
2000209c:	a78000b0 	sh	zero,176(gp)
			break;
		}
	}
	else
	{
		Left_motor_direction_G = Off;
200020a0:	af800094 	sw	zero,148(gp)
		Left_motor_speed_G = 0;
200020a4:	a78000b0 	sh	zero,176(gp)
		Motor_Lf_Enc_Track = 0;
200020a8:	af80003c 	sw	zero,60(gp)
		Enc_Lf_Diff = 0;
200020ac:	af800158 	sw	zero,344(gp)
		Enc_Lf_Old = 0;
200020b0:	af80015c 	sw	zero,348(gp)
	}

	visualsLf();
}
200020b4:	8fbf0014 	lw	ra,20(sp)
		Motor_Lf_Enc_Track = 0;
		Enc_Lf_Diff = 0;
		Enc_Lf_Old = 0;
	}

	visualsLf();
200020b8:	0800075f 	j	20001d7c <visualsLf>
200020bc:	27bd0018 	addiu	sp,sp,24

200020c0 <Motor_Left_Init>:

	End_Of_MoveLf = False;
	bottleTimeoutLf = 0;
	scriptTimeoutLf = 0;

	GPIO_Set_Direction(LED_Pin_LfFd, GPIO_OUTPUT);
200020c0:	3c038000 	lui	v1,0x8000
200020c4:	34620200 	ori	v0,v1,0x200
200020c8:	8c440004 	lw	a0,4(v0)
200020cc:	2405fff7 	li	a1,-9
200020d0:	00852024 	and	a0,a0,a1
200020d4:	ac440004 	sw	a0,4(v0)
200020d8:	8c440004 	lw	a0,4(v0)
	GPIO_Write(LED_Pin_LfFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_LfBd, GPIO_OUTPUT);
200020dc:	2406fffb 	li	a2,-5

	End_Of_MoveLf = False;
	bottleTimeoutLf = 0;
	scriptTimeoutLf = 0;

	GPIO_Set_Direction(LED_Pin_LfFd, GPIO_OUTPUT);
200020e0:	34840008 	ori	a0,a0,0x8
200020e4:	ac440004 	sw	a0,4(v0)
	GPIO_Write(LED_Pin_LfFd, GPIO_LOW);
200020e8:	8c440000 	lw	a0,0(v0)
	GPIO_Set_Direction(LED_Pin_LfBd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_LfBd, GPIO_LOW);
	GPIO_Set_Direction(Left_SW, GPIO_INPUT);
200020ec:	34630500 	ori	v1,v1,0x500
	End_Of_MoveLf = False;
	bottleTimeoutLf = 0;
	scriptTimeoutLf = 0;

	GPIO_Set_Direction(LED_Pin_LfFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_LfFd, GPIO_LOW);
200020f0:	00852024 	and	a0,a0,a1
200020f4:	ac440000 	sw	a0,0(v0)
200020f8:	8c470000 	lw	a3,0(v0)
	GPIO_Set_Direction(LED_Pin_LfBd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_LfBd, GPIO_LOW);
	GPIO_Set_Direction(Left_SW, GPIO_INPUT);

	Segment_Enable(displayC);
200020fc:	8f84ffdc 	lw	a0,-36(gp)
	End_Of_MoveLf = False;
	bottleTimeoutLf = 0;
	scriptTimeoutLf = 0;

	GPIO_Set_Direction(LED_Pin_LfFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_LfFd, GPIO_LOW);
20002100:	ac470000 	sw	a3,0(v0)
	GPIO_Set_Direction(LED_Pin_LfBd, GPIO_OUTPUT);
20002104:	8c470004 	lw	a3,4(v0)
/**
 * Initialisation for the Motor_Left package.
 * This will be called from Tasks_Init by default.
 */
void Motor_Left_Init(void)
{
20002108:	27bdffe8 	addiu	sp,sp,-24
	bottleTimeoutLf = 0;
	scriptTimeoutLf = 0;

	GPIO_Set_Direction(LED_Pin_LfFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_LfFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_LfBd, GPIO_OUTPUT);
2000210c:	00e63824 	and	a3,a3,a2
20002110:	ac470004 	sw	a3,4(v0)
20002114:	8c470004 	lw	a3,4(v0)
/**
 * Initialisation for the Motor_Left package.
 * This will be called from Tasks_Init by default.
 */
void Motor_Left_Init(void)
{
20002118:	afbf0014 	sw	ra,20(sp)
	bottleTimeoutLf = 0;
	scriptTimeoutLf = 0;

	GPIO_Set_Direction(LED_Pin_LfFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_LfFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_LfBd, GPIO_OUTPUT);
2000211c:	34e70004 	ori	a3,a3,0x4
20002120:	ac470004 	sw	a3,4(v0)
	GPIO_Write(LED_Pin_LfBd, GPIO_LOW);
20002124:	8c470000 	lw	a3,0(v0)
void Motor_Left_Init(void)
{
	/* Task initialisation */
	Left_motor_direction_G = Off;
	Left_motor_speed_G = 0;
	Motor_Lf_Enc_Track = 0;
20002128:	af80003c 	sw	zero,60(gp)
	scriptTimeoutLf = 0;

	GPIO_Set_Direction(LED_Pin_LfFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_LfFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_LfBd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_LfBd, GPIO_LOW);
2000212c:	00e63024 	and	a2,a3,a2
20002130:	ac460000 	sw	a2,0(v0)
20002134:	8c460000 	lw	a2,0(v0)
{
	/* Task initialisation */
	Left_motor_direction_G = Off;
	Left_motor_speed_G = 0;
	Motor_Lf_Enc_Track = 0;
	Script_no_check_Lf = 0;
20002138:	a3800164 	sb	zero,356(gp)
	scriptTimeoutLf = 0;

	GPIO_Set_Direction(LED_Pin_LfFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_LfFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_LfBd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_LfBd, GPIO_LOW);
2000213c:	ac460000 	sw	a2,0(v0)
	GPIO_Set_Direction(Left_SW, GPIO_INPUT);
20002140:	8c620004 	lw	v0,4(v1)
 * This will be called from Tasks_Init by default.
 */
void Motor_Left_Init(void)
{
	/* Task initialisation */
	Left_motor_direction_G = Off;
20002144:	af800094 	sw	zero,148(gp)

	GPIO_Set_Direction(LED_Pin_LfFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_LfFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_LfBd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_LfBd, GPIO_LOW);
	GPIO_Set_Direction(Left_SW, GPIO_INPUT);
20002148:	00452824 	and	a1,v0,a1
2000214c:	ac650004 	sw	a1,4(v1)
20002150:	8c620004 	lw	v0,4(v1)
 */
void Motor_Left_Init(void)
{
	/* Task initialisation */
	Left_motor_direction_G = Off;
	Left_motor_speed_G = 0;
20002154:	a78000b0 	sh	zero,176(gp)

	GPIO_Set_Direction(LED_Pin_LfFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_LfFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_LfBd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_LfBd, GPIO_LOW);
	GPIO_Set_Direction(Left_SW, GPIO_INPUT);
20002158:	ac620004 	sw	v0,4(v1)
	Left_motor_direction_G = Off;
	Left_motor_speed_G = 0;
	Motor_Lf_Enc_Track = 0;
	Script_no_check_Lf = 0;

	End_Of_MoveLf = False;
2000215c:	af800068 	sw	zero,104(gp)
	bottleTimeoutLf = 0;
20002160:	a7800160 	sh	zero,352(gp)
	GPIO_Write(LED_Pin_LfFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_LfBd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_LfBd, GPIO_LOW);
	GPIO_Set_Direction(Left_SW, GPIO_INPUT);

	Segment_Enable(displayC);
20002164:	0c000f4d 	jal	20003d34 <Segment_Enable>
20002168:	a7800162 	sh	zero,354(gp)
	Segment_Write(displayC, 0x0);
2000216c:	8f84ffdc 	lw	a0,-36(gp)
20002170:	0c000f5f 	jal	20003d7c <Segment_Write>
20002174:	00002821 	move	a1,zero
	Segment_Clear_Decimal(displayC);
20002178:	8f84ffdc 	lw	a0,-36(gp)
2000217c:	0c000f88 	jal	20003e20 <Segment_Clear_Decimal>
20002180:	00000000 	nop
	Segment_Enable(displayD);
20002184:	8f84ffe0 	lw	a0,-32(gp)
20002188:	0c000f4d 	jal	20003d34 <Segment_Enable>
2000218c:	00000000 	nop
	Segment_Write(displayD, 0x0);
20002190:	8f84ffe0 	lw	a0,-32(gp)
20002194:	0c000f5f 	jal	20003d7c <Segment_Write>
20002198:	00002821 	move	a1,zero
	Segment_Clear_Decimal(displayD);
2000219c:	8f84ffe0 	lw	a0,-32(gp)
}
200021a0:	8fbf0014 	lw	ra,20(sp)
	Segment_Enable(displayC);
	Segment_Write(displayC, 0x0);
	Segment_Clear_Decimal(displayC);
	Segment_Enable(displayD);
	Segment_Write(displayD, 0x0);
	Segment_Clear_Decimal(displayD);
200021a4:	08000f88 	j	20003e20 <Segment_Clear_Decimal>
200021a8:	27bd0018 	addiu	sp,sp,24

200021ac <spi_receive_CAN>:
	uint32_t Byte_counter, length;// displayID;

	PAD_ID = 0x0;

	/* Pull CS pin low - indicates start of transmission */
	GPIO_Write(CS_PIN, GPIO_LOW);
200021ac:	3c028000 	lui	v0,0x8000
200021b0:	34420600 	ori	v0,v0,0x600
200021b4:	8c460000 	lw	a2,0(v0)
200021b8:	2403ffbf 	li	v1,-65
200021bc:	00c31824 	and	v1,a2,v1
200021c0:	ac430000 	sw	v1,0(v0)
200021c4:	8c430000 	lw	v1,0(v0)
/**
 * Processes received CAN messages
 * @param buffer_ins The SPI buffer receive instruction.
 */
void spi_receive_CAN(uint32_t buffer_ins, Receive_Buffers * buffer)
{
200021c8:	27bdffe0 	addiu	sp,sp,-32

	PAD_ID = 0x0;

	/* Pull CS pin low - indicates start of transmission */
	GPIO_Write(CS_PIN, GPIO_LOW);
	SPI_Swap(SPI0, buffer_ins);
200021cc:	308400ff 	andi	a0,a0,0xff
	uint32_t Byte_counter, length;// displayID;

	PAD_ID = 0x0;

	/* Pull CS pin low - indicates start of transmission */
	GPIO_Write(CS_PIN, GPIO_LOW);
200021d0:	ac430000 	sw	v1,0(v0)
/**
 * Processes received CAN messages
 * @param buffer_ins The SPI buffer receive instruction.
 */
void spi_receive_CAN(uint32_t buffer_ins, Receive_Buffers * buffer)
{
200021d4:	afb20018 	sw	s2,24(sp)
200021d8:	00a09021 	move	s2,a1

	PAD_ID = 0x0;

	/* Pull CS pin low - indicates start of transmission */
	GPIO_Write(CS_PIN, GPIO_LOW);
	SPI_Swap(SPI0, buffer_ins);
200021dc:	00802821 	move	a1,a0
200021e0:	00002021 	move	a0,zero
/**
 * Processes received CAN messages
 * @param buffer_ins The SPI buffer receive instruction.
 */
void spi_receive_CAN(uint32_t buffer_ins, Receive_Buffers * buffer)
{
200021e4:	afbf001c 	sw	ra,28(sp)
200021e8:	afb10014 	sw	s1,20(sp)
200021ec:	afb00010 	sw	s0,16(sp)

	PAD_ID = 0x0;

	/* Pull CS pin low - indicates start of transmission */
	GPIO_Write(CS_PIN, GPIO_LOW);
	SPI_Swap(SPI0, buffer_ins);
200021f0:	0c000f39 	jal	20003ce4 <SPI_Swap>
200021f4:	af80018c 	sw	zero,396(gp)

	/* Burn 5 Bytes: EXT_ID and Length */
	SPI_Swap(SPI0, 0xFF);
200021f8:	00002021 	move	a0,zero
200021fc:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002200:	240500ff 	li	a1,255
	SPI_Swap(SPI0, 0xFF);
20002204:	00002021 	move	a0,zero
20002208:	0c000f39 	jal	20003ce4 <SPI_Swap>
2000220c:	240500ff 	li	a1,255
	SPI_Swap(SPI0, 0xFF);
20002210:	00002021 	move	a0,zero
20002214:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002218:	240500ff 	li	a1,255
	SPI_Swap(SPI0, 0xFF);
2000221c:	00002021 	move	a0,zero
20002220:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002224:	240500ff 	li	a1,255
	SPI_Swap(SPI0, 0xFF);
20002228:	00002021 	move	a0,zero
2000222c:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002230:	240500ff 	li	a1,255
20002234:	00008021 	move	s0,zero

	/* Known length */
	length = 8;

	/* Extract the CAN data and insert into the Receive Buffer */
	for (Byte_counter = 0; Byte_counter < length; Byte_counter++)
20002238:	24110008 	li	s1,8
	{
		buffer->CAN_Data[Byte_counter] = SPI_Swap(SPI0, 0xFF);
2000223c:	00002021 	move	a0,zero
20002240:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002244:	240500ff 	li	a1,255
20002248:	02501821 	addu	v1,s2,s0

	/* Known length */
	length = 8;

	/* Extract the CAN data and insert into the Receive Buffer */
	for (Byte_counter = 0; Byte_counter < length; Byte_counter++)
2000224c:	26100001 	addiu	s0,s0,1
20002250:	1611fffa 	bne	s0,s1,2000223c <spi_receive_CAN+0x90>
20002254:	a0620008 	sb	v0,8(v1)
	{
		buffer->CAN_Data[Byte_counter] = SPI_Swap(SPI0, 0xFF);
	}

	GPIO_Write(CS_PIN, GPIO_HIGH);
20002258:	3c028000 	lui	v0,0x8000
2000225c:	34420600 	ori	v0,v0,0x600
20002260:	8c430000 	lw	v1,0(v0)
}
20002264:	8fbf001c 	lw	ra,28(sp)
	for (Byte_counter = 0; Byte_counter < length; Byte_counter++)
	{
		buffer->CAN_Data[Byte_counter] = SPI_Swap(SPI0, 0xFF);
	}

	GPIO_Write(CS_PIN, GPIO_HIGH);
20002268:	ac430000 	sw	v1,0(v0)
2000226c:	8c430000 	lw	v1,0(v0)
}
20002270:	8fb20018 	lw	s2,24(sp)
	for (Byte_counter = 0; Byte_counter < length; Byte_counter++)
	{
		buffer->CAN_Data[Byte_counter] = SPI_Swap(SPI0, 0xFF);
	}

	GPIO_Write(CS_PIN, GPIO_HIGH);
20002274:	34630040 	ori	v1,v1,0x40
}
20002278:	8fb10014 	lw	s1,20(sp)
2000227c:	8fb00010 	lw	s0,16(sp)
	for (Byte_counter = 0; Byte_counter < length; Byte_counter++)
	{
		buffer->CAN_Data[Byte_counter] = SPI_Swap(SPI0, 0xFF);
	}

	GPIO_Write(CS_PIN, GPIO_HIGH);
20002280:	ac430000 	sw	v1,0(v0)
}
20002284:	03e00008 	jr	ra
20002288:	27bd0020 	addiu	sp,sp,32

2000228c <spi_buffer_CAN>:

	/* Separate Extended ID portion */
	EID = MaskedID & 0x3FFFF;

	/* Combine Standard ID, 3 padding bits and Extended ID */
	PAD_ID = ((SID | 0x80000) | EID);
2000228c:	3c020003 	lui	v0,0x3

	/* Mask 4 bytes of CAN ID */
	MaskedID = CAN_ID & 0xFFFFFFFF;

	/* Separate Standard ID portion and shift for extra 3 bits */
	SID = MaskedID & 0x1FFC0000;
20002290:	3c031ffc 	lui	v1,0x1ffc

	/* Separate Extended ID portion */
	EID = MaskedID & 0x3FFFF;

	/* Combine Standard ID, 3 padding bits and Extended ID */
	PAD_ID = ((SID | 0x80000) | EID);
20002294:	3442ffff 	ori	v0,v0,0xffff
20002298:	00821024 	and	v0,a0,v0

	/* Mask 4 bytes of CAN ID */
	MaskedID = CAN_ID & 0xFFFFFFFF;

	/* Separate Standard ID portion and shift for extra 3 bits */
	SID = MaskedID & 0x1FFC0000;
2000229c:	00832024 	and	a0,a0,v1

	/* Separate Extended ID portion */
	EID = MaskedID & 0x3FFFF;

	/* Combine Standard ID, 3 padding bits and Extended ID */
	PAD_ID = ((SID | 0x80000) | EID);
200022a0:	3c030008 	lui	v1,0x8
 * @param EXT_ID Transmission ID for the CAN message.
 * @param length The size of the CAN data message.
 * @param Data_array The CAN data.
 */
void spi_buffer_CAN(uint32_t EXT_ID, uint8_t length, uint8_t Data_array[])
{
200022a4:	27bdffd8 	addiu	sp,sp,-40

	/* Separate Extended ID portion */
	EID = MaskedID & 0x3FFFF;

	/* Combine Standard ID, 3 padding bits and Extended ID */
	PAD_ID = ((SID | 0x80000) | EID);
200022a8:	00431025 	or	v0,v0,v1
200022ac:	000420c0 	sll	a0,a0,0x3
200022b0:	00442025 	or	a0,v0,a0
 * @param EXT_ID Transmission ID for the CAN message.
 * @param length The size of the CAN data message.
 * @param Data_array The CAN data.
 */
void spi_buffer_CAN(uint32_t EXT_ID, uint8_t length, uint8_t Data_array[])
{
200022b4:	afb10018 	sw	s1,24(sp)
200022b8:	30b100ff 	andi	s1,a1,0xff
200022bc:	afb00014 	sw	s0,20(sp)
	PAD_ID = ((SID | 0x80000) | EID);

	/* Write to byte array */
	for(Byte = 3; Byte >= 0; Byte--)
	{
		ID_Array[Byte] = (PAD_ID & 0xFF);
200022c0:	00041e02 	srl	v1,a0,0x18
		PAD_ID >>= 8;
200022c4:	00043a02 	srl	a3,a0,0x8
200022c8:	00042c02 	srl	a1,a0,0x10
	}

	/* add data length to byte array */
	ID_Array[4] = (DL & 0x0F);
200022cc:	3222000f 	andi	v0,s1,0xf
200022d0:	27900170 	addiu	s0,gp,368
 * @param EXT_ID Transmission ID for the CAN message.
 * @param length The size of the CAN data message.
 * @param Data_array The CAN data.
 */
void spi_buffer_CAN(uint32_t EXT_ID, uint8_t length, uint8_t Data_array[])
{
200022d4:	afb30020 	sw	s3,32(sp)
200022d8:	afb2001c 	sw	s2,28(sp)
200022dc:	afbf0024 	sw	ra,36(sp)
	PAD_ID = ((SID | 0x80000) | EID);

	/* Write to byte array */
	for(Byte = 3; Byte >= 0; Byte--)
	{
		ID_Array[Byte] = (PAD_ID & 0xFF);
200022e0:	a3870172 	sb	a3,370(gp)
200022e4:	a3850171 	sb	a1,369(gp)
200022e8:	a3830170 	sb	v1,368(gp)
		PAD_ID >>= 8;
	}

	/* add data length to byte array */
	ID_Array[4] = (DL & 0x0F);
200022ec:	a3820174 	sb	v0,372(gp)
 * @param EXT_ID Transmission ID for the CAN message.
 * @param length The size of the CAN data message.
 * @param Data_array The CAN data.
 */
void spi_buffer_CAN(uint32_t EXT_ID, uint8_t length, uint8_t Data_array[])
{
200022f0:	00c09021 	move	s2,a2
	PAD_ID = ((SID | 0x80000) | EID);

	/* Write to byte array */
	for(Byte = 3; Byte >= 0; Byte--)
	{
		ID_Array[Byte] = (PAD_ID & 0xFF);
200022f4:	a3840173 	sb	a0,371(gp)
 * Send CAN message into SPI buffer
 * @param EXT_ID Transmission ID for the CAN message.
 * @param length The size of the CAN data message.
 * @param Data_array The CAN data.
 */
void spi_buffer_CAN(uint32_t EXT_ID, uint8_t length, uint8_t Data_array[])
200022f8:	26130005 	addiu	s3,s0,5
	build_EXT_ID_bytes(EXT_ID, EXT_ID_Bytes, length);

	/* Send padded CAN ID */
	for (Byte_counter = 0; Byte_counter < 5; Byte_counter++)
	{
		SPI_Swap(SPI0, EXT_ID_Bytes[Byte_counter]);
200022fc:	92050000 	lbu	a1,0(s0)
20002300:	00002021 	move	a0,zero
20002304:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002308:	26100001 	addiu	s0,s0,1

	/* Pad ID with LOAD_TX0_INS info (see MCP2515 datasheet) */
	build_EXT_ID_bytes(EXT_ID, EXT_ID_Bytes, length);

	/* Send padded CAN ID */
	for (Byte_counter = 0; Byte_counter < 5; Byte_counter++)
2000230c:	1613fffb 	bne	s0,s3,200022fc <spi_buffer_CAN+0x70>
20002310:	00000000 	nop
20002314:	080008ca 	j	20002328 <spi_buffer_CAN+0x9c>
20002318:	00008021 	move	s0,zero
	}

	/* Send CAN Data */
	for (Byte_counter = 0; Byte_counter < length; Byte_counter++)
	{
		SPI_Swap(SPI0, Data_array[Byte_counter]);
2000231c:	90650000 	lbu	a1,0(v1)
20002320:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002324:	26100001 	addiu	s0,s0,1
	{
		SPI_Swap(SPI0, EXT_ID_Bytes[Byte_counter]);
	}

	/* Send CAN Data */
	for (Byte_counter = 0; Byte_counter < length; Byte_counter++)
20002328:	0211102b 	sltu	v0,s0,s1
	{
		SPI_Swap(SPI0, Data_array[Byte_counter]);
2000232c:	02501821 	addu	v1,s2,s0
	{
		SPI_Swap(SPI0, EXT_ID_Bytes[Byte_counter]);
	}

	/* Send CAN Data */
	for (Byte_counter = 0; Byte_counter < length; Byte_counter++)
20002330:	1440fffa 	bnez	v0,2000231c <spi_buffer_CAN+0x90>
20002334:	00002021 	move	a0,zero
	{
		SPI_Swap(SPI0, Data_array[Byte_counter]);
	}
}
20002338:	8fbf0024 	lw	ra,36(sp)
2000233c:	8fb30020 	lw	s3,32(sp)
20002340:	8fb2001c 	lw	s2,28(sp)
20002344:	8fb10018 	lw	s1,24(sp)
20002348:	8fb00014 	lw	s0,20(sp)
2000234c:	03e00008 	jr	ra
20002350:	27bd0028 	addiu	sp,sp,40

20002354 <Message_Sender_Update>:
 * Specifies messages to send by SPI
 */
void Message_Sender_Update(void)
{
	/* Test values */
	ticked++;
20002354:	97830198 	lhu	v1,408(gp)
	if(ticked % 4000 == 0)
20002358:	24020fa0 	li	v0,4000
 * Specifies messages to send by SPI
 */
void Message_Sender_Update(void)
{
	/* Test values */
	ticked++;
2000235c:	24630001 	addiu	v1,v1,1
20002360:	3063ffff 	andi	v1,v1,0xffff
	if(ticked % 4000 == 0)
20002364:	14400002 	bnez	v0,20002370 <Message_Sender_Update+0x1c>
20002368:	0062001b 	divu	zero,v1,v0
2000236c:	0007000d 	break	0x7

/**
 * Specifies messages to send by SPI
 */
void Message_Sender_Update(void)
{
20002370:	27bdffe0 	addiu	sp,sp,-32
20002374:	afbf001c 	sw	ra,28(sp)
20002378:	afb10018 	sw	s1,24(sp)
2000237c:	afb00014 	sw	s0,20(sp)
	/* Test values */
	ticked++;
	if(ticked % 4000 == 0)
20002380:	00002010 	mfhi	a0
20002384:	14800003 	bnez	a0,20002394 <Message_Sender_Update+0x40>
20002388:	a7830198 	sh	v1,408(gp)
	{
		servo[0] = 0x20;
2000238c:	080008ec 	j	200023b0 <Message_Sender_Update+0x5c>
20002390:	24020020 	li	v0,32
		servo[1] = 0x20;
	}
	else if ((ticked + 2000) % 4000 == 0)
20002394:	246307d0 	addiu	v1,v1,2000
20002398:	14400002 	bnez	v0,200023a4 <Message_Sender_Update+0x50>
2000239c:	0062001a 	div	zero,v1,v0
200023a0:	0007000d 	break	0x7
200023a4:	00001010 	mfhi	v0
200023a8:	14400003 	bnez	v0,200023b8 <Message_Sender_Update+0x64>
200023ac:	2402ffa0 	li	v0,-96
	{
		servo[0] = 0xA0;
		servo[1] = 0xA0;
200023b0:	a38200a9 	sb	v0,169(gp)
		servo[0] = 0x20;
		servo[1] = 0x20;
	}
	else if ((ticked + 2000) % 4000 == 0)
	{
		servo[0] = 0xA0;
200023b4:	a38200a8 	sb	v0,168(gp)
		servo[1] = 0xA0;
	}

	/* First Update ensures the CONFIG values are correct */
	if(init == False)
200023b8:	8f820178 	lw	v0,376(gp)
200023bc:	00000000 	nop
200023c0:	1440011e 	bnez	v0,2000283c <Message_Sender_Update+0x4e8>
200023c4:	3c108000 	lui	s0,0x8000
	{
		/* Soft Reset */
		GPIO_Write(CS_PIN, GPIO_LOW);
200023c8:	36100600 	ori	s0,s0,0x600
200023cc:	8e020000 	lw	v0,0(s0)
200023d0:	2411ffbf 	li	s1,-65
200023d4:	00511024 	and	v0,v0,s1
200023d8:	ae020000 	sw	v0,0(s0)
200023dc:	8e020000 	lw	v0,0(s0)
		SPI_Swap(SPI0, 0xC0);
200023e0:	00002021 	move	a0,zero
200023e4:	240500c0 	li	a1,192

	/* First Update ensures the CONFIG values are correct */
	if(init == False)
	{
		/* Soft Reset */
		GPIO_Write(CS_PIN, GPIO_LOW);
200023e8:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, 0xC0);
200023ec:	0c000f39 	jal	20003ce4 <SPI_Swap>
200023f0:	00000000 	nop
		GPIO_Write(CS_PIN, GPIO_HIGH);
200023f4:	8e020000 	lw	v0,0(s0)

		/* Set into CONFIG mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
200023f8:	00002021 	move	a0,zero
	if(init == False)
	{
		/* Soft Reset */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0xC0);
		GPIO_Write(CS_PIN, GPIO_HIGH);
200023fc:	ae020000 	sw	v0,0(s0)
20002400:	8e020000 	lw	v0,0(s0)

		/* Set into CONFIG mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
20002404:	24050002 	li	a1,2
	if(init == False)
	{
		/* Soft Reset */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0xC0);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20002408:	34420040 	ori	v0,v0,0x40
2000240c:	ae020000 	sw	v0,0(s0)

		/* Set into CONFIG mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
20002410:	8e020000 	lw	v0,0(s0)
20002414:	00000000 	nop
20002418:	00511024 	and	v0,v0,s1
2000241c:	ae020000 	sw	v0,0(s0)
20002420:	8e020000 	lw	v0,0(s0)
20002424:	00000000 	nop
20002428:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, 0x02);
2000242c:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002430:	00000000 	nop
		SPI_Swap(SPI0, 0x0F);
20002434:	00002021 	move	a0,zero
20002438:	0c000f39 	jal	20003ce4 <SPI_Swap>
2000243c:	2405000f 	li	a1,15
		SPI_Swap(SPI0, 0x80);
20002440:	00002021 	move	a0,zero
20002444:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002448:	24050080 	li	a1,128
		GPIO_Write(CS_PIN, GPIO_HIGH);
2000244c:	8e020000 	lw	v0,0(s0)

		/* Verify CONFIG mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x03);
20002450:	00002021 	move	a0,zero
		/* Set into CONFIG mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x0F);
		SPI_Swap(SPI0, 0x80);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20002454:	ae020000 	sw	v0,0(s0)
20002458:	8e020000 	lw	v0,0(s0)

		/* Verify CONFIG mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x03);
2000245c:	24050003 	li	a1,3
		/* Set into CONFIG mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x0F);
		SPI_Swap(SPI0, 0x80);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20002460:	34420040 	ori	v0,v0,0x40
20002464:	ae020000 	sw	v0,0(s0)

		/* Verify CONFIG mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
20002468:	8e020000 	lw	v0,0(s0)
2000246c:	00000000 	nop
20002470:	00511024 	and	v0,v0,s1
20002474:	ae020000 	sw	v0,0(s0)
20002478:	8e020000 	lw	v0,0(s0)
2000247c:	00000000 	nop
20002480:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, 0x03);
20002484:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002488:	00000000 	nop
		SPI_Swap(SPI0, 0x0E);
2000248c:	00002021 	move	a0,zero
20002490:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002494:	2405000e 	li	a1,14
		GPIO_Write(CS_PIN, GPIO_HIGH);
20002498:	8e020000 	lw	v0,0(s0)

		/* Set values in the CONFIG registers for 250 kbps CAN */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
2000249c:	00002021 	move	a0,zero

		/* Verify CONFIG mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x03);
		SPI_Swap(SPI0, 0x0E);
		GPIO_Write(CS_PIN, GPIO_HIGH);
200024a0:	ae020000 	sw	v0,0(s0)
200024a4:	8e020000 	lw	v0,0(s0)

		/* Set values in the CONFIG registers for 250 kbps CAN */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
200024a8:	24050002 	li	a1,2

		/* Verify CONFIG mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x03);
		SPI_Swap(SPI0, 0x0E);
		GPIO_Write(CS_PIN, GPIO_HIGH);
200024ac:	34420040 	ori	v0,v0,0x40
200024b0:	ae020000 	sw	v0,0(s0)

		/* Set values in the CONFIG registers for 250 kbps CAN */
		GPIO_Write(CS_PIN, GPIO_LOW);
200024b4:	8e020000 	lw	v0,0(s0)
200024b8:	00000000 	nop
200024bc:	00511024 	and	v0,v0,s1
200024c0:	ae020000 	sw	v0,0(s0)
200024c4:	8e020000 	lw	v0,0(s0)
200024c8:	00000000 	nop
200024cc:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, 0x02);
200024d0:	0c000f39 	jal	20003ce4 <SPI_Swap>
200024d4:	00000000 	nop
		SPI_Swap(SPI0, 0x28);
200024d8:	00002021 	move	a0,zero
200024dc:	0c000f39 	jal	20003ce4 <SPI_Swap>
200024e0:	24050028 	li	a1,40
		SPI_Swap(SPI0, 0x02);
200024e4:	00002021 	move	a0,zero
200024e8:	0c000f39 	jal	20003ce4 <SPI_Swap>
200024ec:	24050002 	li	a1,2
		SPI_Swap(SPI0, 0x90);
200024f0:	00002021 	move	a0,zero
200024f4:	0c000f39 	jal	20003ce4 <SPI_Swap>
200024f8:	24050090 	li	a1,144
		SPI_Swap(SPI0, 0x03);
200024fc:	00002021 	move	a0,zero
20002500:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002504:	24050003 	li	a1,3
		SPI_Swap(SPI0, 0x00);
20002508:	00002021 	move	a0,zero
2000250c:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002510:	00002821 	move	a1,zero
		GPIO_Write(CS_PIN, GPIO_HIGH);
20002514:	8e020000 	lw	v0,0(s0)

		/* Verify set values */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x03);
20002518:	00002021 	move	a0,zero
		SPI_Swap(SPI0, 0x28);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x90);
		SPI_Swap(SPI0, 0x03);
		SPI_Swap(SPI0, 0x00);
		GPIO_Write(CS_PIN, GPIO_HIGH);
2000251c:	ae020000 	sw	v0,0(s0)
20002520:	8e020000 	lw	v0,0(s0)

		/* Verify set values */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x03);
20002524:	24050003 	li	a1,3
		SPI_Swap(SPI0, 0x28);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x90);
		SPI_Swap(SPI0, 0x03);
		SPI_Swap(SPI0, 0x00);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20002528:	34420040 	ori	v0,v0,0x40
2000252c:	ae020000 	sw	v0,0(s0)

		/* Verify set values */
		GPIO_Write(CS_PIN, GPIO_LOW);
20002530:	8e020000 	lw	v0,0(s0)
20002534:	00000000 	nop
20002538:	00511024 	and	v0,v0,s1
2000253c:	ae020000 	sw	v0,0(s0)
20002540:	8e020000 	lw	v0,0(s0)
20002544:	00000000 	nop
20002548:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, 0x03);
2000254c:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002550:	00000000 	nop
		SPI_Swap(SPI0, 0x2A);
20002554:	00002021 	move	a0,zero
20002558:	0c000f39 	jal	20003ce4 <SPI_Swap>
2000255c:	2405002a 	li	a1,42
		speedPin = SPI_Swap(SPI0, 0xFF);
20002560:	00002021 	move	a0,zero
20002564:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002568:	240500ff 	li	a1,255
		GPIO_Write(CS_PIN, GPIO_HIGH);
2000256c:	8e030000 	lw	v1,0(s0)

		/* BFPCTRL register cleared */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
20002570:	00002021 	move	a0,zero
		/* Verify set values */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x03);
		SPI_Swap(SPI0, 0x2A);
		speedPin = SPI_Swap(SPI0, 0xFF);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20002574:	ae030000 	sw	v1,0(s0)
20002578:	8e030000 	lw	v1,0(s0)

		/* BFPCTRL register cleared */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
2000257c:	24050002 	li	a1,2
		/* Verify set values */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x03);
		SPI_Swap(SPI0, 0x2A);
		speedPin = SPI_Swap(SPI0, 0xFF);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20002580:	34630040 	ori	v1,v1,0x40
20002584:	ae030000 	sw	v1,0(s0)

		/* BFPCTRL register cleared */
		GPIO_Write(CS_PIN, GPIO_LOW);
20002588:	8e030000 	lw	v1,0(s0)

		/* Verify set values */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x03);
		SPI_Swap(SPI0, 0x2A);
		speedPin = SPI_Swap(SPI0, 0xFF);
2000258c:	a3820175 	sb	v0,373(gp)
		GPIO_Write(CS_PIN, GPIO_HIGH);

		/* BFPCTRL register cleared */
		GPIO_Write(CS_PIN, GPIO_LOW);
20002590:	00711824 	and	v1,v1,s1
20002594:	ae030000 	sw	v1,0(s0)
20002598:	8e020000 	lw	v0,0(s0)
2000259c:	00000000 	nop
200025a0:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, 0x02);
200025a4:	0c000f39 	jal	20003ce4 <SPI_Swap>
200025a8:	00000000 	nop
		SPI_Swap(SPI0, 0x0C);
200025ac:	00002021 	move	a0,zero
200025b0:	0c000f39 	jal	20003ce4 <SPI_Swap>
200025b4:	2405000c 	li	a1,12
		SPI_Swap(SPI0, 0x00);
200025b8:	00002021 	move	a0,zero
200025bc:	0c000f39 	jal	20003ce4 <SPI_Swap>
200025c0:	00002821 	move	a1,zero
		GPIO_Write(CS_PIN, GPIO_HIGH);
200025c4:	8e020000 	lw	v0,0(s0)

		/* TXRTSCTRL register cleared */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
200025c8:	00002021 	move	a0,zero
		/* BFPCTRL register cleared */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x0C);
		SPI_Swap(SPI0, 0x00);
		GPIO_Write(CS_PIN, GPIO_HIGH);
200025cc:	ae020000 	sw	v0,0(s0)
200025d0:	8e020000 	lw	v0,0(s0)

		/* TXRTSCTRL register cleared */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
200025d4:	24050002 	li	a1,2
		/* BFPCTRL register cleared */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x0C);
		SPI_Swap(SPI0, 0x00);
		GPIO_Write(CS_PIN, GPIO_HIGH);
200025d8:	34420040 	ori	v0,v0,0x40
200025dc:	ae020000 	sw	v0,0(s0)

		/* TXRTSCTRL register cleared */
		GPIO_Write(CS_PIN, GPIO_LOW);
200025e0:	8e020000 	lw	v0,0(s0)
200025e4:	00000000 	nop
200025e8:	00511024 	and	v0,v0,s1
200025ec:	ae020000 	sw	v0,0(s0)
200025f0:	8e020000 	lw	v0,0(s0)
200025f4:	00000000 	nop
200025f8:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, 0x02);
200025fc:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002600:	00000000 	nop
		SPI_Swap(SPI0, 0x0D);
20002604:	00002021 	move	a0,zero
20002608:	0c000f39 	jal	20003ce4 <SPI_Swap>
2000260c:	2405000d 	li	a1,13
		SPI_Swap(SPI0, 0x00);
20002610:	00002021 	move	a0,zero
20002614:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002618:	00002821 	move	a1,zero
		GPIO_Write(CS_PIN, GPIO_HIGH);
2000261c:	8e020000 	lw	v0,0(s0)

		/* RXB0CTRL */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
20002620:	00002021 	move	a0,zero
		/* TXRTSCTRL register cleared */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x0D);
		SPI_Swap(SPI0, 0x00);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20002624:	ae020000 	sw	v0,0(s0)
20002628:	8e020000 	lw	v0,0(s0)

		/* RXB0CTRL */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
2000262c:	24050002 	li	a1,2
		/* TXRTSCTRL register cleared */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x0D);
		SPI_Swap(SPI0, 0x00);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20002630:	34420040 	ori	v0,v0,0x40
20002634:	ae020000 	sw	v0,0(s0)

		/* RXB0CTRL */
		GPIO_Write(CS_PIN, GPIO_LOW);
20002638:	8e020000 	lw	v0,0(s0)
2000263c:	00000000 	nop
20002640:	00511024 	and	v0,v0,s1
20002644:	ae020000 	sw	v0,0(s0)
20002648:	8e020000 	lw	v0,0(s0)
2000264c:	00000000 	nop
20002650:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, 0x02);
20002654:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002658:	00000000 	nop
		SPI_Swap(SPI0, 0x60);
2000265c:	00002021 	move	a0,zero
20002660:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002664:	24050060 	li	a1,96
		SPI_Swap(SPI0, 0x60);
20002668:	00002021 	move	a0,zero
2000266c:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002670:	24050060 	li	a1,96
		GPIO_Write(CS_PIN, GPIO_HIGH);
20002674:	8e020000 	lw	v0,0(s0)

		/* RXB1CTRL */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
20002678:	00002021 	move	a0,zero
		/* RXB0CTRL */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x60);
		SPI_Swap(SPI0, 0x60);
		GPIO_Write(CS_PIN, GPIO_HIGH);
2000267c:	ae020000 	sw	v0,0(s0)
20002680:	8e020000 	lw	v0,0(s0)

		/* RXB1CTRL */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
20002684:	24050002 	li	a1,2
		/* RXB0CTRL */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x60);
		SPI_Swap(SPI0, 0x60);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20002688:	34420040 	ori	v0,v0,0x40
2000268c:	ae020000 	sw	v0,0(s0)

		/* RXB1CTRL */
		GPIO_Write(CS_PIN, GPIO_LOW);
20002690:	8e020000 	lw	v0,0(s0)
20002694:	00000000 	nop
20002698:	00511024 	and	v0,v0,s1
2000269c:	ae020000 	sw	v0,0(s0)
200026a0:	8e020000 	lw	v0,0(s0)
200026a4:	00000000 	nop
200026a8:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, 0x02);
200026ac:	0c000f39 	jal	20003ce4 <SPI_Swap>
200026b0:	00000000 	nop
		SPI_Swap(SPI0, 0x70);
200026b4:	00002021 	move	a0,zero
200026b8:	0c000f39 	jal	20003ce4 <SPI_Swap>
200026bc:	24050070 	li	a1,112
		SPI_Swap(SPI0, 0x60);
200026c0:	00002021 	move	a0,zero
200026c4:	0c000f39 	jal	20003ce4 <SPI_Swap>
200026c8:	24050060 	li	a1,96
		GPIO_Write(CS_PIN, GPIO_HIGH);
200026cc:	8e020000 	lw	v0,0(s0)

		/* Filter for impossible CAN ID */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
200026d0:	00002021 	move	a0,zero
		/* RXB1CTRL */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x70);
		SPI_Swap(SPI0, 0x60);
		GPIO_Write(CS_PIN, GPIO_HIGH);
200026d4:	ae020000 	sw	v0,0(s0)
200026d8:	8e020000 	lw	v0,0(s0)

		/* Filter for impossible CAN ID */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
200026dc:	24050002 	li	a1,2
		/* RXB1CTRL */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x70);
		SPI_Swap(SPI0, 0x60);
		GPIO_Write(CS_PIN, GPIO_HIGH);
200026e0:	34420040 	ori	v0,v0,0x40
200026e4:	ae020000 	sw	v0,0(s0)

		/* Filter for impossible CAN ID */
		GPIO_Write(CS_PIN, GPIO_LOW);
200026e8:	8e020000 	lw	v0,0(s0)
200026ec:	00000000 	nop
200026f0:	00511024 	and	v0,v0,s1
200026f4:	ae020000 	sw	v0,0(s0)
200026f8:	8e020000 	lw	v0,0(s0)
200026fc:	00000000 	nop
20002700:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, 0x02);
20002704:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002708:	00000000 	nop
		SPI_Swap(SPI0, 0x08);
2000270c:	00002021 	move	a0,zero
20002710:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002714:	24050008 	li	a1,8
		SPI_Swap(SPI0, 0x3F);
20002718:	00002021 	move	a0,zero
2000271c:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002720:	2405003f 	li	a1,63
		SPI_Swap(SPI0, 0x0F);
20002724:	00002021 	move	a0,zero
20002728:	0c000f39 	jal	20003ce4 <SPI_Swap>
2000272c:	2405000f 	li	a1,15
		SPI_Swap(SPI0, 0xFF);
20002730:	00002021 	move	a0,zero
20002734:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002738:	240500ff 	li	a1,255
		SPI_Swap(SPI0, 0xFF);
2000273c:	00002021 	move	a0,zero
20002740:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002744:	240500ff 	li	a1,255
		GPIO_Write(CS_PIN, GPIO_HIGH);
20002748:	8e020000 	lw	v0,0(s0)

		/* Mask for impossible CAN ID */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
2000274c:	00002021 	move	a0,zero
		SPI_Swap(SPI0, 0x08);
		SPI_Swap(SPI0, 0x3F);
		SPI_Swap(SPI0, 0x0F);
		SPI_Swap(SPI0, 0xFF);
		SPI_Swap(SPI0, 0xFF);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20002750:	ae020000 	sw	v0,0(s0)
20002754:	8e020000 	lw	v0,0(s0)

		/* Mask for impossible CAN ID */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
20002758:	24050002 	li	a1,2
		SPI_Swap(SPI0, 0x08);
		SPI_Swap(SPI0, 0x3F);
		SPI_Swap(SPI0, 0x0F);
		SPI_Swap(SPI0, 0xFF);
		SPI_Swap(SPI0, 0xFF);
		GPIO_Write(CS_PIN, GPIO_HIGH);
2000275c:	34420040 	ori	v0,v0,0x40
20002760:	ae020000 	sw	v0,0(s0)

		/* Mask for impossible CAN ID */
		GPIO_Write(CS_PIN, GPIO_LOW);
20002764:	8e020000 	lw	v0,0(s0)
20002768:	00000000 	nop
2000276c:	00511024 	and	v0,v0,s1
20002770:	ae020000 	sw	v0,0(s0)
20002774:	8e020000 	lw	v0,0(s0)
20002778:	00000000 	nop
2000277c:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, 0x02);
20002780:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002784:	00000000 	nop
		SPI_Swap(SPI0, 0x24);
20002788:	00002021 	move	a0,zero
2000278c:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002790:	24050024 	li	a1,36
		SPI_Swap(SPI0, 0xFF);
20002794:	00002021 	move	a0,zero
20002798:	0c000f39 	jal	20003ce4 <SPI_Swap>
2000279c:	240500ff 	li	a1,255
		SPI_Swap(SPI0, 0xFF);
200027a0:	00002021 	move	a0,zero
200027a4:	0c000f39 	jal	20003ce4 <SPI_Swap>
200027a8:	240500ff 	li	a1,255
		SPI_Swap(SPI0, 0xFF);
200027ac:	00002021 	move	a0,zero
200027b0:	0c000f39 	jal	20003ce4 <SPI_Swap>
200027b4:	240500ff 	li	a1,255
		SPI_Swap(SPI0, 0xFF);
200027b8:	00002021 	move	a0,zero
200027bc:	0c000f39 	jal	20003ce4 <SPI_Swap>
200027c0:	240500ff 	li	a1,255
		GPIO_Write(CS_PIN, GPIO_HIGH);
200027c4:	8e020000 	lw	v0,0(s0)

		/* CANCTRL - Set to Normal Mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
200027c8:	00002021 	move	a0,zero
		SPI_Swap(SPI0, 0x24);
		SPI_Swap(SPI0, 0xFF);
		SPI_Swap(SPI0, 0xFF);
		SPI_Swap(SPI0, 0xFF);
		SPI_Swap(SPI0, 0xFF);
		GPIO_Write(CS_PIN, GPIO_HIGH);
200027cc:	ae020000 	sw	v0,0(s0)
200027d0:	8e020000 	lw	v0,0(s0)

		/* CANCTRL - Set to Normal Mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
200027d4:	24050002 	li	a1,2
		SPI_Swap(SPI0, 0x24);
		SPI_Swap(SPI0, 0xFF);
		SPI_Swap(SPI0, 0xFF);
		SPI_Swap(SPI0, 0xFF);
		SPI_Swap(SPI0, 0xFF);
		GPIO_Write(CS_PIN, GPIO_HIGH);
200027d8:	34420040 	ori	v0,v0,0x40
200027dc:	ae020000 	sw	v0,0(s0)

		/* CANCTRL - Set to Normal Mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
200027e0:	8e020000 	lw	v0,0(s0)
200027e4:	00000000 	nop
200027e8:	00518824 	and	s1,v0,s1
200027ec:	ae110000 	sw	s1,0(s0)
200027f0:	8e020000 	lw	v0,0(s0)
200027f4:	00000000 	nop
200027f8:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, 0x02);
200027fc:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002800:	00000000 	nop
		SPI_Swap(SPI0, 0x0F);
20002804:	00002021 	move	a0,zero
20002808:	0c000f39 	jal	20003ce4 <SPI_Swap>
2000280c:	2405000f 	li	a1,15
		SPI_Swap(SPI0, 0x00);
20002810:	00002021 	move	a0,zero
20002814:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002818:	00002821 	move	a1,zero
		GPIO_Write(CS_PIN, GPIO_HIGH);
2000281c:	8e020000 	lw	v0,0(s0)

		init = True;
20002820:	24030001 	li	v1,1
		/* CANCTRL - Set to Normal Mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x0F);
		SPI_Swap(SPI0, 0x00);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20002824:	ae020000 	sw	v0,0(s0)
20002828:	8e020000 	lw	v0,0(s0)

		init = True;
2000282c:	af830178 	sw	v1,376(gp)
		/* CANCTRL - Set to Normal Mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x0F);
		SPI_Swap(SPI0, 0x00);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20002830:	34420040 	ori	v0,v0,0x40
20002834:	ae020000 	sw	v0,0(s0)
	/* Transmit "proper" CAN messages only when the Mode is GO */
	//if(System_Mode_G == Go || System_Mode_G == Game_Over)
	{
		/* Pull CS pin low - indicates start of transmission */
		/* Load CAN message into TX0: Left Motor */
		GPIO_Write(CS_PIN, GPIO_LOW);
20002838:	3c108000 	lui	s0,0x8000
2000283c:	36100600 	ori	s0,s0,0x600
20002840:	8e020000 	lw	v0,0(s0)
20002844:	2411ffbf 	li	s1,-65
20002848:	00511024 	and	v0,v0,s1
2000284c:	ae020000 	sw	v0,0(s0)
20002850:	8e020000 	lw	v0,0(s0)
		SPI_Swap(SPI0, LOAD_TX0_INS);
20002854:	00002021 	move	a0,zero
20002858:	24050040 	li	a1,64
	/* Transmit "proper" CAN messages only when the Mode is GO */
	//if(System_Mode_G == Go || System_Mode_G == Game_Over)
	{
		/* Pull CS pin low - indicates start of transmission */
		/* Load CAN message into TX0: Left Motor */
		GPIO_Write(CS_PIN, GPIO_LOW);
2000285c:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, LOAD_TX0_INS);
20002860:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002864:	00000000 	nop
		spi_buffer_CAN(canIDLf, 8, candataLf);
20002868:	8f8400e8 	lw	a0,232(gp)
2000286c:	2786006c 	addiu	a2,gp,108
20002870:	0c0008a3 	jal	2000228c <spi_buffer_CAN>
20002874:	24050008 	li	a1,8
		GPIO_Write(CS_PIN, GPIO_HIGH);
20002878:	8e020000 	lw	v0,0(s0)

		/* Load CAN message into TX1: Right Motor */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, LOAD_TX1_INS);
2000287c:	00002021 	move	a0,zero
		/* Pull CS pin low - indicates start of transmission */
		/* Load CAN message into TX0: Left Motor */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, LOAD_TX0_INS);
		spi_buffer_CAN(canIDLf, 8, candataLf);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20002880:	ae020000 	sw	v0,0(s0)
20002884:	8e020000 	lw	v0,0(s0)

		/* Load CAN message into TX1: Right Motor */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, LOAD_TX1_INS);
20002888:	24050042 	li	a1,66
		/* Pull CS pin low - indicates start of transmission */
		/* Load CAN message into TX0: Left Motor */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, LOAD_TX0_INS);
		spi_buffer_CAN(canIDLf, 8, candataLf);
		GPIO_Write(CS_PIN, GPIO_HIGH);
2000288c:	34420040 	ori	v0,v0,0x40
20002890:	ae020000 	sw	v0,0(s0)

		/* Load CAN message into TX1: Right Motor */
		GPIO_Write(CS_PIN, GPIO_LOW);
20002894:	8e020000 	lw	v0,0(s0)
20002898:	00000000 	nop
2000289c:	00511024 	and	v0,v0,s1
200028a0:	ae020000 	sw	v0,0(s0)
200028a4:	8e020000 	lw	v0,0(s0)
200028a8:	00000000 	nop
200028ac:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, LOAD_TX1_INS);
200028b0:	0c000f39 	jal	20003ce4 <SPI_Swap>
200028b4:	00000000 	nop
		spi_buffer_CAN(canIDRt, 8, candataRt);
200028b8:	8f840064 	lw	a0,100(gp)
200028bc:	27860098 	addiu	a2,gp,152
200028c0:	0c0008a3 	jal	2000228c <spi_buffer_CAN>
200028c4:	24050008 	li	a1,8
		GPIO_Write(CS_PIN, GPIO_HIGH);
200028c8:	8e020000 	lw	v0,0(s0)

		/* Load CAN message into TX2: Servo controls */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, LOAD_TX2_INS);
200028cc:	00002021 	move	a0,zero

		/* Load CAN message into TX1: Right Motor */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, LOAD_TX1_INS);
		spi_buffer_CAN(canIDRt, 8, candataRt);
		GPIO_Write(CS_PIN, GPIO_HIGH);
200028d0:	ae020000 	sw	v0,0(s0)
200028d4:	8e020000 	lw	v0,0(s0)

		/* Load CAN message into TX2: Servo controls */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, LOAD_TX2_INS);
200028d8:	24050044 	li	a1,68

		/* Load CAN message into TX1: Right Motor */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, LOAD_TX1_INS);
		spi_buffer_CAN(canIDRt, 8, candataRt);
		GPIO_Write(CS_PIN, GPIO_HIGH);
200028dc:	34420040 	ori	v0,v0,0x40
200028e0:	ae020000 	sw	v0,0(s0)

		/* Load CAN message into TX2: Servo controls */
		GPIO_Write(CS_PIN, GPIO_LOW);
200028e4:	8e020000 	lw	v0,0(s0)
200028e8:	00000000 	nop
200028ec:	00511024 	and	v0,v0,s1
200028f0:	ae020000 	sw	v0,0(s0)
200028f4:	8e020000 	lw	v0,0(s0)
200028f8:	00000000 	nop
200028fc:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, LOAD_TX2_INS);
20002900:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002904:	00000000 	nop
		spi_buffer_CAN(0x05A5EEEE, 8, servo);
20002908:	3c0405a5 	lui	a0,0x5a5
2000290c:	278600a8 	addiu	a2,gp,168
20002910:	3484eeee 	ori	a0,a0,0xeeee
20002914:	0c0008a3 	jal	2000228c <spi_buffer_CAN>
20002918:	24050008 	li	a1,8
		GPIO_Write(CS_PIN, GPIO_HIGH);
2000291c:	8e020000 	lw	v0,0(s0)

		/* Tx0 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, RTS_TX0_INS);
20002920:	00002021 	move	a0,zero

		/* Load CAN message into TX2: Servo controls */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, LOAD_TX2_INS);
		spi_buffer_CAN(0x05A5EEEE, 8, servo);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20002924:	ae020000 	sw	v0,0(s0)
20002928:	8e020000 	lw	v0,0(s0)

		/* Tx0 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, RTS_TX0_INS);
2000292c:	24050081 	li	a1,129

		/* Load CAN message into TX2: Servo controls */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, LOAD_TX2_INS);
		spi_buffer_CAN(0x05A5EEEE, 8, servo);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20002930:	34420040 	ori	v0,v0,0x40
20002934:	ae020000 	sw	v0,0(s0)

		/* Tx0 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
20002938:	8e020000 	lw	v0,0(s0)
2000293c:	00000000 	nop
20002940:	00511024 	and	v0,v0,s1
20002944:	ae020000 	sw	v0,0(s0)
20002948:	8e020000 	lw	v0,0(s0)
2000294c:	00000000 	nop
20002950:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, RTS_TX0_INS);
20002954:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002958:	00000000 	nop
		GPIO_Write(CS_PIN, GPIO_HIGH);
2000295c:	8e020000 	lw	v0,0(s0)

		/* Tx1 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, RTS_TX1_INS);
20002960:	00002021 	move	a0,zero
		GPIO_Write(CS_PIN, GPIO_HIGH);

		/* Tx0 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, RTS_TX0_INS);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20002964:	ae020000 	sw	v0,0(s0)
20002968:	8e020000 	lw	v0,0(s0)

		/* Tx1 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, RTS_TX1_INS);
2000296c:	24050082 	li	a1,130
		GPIO_Write(CS_PIN, GPIO_HIGH);

		/* Tx0 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, RTS_TX0_INS);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20002970:	34420040 	ori	v0,v0,0x40
20002974:	ae020000 	sw	v0,0(s0)

		/* Tx1 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
20002978:	8e020000 	lw	v0,0(s0)
2000297c:	00000000 	nop
20002980:	00511024 	and	v0,v0,s1
20002984:	ae020000 	sw	v0,0(s0)
20002988:	8e020000 	lw	v0,0(s0)
2000298c:	00000000 	nop
20002990:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, RTS_TX1_INS);
20002994:	0c000f39 	jal	20003ce4 <SPI_Swap>
20002998:	00000000 	nop
		GPIO_Write(CS_PIN, GPIO_HIGH);
2000299c:	8e020000 	lw	v0,0(s0)

		/* Tx2 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, RTS_TX2_INS);
200029a0:	00002021 	move	a0,zero
		GPIO_Write(CS_PIN, GPIO_HIGH);

		/* Tx1 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, RTS_TX1_INS);
		GPIO_Write(CS_PIN, GPIO_HIGH);
200029a4:	ae020000 	sw	v0,0(s0)
200029a8:	8e020000 	lw	v0,0(s0)

		/* Tx2 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, RTS_TX2_INS);
200029ac:	24050084 	li	a1,132
		GPIO_Write(CS_PIN, GPIO_HIGH);

		/* Tx1 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, RTS_TX1_INS);
		GPIO_Write(CS_PIN, GPIO_HIGH);
200029b0:	34420040 	ori	v0,v0,0x40
200029b4:	ae020000 	sw	v0,0(s0)

		/* Tx2 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
200029b8:	8e020000 	lw	v0,0(s0)
200029bc:	00000000 	nop
200029c0:	00518824 	and	s1,v0,s1
200029c4:	ae110000 	sw	s1,0(s0)
200029c8:	8e020000 	lw	v0,0(s0)
200029cc:	00000000 	nop
200029d0:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, RTS_TX2_INS);
200029d4:	0c000f39 	jal	20003ce4 <SPI_Swap>
200029d8:	00000000 	nop
		GPIO_Write(CS_PIN, GPIO_HIGH);
200029dc:	8e020000 	lw	v0,0(s0)

		/* Check Rx buffers for incoming message */
		spi_receive_CAN(READ_RX0_INS, &bufferRX0);
200029e0:	3c054000 	lui	a1,0x4000
		GPIO_Write(CS_PIN, GPIO_HIGH);

		/* Tx2 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, RTS_TX2_INS);
		GPIO_Write(CS_PIN, GPIO_HIGH);
200029e4:	ae020000 	sw	v0,0(s0)
200029e8:	8e020000 	lw	v0,0(s0)

		/* Check Rx buffers for incoming message */
		spi_receive_CAN(READ_RX0_INS, &bufferRX0);
	}

}
200029ec:	8fbf001c 	lw	ra,28(sp)
		GPIO_Write(CS_PIN, GPIO_HIGH);

		/* Tx2 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, RTS_TX2_INS);
		GPIO_Write(CS_PIN, GPIO_HIGH);
200029f0:	34420040 	ori	v0,v0,0x40
200029f4:	ae020000 	sw	v0,0(s0)

		/* Check Rx buffers for incoming message */
		spi_receive_CAN(READ_RX0_INS, &bufferRX0);
	}

}
200029f8:	8fb10018 	lw	s1,24(sp)
200029fc:	8fb00014 	lw	s0,20(sp)
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, RTS_TX2_INS);
		GPIO_Write(CS_PIN, GPIO_HIGH);

		/* Check Rx buffers for incoming message */
		spi_receive_CAN(READ_RX0_INS, &bufferRX0);
20002a00:	24a50640 	addiu	a1,a1,1600
20002a04:	24040090 	li	a0,144
20002a08:	0800086b 	j	200021ac <spi_receive_CAN>
20002a0c:	27bd0020 	addiu	sp,sp,32

20002a10 <Message_Sender_Init>:
/**
 * Initialisation for the SPI package.
 * This will be called from Tasks_Init by default.
 */
void Message_Sender_Init(void)
{
20002a10:	27bdffe8 	addiu	sp,sp,-24
	/* Task initialisation */
	// SPI  0
	// Mode 0
	// SCLK 1KHz = (50MHz / 1000)
	const uint32_t clock_divider = Config_Oscillator_Frequency / 10000000;
	SPI_Init(SPI0, 0, clock_divider);
20002a14:	00002021 	move	a0,zero
20002a18:	00002821 	move	a1,zero
/**
 * Initialisation for the SPI package.
 * This will be called from Tasks_Init by default.
 */
void Message_Sender_Init(void)
{
20002a1c:	afbf0014 	sw	ra,20(sp)
	/* Task initialisation */
	// SPI  0
	// Mode 0
	// SCLK 1KHz = (50MHz / 1000)
	const uint32_t clock_divider = Config_Oscillator_Frequency / 10000000;
	SPI_Init(SPI0, 0, clock_divider);
20002a20:	0c000f2c 	jal	20003cb0 <SPI_Init>
20002a24:	24060005 	li	a2,5
	speedPin = 0x33;

	bufferRX0.status = Used;
	bufferRX1.status = Used;

	GPIO_Set_Direction(CS_PIN, GPIO_OUTPUT);
20002a28:	3c028000 	lui	v0,0x8000
20002a2c:	34420600 	ori	v0,v0,0x600
20002a30:	8c440004 	lw	a0,4(v0)
20002a34:	2403ffbf 	li	v1,-65
20002a38:	00831824 	and	v1,a0,v1
20002a3c:	ac430004 	sw	v1,4(v0)
20002a40:	8c430004 	lw	v1,4(v0)
	const uint32_t clock_divider = Config_Oscillator_Frequency / 10000000;
	SPI_Init(SPI0, 0, clock_divider);

	speedPin = 0x33;

	bufferRX0.status = Used;
20002a44:	24040001 	li	a0,1
	bufferRX1.status = Used;

	GPIO_Set_Direction(CS_PIN, GPIO_OUTPUT);
20002a48:	34630040 	ori	v1,v1,0x40
20002a4c:	ac430004 	sw	v1,4(v0)
	GPIO_Write(CS_PIN, GPIO_HIGH);
20002a50:	8c430000 	lw	v1,0(v0)
	SPI_Init(SPI0, 0, clock_divider);

	speedPin = 0x33;

	bufferRX0.status = Used;
	bufferRX1.status = Used;
20002a54:	3c064000 	lui	a2,0x4000

	GPIO_Set_Direction(CS_PIN, GPIO_OUTPUT);
	GPIO_Write(CS_PIN, GPIO_HIGH);
20002a58:	ac430000 	sw	v1,0(v0)
20002a5c:	8c430000 	lw	v1,0(v0)
	SPI_Init(SPI0, 0, clock_divider);

	speedPin = 0x33;

	bufferRX0.status = Used;
	bufferRX1.status = Used;
20002a60:	acc40650 	sw	a0,1616(a2)

	GPIO_Set_Direction(CS_PIN, GPIO_OUTPUT);
	GPIO_Write(CS_PIN, GPIO_HIGH);
20002a64:	34630040 	ori	v1,v1,0x40
20002a68:	ac430000 	sw	v1,0(v0)

	GPIO_Set_Direction(RST_PIN, GPIO_OUTPUT);
20002a6c:	8c450004 	lw	a1,4(v0)
20002a70:	2403fffb 	li	v1,-5
20002a74:	00a31824 	and	v1,a1,v1
20002a78:	ac430004 	sw	v1,4(v0)
20002a7c:	8c430004 	lw	v1,4(v0)
	GPIO_Write(RST_PIN, GPIO_HIGH);

	init = False;
20002a80:	af800178 	sw	zero,376(gp)
	bufferRX1.status = Used;

	GPIO_Set_Direction(CS_PIN, GPIO_OUTPUT);
	GPIO_Write(CS_PIN, GPIO_HIGH);

	GPIO_Set_Direction(RST_PIN, GPIO_OUTPUT);
20002a84:	34630004 	ori	v1,v1,0x4
20002a88:	ac430004 	sw	v1,4(v0)
	GPIO_Write(RST_PIN, GPIO_HIGH);
20002a8c:	8c450000 	lw	a1,0(v0)

	init = False;
20002a90:	278300a8 	addiu	v1,gp,168

	GPIO_Set_Direction(CS_PIN, GPIO_OUTPUT);
	GPIO_Write(CS_PIN, GPIO_HIGH);

	GPIO_Set_Direction(RST_PIN, GPIO_OUTPUT);
	GPIO_Write(RST_PIN, GPIO_HIGH);
20002a94:	ac450000 	sw	a1,0(v0)
20002a98:	8c450000 	lw	a1,0(v0)
20002a9c:	00000000 	nop
20002aa0:	34a50004 	ori	a1,a1,0x4
20002aa4:	ac450000 	sw	a1,0(v0)
	// Mode 0
	// SCLK 1KHz = (50MHz / 1000)
	const uint32_t clock_divider = Config_Oscillator_Frequency / 10000000;
	SPI_Init(SPI0, 0, clock_divider);

	speedPin = 0x33;
20002aa8:	24020033 	li	v0,51
20002aac:	a3820175 	sb	v0,373(gp)

	bufferRX0.status = Used;
20002ab0:	3c024000 	lui	v0,0x4000
20002ab4:	ac440640 	sw	a0,1600(v0)

/**
 * Initialisation for the SPI package.
 * This will be called from Tasks_Init by default.
 */
void Message_Sender_Init(void)
20002ab8:	24620008 	addiu	v0,v1,8

	init = False;

	for(uint8_t i = 0; i < 8; i++)
	{
		servo[i] = 0x0;
20002abc:	a0600000 	sb	zero,0(v1)
20002ac0:	24630001 	addiu	v1,v1,1
	GPIO_Set_Direction(RST_PIN, GPIO_OUTPUT);
	GPIO_Write(RST_PIN, GPIO_HIGH);

	init = False;

	for(uint8_t i = 0; i < 8; i++)
20002ac4:	1462fffd 	bne	v1,v0,20002abc <Message_Sender_Init+0xac>
20002ac8:	00000000 	nop
	{
		servo[i] = 0x0;
	}

	ticked = 0;
}
20002acc:	8fbf0014 	lw	ra,20(sp)
	for(uint8_t i = 0; i < 8; i++)
	{
		servo[i] = 0x0;
	}

	ticked = 0;
20002ad0:	a7800198 	sh	zero,408(gp)
}
20002ad4:	03e00008 	jr	ra
20002ad8:	27bd0018 	addiu	sp,sp,24

20002adc <Flashing_LED_Init>:
/**
 * Initialises the GPIO pin and outputs the initial value to the LED.
 */
void Flashing_LED_Init(void)
{
	GPIO_Set_Direction(LED_Pin, GPIO_OUTPUT);
20002adc:	3c028000 	lui	v0,0x8000
20002ae0:	34420200 	ori	v0,v0,0x200
20002ae4:	8c440004 	lw	a0,4(v0)
20002ae8:	2403fdff 	li	v1,-513
20002aec:	00831824 	and	v1,a0,v1
20002af0:	ac430004 	sw	v1,4(v0)
20002af4:	8c440004 	lw	a0,4(v0)
	GPIO_Write(LED_Pin, led_state);
20002af8:	8f830000 	lw	v1,0(gp)
/**
 * Initialises the GPIO pin and outputs the initial value to the LED.
 */
void Flashing_LED_Init(void)
{
	GPIO_Set_Direction(LED_Pin, GPIO_OUTPUT);
20002afc:	34840200 	ori	a0,a0,0x200
20002b00:	ac440004 	sw	a0,4(v0)
	GPIO_Write(LED_Pin, led_state);
20002b04:	2c640001 	sltiu	a0,v1,1
20002b08:	8c450000 	lw	a1,0(v0)
20002b0c:	00042240 	sll	a0,a0,0x9
20002b10:	00042027 	nor	a0,zero,a0
20002b14:	00852024 	and	a0,a0,a1
20002b18:	ac440000 	sw	a0,0(v0)
20002b1c:	8c440000 	lw	a0,0(v0)
20002b20:	00031a40 	sll	v1,v1,0x9
20002b24:	00641825 	or	v1,v1,a0
20002b28:	ac430000 	sw	v1,0(v0)
}
20002b2c:	03e00008 	jr	ra
20002b30:	00000000 	nop

20002b34 <Flashing_LED_Toggle>:
/**
 * Toggles the state of the GPIO pin and its LED.
 */
void Flashing_LED_Toggle(void)
{
	GPIO_Write(LED_Pin, led_state);
20002b34:	8f830000 	lw	v1,0(gp)
20002b38:	3c028000 	lui	v0,0x8000
20002b3c:	34420200 	ori	v0,v0,0x200
20002b40:	2c640001 	sltiu	a0,v1,1
20002b44:	8c460000 	lw	a2,0(v0)
20002b48:	00042a40 	sll	a1,a0,0x9
20002b4c:	00052827 	nor	a1,zero,a1
20002b50:	00a62824 	and	a1,a1,a2
20002b54:	ac450000 	sw	a1,0(v0)
20002b58:	8c450000 	lw	a1,0(v0)
20002b5c:	00033240 	sll	a2,v1,0x9
20002b60:	00c52825 	or	a1,a2,a1
	if(System_Mode_G == Set)
20002b64:	8f8600f8 	lw	a2,248(gp)
/**
 * Toggles the state of the GPIO pin and its LED.
 */
void Flashing_LED_Toggle(void)
{
	GPIO_Write(LED_Pin, led_state);
20002b68:	ac450000 	sw	a1,0(v0)
	if(System_Mode_G == Set)
20002b6c:	24050001 	li	a1,1
20002b70:	14c5000a 	bne	a2,a1,20002b9c <Flashing_LED_Toggle+0x68>
20002b74:	00000000 	nop
	{
		GPIO_Write(Error_Lamp, led_state);
20002b78:	8c450000 	lw	a1,0(v0)
20002b7c:	00042200 	sll	a0,a0,0x8
20002b80:	00042027 	nor	a0,zero,a0
20002b84:	00852024 	and	a0,a0,a1
20002b88:	ac440000 	sw	a0,0(v0)
20002b8c:	8c440000 	lw	a0,0(v0)
20002b90:	00032a00 	sll	a1,v1,0x8
20002b94:	08000aec 	j	20002bb0 <Flashing_LED_Toggle+0x7c>
20002b98:	00a42025 	or	a0,a1,a0
	}
	else
	{
		GPIO_Write(Error_Lamp, GPIO_LOW);
20002b9c:	8c450000 	lw	a1,0(v0)
20002ba0:	2404feff 	li	a0,-257
20002ba4:	00a42024 	and	a0,a1,a0
20002ba8:	ac440000 	sw	a0,0(v0)
20002bac:	8c440000 	lw	a0,0(v0)
	}
	led_state = !led_state;
20002bb0:	2c630001 	sltiu	v1,v1,1
	{
		GPIO_Write(Error_Lamp, led_state);
	}
	else
	{
		GPIO_Write(Error_Lamp, GPIO_LOW);
20002bb4:	ac440000 	sw	a0,0(v0)
	}
	led_state = !led_state;
}
20002bb8:	03e00008 	jr	ra
20002bbc:	af830000 	sw	v1,0(gp)

20002bc0 <Course_Corrector_Init>:
 * This will be called from Tasks_Init by default.
 */
void Course_Corrector_Init(void)
{
	/* Initialisation of course correction values */
	Course_correction_Lf = False;
20002bc0:	af800074 	sw	zero,116(gp)
	Course_correction_Rt = False;
}
20002bc4:	03e00008 	jr	ra
20002bc8:	af800060 	sw	zero,96(gp)

20002bcc <Course_Corrector_Update>:
 * Basic implementation: To reduce the speed of the faster side.
 * Advanced requirement: To recalculate the Script to compensate for deviation.
 */
void Course_Corrector_Update(void)
{
	if(System_Mode_G == Go)
20002bcc:	8f8300f8 	lw	v1,248(gp)
20002bd0:	24020002 	li	v0,2
20002bd4:	14620011 	bne	v1,v0,20002c1c <Course_Corrector_Update+0x50>
20002bd8:	00000000 	nop
	{
		/* Encoder monitor task */
		/* If the Left side is faster than the Right, activate the Left CC flag */
		if((Motor_Lf_Enc_Track - Motor_Rt_Enc_Track) > COURSE_CORRECTION_BUFFER)
20002bdc:	8f82003c 	lw	v0,60(gp)
20002be0:	8f8300d8 	lw	v1,216(gp)
20002be4:	00000000 	nop
20002be8:	00432023 	subu	a0,v0,v1
20002bec:	28840004 	slti	a0,a0,4
20002bf0:	14800005 	bnez	a0,20002c08 <Course_Corrector_Update+0x3c>
20002bf4:	00621023 	subu	v0,v1,v0
		{
			Course_correction_Lf = False;
			Course_correction_Rt = True;
20002bf8:	24020001 	li	v0,1
20002bfc:	af820060 	sw	v0,96(gp)
	{
		/* Encoder monitor task */
		/* If the Left side is faster than the Right, activate the Left CC flag */
		if((Motor_Lf_Enc_Track - Motor_Rt_Enc_Track) > COURSE_CORRECTION_BUFFER)
		{
			Course_correction_Lf = False;
20002c00:	03e00008 	jr	ra
20002c04:	af800074 	sw	zero,116(gp)
			Course_correction_Rt = True;
		}
		/* If the Right side is faster than the Left, activate the Right CC flag */
		else if((Motor_Rt_Enc_Track - Motor_Lf_Enc_Track) > COURSE_CORRECTION_BUFFER)
20002c08:	28420004 	slti	v0,v0,4
20002c0c:	14400003 	bnez	v0,20002c1c <Course_Corrector_Update+0x50>
20002c10:	24020001 	li	v0,1
		{
			Course_correction_Lf = True;
20002c14:	08000b08 	j	20002c20 <Course_Corrector_Update+0x54>
20002c18:	af820074 	sw	v0,116(gp)
		}
	}
	/* Ensure default is False */
	else
	{
		Course_correction_Lf = False;
20002c1c:	af800074 	sw	zero,116(gp)
		Course_correction_Rt = False;
20002c20:	03e00008 	jr	ra
20002c24:	af800060 	sw	zero,96(gp)

20002c28 <CAN_relay_Init>:
 * This will be called from Tasks_Init by default.
 */
void CAN_relay_Init(void)
{
	/* Initialisation of variables */
	motor_speed_Lf = 0x0;
20002c28:	a780019e 	sh	zero,414(gp)
	motor_speed_Rt = 0x0;
20002c2c:	a780019c 	sh	zero,412(gp)
	motor_direction_Lf = 0x0;
20002c30:	a38001a0 	sb	zero,416(gp)
	motor_direction_Rt = 0x0;
20002c34:	a380019a 	sb	zero,410(gp)
	canIDLf = 0;
20002c38:	af8000e8 	sw	zero,232(gp)
	canIDRt = 0;
20002c3c:	af800064 	sw	zero,100(gp)
20002c40:	00001021 	move	v0,zero
	for(uint8_t i = 0; i < 8; i++)
	{
		candataLf[i] = 0;
20002c44:	2785006c 	addiu	a1,gp,108
		candataRt[i] = 0;
20002c48:	27840098 	addiu	a0,gp,152
	motor_speed_Rt = 0x0;
	motor_direction_Lf = 0x0;
	motor_direction_Rt = 0x0;
	canIDLf = 0;
	canIDRt = 0;
	for(uint8_t i = 0; i < 8; i++)
20002c4c:	24030008 	li	v1,8
	{
		candataLf[i] = 0;
20002c50:	00453821 	addu	a3,v0,a1
		candataRt[i] = 0;
20002c54:	00443021 	addu	a2,v0,a0
20002c58:	24420001 	addiu	v0,v0,1
	motor_direction_Rt = 0x0;
	canIDLf = 0;
	canIDRt = 0;
	for(uint8_t i = 0; i < 8; i++)
	{
		candataLf[i] = 0;
20002c5c:	a0e00000 	sb	zero,0(a3)
	motor_speed_Rt = 0x0;
	motor_direction_Lf = 0x0;
	motor_direction_Rt = 0x0;
	canIDLf = 0;
	canIDRt = 0;
	for(uint8_t i = 0; i < 8; i++)
20002c60:	1443fffb 	bne	v0,v1,20002c50 <CAN_relay_Init+0x28>
20002c64:	a0c00000 	sb	zero,0(a2)
		candataLf[i] = 0;
		candataRt[i] = 0;
	}

	/* Initialisation of Sensor Readings */
	sensorReadings.IRLeft = 0xFF;
20002c68:	3c044000 	lui	a0,0x4000
20002c6c:	240200ff 	li	v0,255
	sensorReadings.IRRight = 0xFF;
20002c70:	24830660 	addiu	v1,a0,1632
	sensorReadings.USFwd = 0xFF;
20002c74:	ac620008 	sw	v0,8(v1)
		candataLf[i] = 0;
		candataRt[i] = 0;
	}

	/* Initialisation of Sensor Readings */
	sensorReadings.IRLeft = 0xFF;
20002c78:	ac820660 	sw	v0,1632(a0)
	sensorReadings.IRRight = 0xFF;
	sensorReadings.USFwd = 0xFF;
}
20002c7c:	03e00008 	jr	ra
20002c80:	ac620004 	sw	v0,4(v1)

20002c84 <readCAN>:
}

void readCAN(void)
{
	/* Check to see data received from Proximity sensor */
	sensorReadings.IRLeft = ((bufferRX0.CAN_Data[2] & 0x3F) << 6) | (bufferRX0.CAN_Data[3] & 0x3F);
20002c84:	3c024000 	lui	v0,0x4000
20002c88:	24420640 	addiu	v0,v0,1600
20002c8c:	9045000a 	lbu	a1,10(v0)
	sensorReadings.IRRight = ((bufferRX0.CAN_Data[4] & 0x3F) << 6) | (bufferRX0.CAN_Data[5] & 0x3F);
20002c90:	9044000c 	lbu	a0,12(v0)
	sensorReadings.USFwd = ((((bufferRX0.CAN_Data[6] & 0x3F) << 6) | (bufferRX0.CAN_Data[7] & 0x3F)) & 0x0FFF);
20002c94:	9046000e 	lbu	a2,14(v0)
20002c98:	9043000f 	lbu	v1,15(v0)
}

void readCAN(void)
{
	/* Check to see data received from Proximity sensor */
	sensorReadings.IRLeft = ((bufferRX0.CAN_Data[2] & 0x3F) << 6) | (bufferRX0.CAN_Data[3] & 0x3F);
20002c9c:	9048000b 	lbu	t0,11(v0)
	sensorReadings.IRRight = ((bufferRX0.CAN_Data[4] & 0x3F) << 6) | (bufferRX0.CAN_Data[5] & 0x3F);
20002ca0:	9047000d 	lbu	a3,13(v0)
}

void readCAN(void)
{
	/* Check to see data received from Proximity sensor */
	sensorReadings.IRLeft = ((bufferRX0.CAN_Data[2] & 0x3F) << 6) | (bufferRX0.CAN_Data[3] & 0x3F);
20002ca4:	30a5003f 	andi	a1,a1,0x3f
	sensorReadings.IRRight = ((bufferRX0.CAN_Data[4] & 0x3F) << 6) | (bufferRX0.CAN_Data[5] & 0x3F);
20002ca8:	3084003f 	andi	a0,a0,0x3f
	sensorReadings.USFwd = ((((bufferRX0.CAN_Data[6] & 0x3F) << 6) | (bufferRX0.CAN_Data[7] & 0x3F)) & 0x0FFF);
20002cac:	30c6003f 	andi	a2,a2,0x3f
20002cb0:	3062003f 	andi	v0,v1,0x3f
}

void readCAN(void)
{
	/* Check to see data received from Proximity sensor */
	sensorReadings.IRLeft = ((bufferRX0.CAN_Data[2] & 0x3F) << 6) | (bufferRX0.CAN_Data[3] & 0x3F);
20002cb4:	00052980 	sll	a1,a1,0x6
20002cb8:	3c034000 	lui	v1,0x4000
20002cbc:	3108003f 	andi	t0,t0,0x3f
	sensorReadings.IRRight = ((bufferRX0.CAN_Data[4] & 0x3F) << 6) | (bufferRX0.CAN_Data[5] & 0x3F);
20002cc0:	00042180 	sll	a0,a0,0x6
20002cc4:	30e7003f 	andi	a3,a3,0x3f
	sensorReadings.USFwd = ((((bufferRX0.CAN_Data[6] & 0x3F) << 6) | (bufferRX0.CAN_Data[7] & 0x3F)) & 0x0FFF);
20002cc8:	00063180 	sll	a2,a2,0x6
20002ccc:	00c23025 	or	a2,a2,v0
}

void readCAN(void)
{
	/* Check to see data received from Proximity sensor */
	sensorReadings.IRLeft = ((bufferRX0.CAN_Data[2] & 0x3F) << 6) | (bufferRX0.CAN_Data[3] & 0x3F);
20002cd0:	00a82825 	or	a1,a1,t0
	sensorReadings.IRRight = ((bufferRX0.CAN_Data[4] & 0x3F) << 6) | (bufferRX0.CAN_Data[5] & 0x3F);
20002cd4:	24620660 	addiu	v0,v1,1632
20002cd8:	00872025 	or	a0,a0,a3
	sensorReadings.USFwd = ((((bufferRX0.CAN_Data[6] & 0x3F) << 6) | (bufferRX0.CAN_Data[7] & 0x3F)) & 0x0FFF);
20002cdc:	ac460008 	sw	a2,8(v0)
}

void readCAN(void)
{
	/* Check to see data received from Proximity sensor */
	sensorReadings.IRLeft = ((bufferRX0.CAN_Data[2] & 0x3F) << 6) | (bufferRX0.CAN_Data[3] & 0x3F);
20002ce0:	ac650660 	sw	a1,1632(v1)
	sensorReadings.IRRight = ((bufferRX0.CAN_Data[4] & 0x3F) << 6) | (bufferRX0.CAN_Data[5] & 0x3F);
	sensorReadings.USFwd = ((((bufferRX0.CAN_Data[6] & 0x3F) << 6) | (bufferRX0.CAN_Data[7] & 0x3F)) & 0x0FFF);
}
20002ce4:	03e00008 	jr	ra
20002ce8:	ac440004 	sw	a0,4(v0)

20002cec <CAN_relay_Update>:

/**
 * Retrieves and translates the Speed and Direction from the Motor Tasks into CAN messages.
 */
void CAN_relay_Update(void)
{
20002cec:	27bdffe8 	addiu	sp,sp,-24
20002cf0:	afbf0014 	sw	ra,20(sp)
	/* If the System is in GO mode, perform the calculations and translation */
	//if(System_Mode_G == Go)
	{
		/* Read CAN buffer */
		readCAN();
20002cf4:	0c000b21 	jal	20002c84 <readCAN>
20002cf8:	00000000 	nop

		/* Motor direction control */
		switch(Left_motor_direction_G)
20002cfc:	8f820094 	lw	v0,148(gp)
20002d00:	24030001 	li	v1,1
20002d04:	10430003 	beq	v0,v1,20002d14 <CAN_relay_Update+0x28>
20002d08:	24030002 	li	v1,2
20002d0c:	14430003 	bne	v0,v1,20002d1c <CAN_relay_Update+0x30>
20002d10:	00000000 	nop
		case Forwards:
			motor_direction_Lf = 0x1;
			break;
		case Reverse:
			motor_direction_Lf = 0x2;
			break;
20002d14:	08000b48 	j	20002d20 <CAN_relay_Update+0x34>
20002d18:	a38201a0 	sb	v0,416(gp)
		case Off:
		default:
			motor_direction_Lf = 0x0;
20002d1c:	a38001a0 	sb	zero,416(gp)
			break;
		}

		switch(Right_motor_direction_G)
20002d20:	8f820084 	lw	v0,132(gp)
20002d24:	24030001 	li	v1,1
20002d28:	10430003 	beq	v0,v1,20002d38 <CAN_relay_Update+0x4c>
20002d2c:	24030002 	li	v1,2
20002d30:	14430003 	bne	v0,v1,20002d40 <CAN_relay_Update+0x54>
20002d34:	00000000 	nop
		case Forwards:
			motor_direction_Rt = 0x1;
			break;
		case Reverse:
			motor_direction_Rt = 0x2;
			break;
20002d38:	08000b51 	j	20002d44 <CAN_relay_Update+0x58>
20002d3c:	a382019a 	sb	v0,410(gp)
		case Off:
		default:
			motor_direction_Rt = 0x0;
20002d40:	a380019a 	sb	zero,410(gp)
			break;
		}

		/* Motor speed value has a resolution of 0.5 RPM per bit; multiply value by 2 */
		motor_speed_Lf = Left_motor_speed_G * 2;
20002d44:	978300b0 	lhu	v1,176(gp)
		motor_speed_Rt = Right_motor_speed_G * 2;
20002d48:	978200b2 	lhu	v0,178(gp)
			motor_direction_Rt = 0x0;
			break;
		}

		/* Motor speed value has a resolution of 0.5 RPM per bit; multiply value by 2 */
		motor_speed_Lf = Left_motor_speed_G * 2;
20002d4c:	00031840 	sll	v1,v1,0x1
		motor_speed_Rt = Right_motor_speed_G * 2;
20002d50:	00021040 	sll	v0,v0,0x1

		if(Opponent_detected == True)
20002d54:	8f850040 	lw	a1,64(gp)
			motor_direction_Rt = 0x0;
			break;
		}

		/* Motor speed value has a resolution of 0.5 RPM per bit; multiply value by 2 */
		motor_speed_Lf = Left_motor_speed_G * 2;
20002d58:	3063ffff 	andi	v1,v1,0xffff
		motor_speed_Rt = Right_motor_speed_G * 2;
20002d5c:	3042ffff 	andi	v0,v0,0xffff

		if(Opponent_detected == True)
20002d60:	24040001 	li	a0,1
			motor_direction_Rt = 0x0;
			break;
		}

		/* Motor speed value has a resolution of 0.5 RPM per bit; multiply value by 2 */
		motor_speed_Lf = Left_motor_speed_G * 2;
20002d64:	a783019e 	sh	v1,414(gp)
		motor_speed_Rt = Right_motor_speed_G * 2;

		if(Opponent_detected == True)
20002d68:	14a40003 	bne	a1,a0,20002d78 <CAN_relay_Update+0x8c>
20002d6c:	a782019c 	sh	v0,412(gp)
		{
			motor_direction_Rt = 0x0;
20002d70:	a380019a 	sb	zero,410(gp)
			motor_direction_Lf = 0x0;
20002d74:	a38001a0 	sb	zero,416(gp)
	 * Byte 2: Motor speed LO_BYTE
	 * Byte 3: Motor speed HI_BYTE
	 */
	candataLf[0] = motor_direction_Lf & 0x3;
	candataLf[2] = motor_speed_Lf & 0xFF;
	candataLf[3] = motor_speed_Lf >> 8;
20002d78:	00033202 	srl	a2,v1,0x8
	/* CAN_Data
	 * Byte 0: Motor direction
	 * Byte 2: Motor speed LO_BYTE
	 * Byte 3: Motor speed HI_BYTE
	 */
	candataLf[0] = motor_direction_Lf & 0x3;
20002d7c:	938701a0 	lbu	a3,416(gp)
}

void constructCANRt(void)
{
	canIDRt = 0x10EFD100;
	candataRt[0] = motor_direction_Rt & 0x3;
20002d80:	9385019a 	lbu	a1,410(gp)
	 * Byte 0: Priority. (Bits 3,4,5) [Bits 0,1,2,6,7 excluded]
	 * Byte 1: PDU1 Proprietary A identifier for peer-to-peer communications.
	 * Byte 2: Destination Peer Address: Motor Controller Address. Configurable using MC configuration utility.
	 * Byte 3: Source Peer Address.
	 */
	canIDLf = 0x14EFD000;
20002d84:	3c0814ef 	lui	t0,0x14ef
	 * Byte 2: Motor speed LO_BYTE
	 * Byte 3: Motor speed HI_BYTE
	 */
	candataLf[0] = motor_direction_Lf & 0x3;
	candataLf[2] = motor_speed_Lf & 0xFF;
	candataLf[3] = motor_speed_Lf >> 8;
20002d88:	a386006f 	sb	a2,111(gp)
	/* Force the Robot to stop by flooding the CAN with the STOP message */
	//else
	{
		//constructStopCAN();
	}
}
20002d8c:	8fbf0014 	lw	ra,20(sp)
	candataLf[3] = motor_speed_Lf >> 8;
}

void constructCANRt(void)
{
	canIDRt = 0x10EFD100;
20002d90:	3c0610ef 	lui	a2,0x10ef
	/* CAN_Data
	 * Byte 0: Motor direction
	 * Byte 2: Motor speed LO_BYTE
	 * Byte 3: Motor speed HI_BYTE
	 */
	candataLf[0] = motor_direction_Lf & 0x3;
20002d94:	30e70003 	andi	a3,a3,0x3
}

void constructCANRt(void)
{
	canIDRt = 0x10EFD100;
	candataRt[0] = motor_direction_Rt & 0x3;
20002d98:	30a50003 	andi	a1,a1,0x3
	candataRt[2] = motor_speed_Rt & 0xFF;
	candataRt[3] = motor_speed_Rt >> 8;
20002d9c:	00022202 	srl	a0,v0,0x8
	 * Byte 0: Priority. (Bits 3,4,5) [Bits 0,1,2,6,7 excluded]
	 * Byte 1: PDU1 Proprietary A identifier for peer-to-peer communications.
	 * Byte 2: Destination Peer Address: Motor Controller Address. Configurable using MC configuration utility.
	 * Byte 3: Source Peer Address.
	 */
	canIDLf = 0x14EFD000;
20002da0:	3508d000 	ori	t0,t0,0xd000
	candataLf[3] = motor_speed_Lf >> 8;
}

void constructCANRt(void)
{
	canIDRt = 0x10EFD100;
20002da4:	34c6d100 	ori	a2,a2,0xd100
	 * Byte 0: Priority. (Bits 3,4,5) [Bits 0,1,2,6,7 excluded]
	 * Byte 1: PDU1 Proprietary A identifier for peer-to-peer communications.
	 * Byte 2: Destination Peer Address: Motor Controller Address. Configurable using MC configuration utility.
	 * Byte 3: Source Peer Address.
	 */
	canIDLf = 0x14EFD000;
20002da8:	af8800e8 	sw	t0,232(gp)
	/* CAN_Data
	 * Byte 0: Motor direction
	 * Byte 2: Motor speed LO_BYTE
	 * Byte 3: Motor speed HI_BYTE
	 */
	candataLf[0] = motor_direction_Lf & 0x3;
20002dac:	a387006c 	sb	a3,108(gp)
	candataLf[3] = motor_speed_Lf >> 8;
}

void constructCANRt(void)
{
	canIDRt = 0x10EFD100;
20002db0:	af860064 	sw	a2,100(gp)
	candataRt[0] = motor_direction_Rt & 0x3;
20002db4:	a3850098 	sb	a1,152(gp)
	candataRt[2] = motor_speed_Rt & 0xFF;
	candataRt[3] = motor_speed_Rt >> 8;
20002db8:	a384009b 	sb	a0,155(gp)
	 * Byte 0: Motor direction
	 * Byte 2: Motor speed LO_BYTE
	 * Byte 3: Motor speed HI_BYTE
	 */
	candataLf[0] = motor_direction_Lf & 0x3;
	candataLf[2] = motor_speed_Lf & 0xFF;
20002dbc:	a383006e 	sb	v1,110(gp)

void constructCANRt(void)
{
	canIDRt = 0x10EFD100;
	candataRt[0] = motor_direction_Rt & 0x3;
	candataRt[2] = motor_speed_Rt & 0xFF;
20002dc0:	a382009a 	sb	v0,154(gp)
	/* Force the Robot to stop by flooding the CAN with the STOP message */
	//else
	{
		//constructStopCAN();
	}
}
20002dc4:	03e00008 	jr	ra
20002dc8:	27bd0018 	addiu	sp,sp,24

20002dcc <Handler>:
        .section .text.Handler
        .ent Handler
        .set noat
        .set noreorder
Handler:
        mfc0   $26, $13			# Read CP0 Cause register
20002dcc:	401a6800 	mfc0	k0,c0_cause
		nop
20002dd0:	00000000 	nop
		and    $27, $26, 0x3f
20002dd4:	335b003f 	andi	k1,k0,0x3f
		la	   $26, TableBase
20002dd8:	3c1a4000 	lui	k0,0x4000
20002ddc:	275a0380 	addiu	k0,k0,896
		addu   $26, $26, $27
20002de0:	035bd021 	addu	k0,k0,k1
		lw     $27, 0($26)
20002de4:	8f5b0000 	lw	k1,0(k0)
		nop
20002de8:	00000000 	nop
		j	   $27
20002dec:	03600008 	jr	k1
        nop
20002df0:	00000000 	nop

20002df4 <End_Handler>:
        .end Handler

      .globl End_Handler
      .ent End_Handler
End_Handler:
 		mfc0   $26,$14         # Read CP0 EPC return address Reg
20002df4:	401a7000 	mfc0	k0,c0_epc
        nop
20002df8:	00000000 	nop
        j      $26             # Return from handler
20002dfc:	03400008 	jr	k0
        rfe
20002e00:	42000010 	rfe

20002e04 <Excpt_Unused>:
	.set noreorder
	.set noat

	.globl Excpt_Unused
Excpt_Unused:
        j    Excpt_Unused 	# Loop
20002e04:	08000b81 00000000                       ........

20002e0c <Excpt_IAbort>:
        nop

	.globl Excpt_IAbort
Excpt_IAbort:
		mfc0   $26,$14         # Read CP0 EPC return address Reg
20002e0c:	401a7000 08000b83 00000000              .p.@........

20002e18 <Excpt_DAbort>:
        j    Excpt_IAbort 	   # Loop
        nop

	.globl Excpt_DAbort
Excpt_DAbort:
        j    Excpt_DAbort 	   # Loop
20002e18:	08000b86 00000000                       ........

20002e20 <Excpt_Syscall>:
        nop

	.globl Excpt_Syscall
Excpt_Syscall:
        j    Excpt_Syscall 	   # Loop
20002e20:	08000b88 00000000                       ........

20002e28 <Excpt_UndefInst>:
        nop

	.globl Excpt_UndefInst
Excpt_UndefInst:
        j    Excpt_UndefInst   # Loop
20002e28:	08000b8a 00000000                       ........

20002e30 <Excpt_Overflow>:
        nop

	.globl Excpt_Overflow
Excpt_Overflow:
        j    Excpt_Overflow	   # Loop
20002e30:	08000b8c 00000000                       ........

20002e38 <Excpt_CoPro>:
        nop

	.globl Excpt_CoPro
Excpt_CoPro:
        j    Excpt_CoPro	   # Loop
20002e38:	08000b8e 00000000                       ........

20002e40 <Excpt_Break>:
        nop

	.globl Excpt_Break
Excpt_Break:
        j    Excpt_Break	   # Loop
20002e40:	08000b90 00000000                       ........

20002e48 <InterruptHandler>:
        .ent InterruptHandler
        .set noat
        .set noreorder
InterruptHandler:
		/* Temporarily store the User Stack Pointer */
		move $k1, $sp
20002e48:	03a0d821 	move	k1,sp

		/* Load the IRQ Stack Pointer */
		la $k0, IRQ_Stk_Base_Val
20002e4c:	3c1a4000 	lui	k0,0x4000
20002e50:	375a4000 	ori	k0,k0,0x4000
		move $sp, $k0
20002e54:	0340e821 	move	sp,k0

		/* Allocate stack space */
#ifndef FPU
		subu $sp, 120
20002e58:	27bdff88 	addiu	sp,sp,-120
#else
		subu $sp, 252
#endif

		/* Save all the key general purpose registers */
		sw $ra,   4($sp)
20002e5c:	afbf0004 	sw	ra,4(sp)
        sw $t9,   8($sp)
20002e60:	afb90008 	sw	t9,8(sp)
        sw $t8,  12($sp)
20002e64:	afb8000c 	sw	t8,12(sp)
        sw $s7,  16($sp)
20002e68:	afb70010 	sw	s7,16(sp)
        sw $s6,  20($sp)
20002e6c:	afb60014 	sw	s6,20(sp)
        sw $s5,  24($sp)
20002e70:	afb50018 	sw	s5,24(sp)
        sw $s4,  28($sp)
20002e74:	afb4001c 	sw	s4,28(sp)
        sw $s3,  32($sp)
20002e78:	afb30020 	sw	s3,32(sp)
        sw $s2,  36($sp)
20002e7c:	afb20024 	sw	s2,36(sp)
        sw $s1,  40($sp)
20002e80:	afb10028 	sw	s1,40(sp)
        sw $s0,  44($sp)
20002e84:	afb0002c 	sw	s0,44(sp)
        sw $t7,  48($sp)
20002e88:	afaf0030 	sw	t7,48(sp)
        sw $t6,  52($sp)
20002e8c:	afae0034 	sw	t6,52(sp)
        sw $t5,  56($sp)
20002e90:	afad0038 	sw	t5,56(sp)
        sw $t4,  60($sp)
20002e94:	afac003c 	sw	t4,60(sp)
        sw $t3,  64($sp)
20002e98:	afab0040 	sw	t3,64(sp)
        sw $t2,  68($sp)
20002e9c:	afaa0044 	sw	t2,68(sp)
        sw $t1,  72($sp)
20002ea0:	afa90048 	sw	t1,72(sp)
        sw $t0,  76($sp)
20002ea4:	afa8004c 	sw	t0,76(sp)
        sw $a3,  80($sp)
20002ea8:	afa70050 	sw	a3,80(sp)
        sw $a2,  84($sp)
20002eac:	afa60054 	sw	a2,84(sp)
        sw $a1,  88($sp)
20002eb0:	afa50058 	sw	a1,88(sp)
        sw $a0,  92($sp)
20002eb4:	afa4005c 	sw	a0,92(sp)
        sw $v1,  96($sp)
20002eb8:	afa30060 	sw	v1,96(sp)
        sw $v0, 100($sp)
20002ebc:	afa20064 	sw	v0,100(sp)
        sw $at, 104($sp)
20002ec0:	afa10068 	sw	at,104(sp)
        sw $k1, 108($sp)
20002ec4:	afbb006c 	sw	k1,108(sp)
		swc1 $f31, 236($sp)
		sw $t1, 240($sp)
#endif

        /* Get the Return Address (EPC) */
        mfc0 $k0, $14
20002ec8:	401a7000 	mfc0	k0,c0_epc

		/* Store the stack frame */
#ifndef FPU
		sw $fp, 112($sp)
20002ecc:	afbe0070 	sw	s8,112(sp)
		sw $k0, 116($sp)
20002ed0:	afba0074 	sw	k0,116(sp)
#else
		sw $fp, 244($sp)
		sw $k0, 248($sp)
#endif
		move $fp,$sp
20002ed4:	03a0f021 	move	s8,sp

		/* Clear pending interrupts */
		mfc0 $26,$13
20002ed8:	401a6800 	mfc0	k0,c0_cause
        nop
20002edc:	00000000 	nop
        li   $26,0xFF00
20002ee0:	341aff00 	li	k0,0xff00
        mtc0 $26,$13
20002ee4:	409a6800 	mtc0	k0,c0_cause

 		subu $sp, 24
20002ee8:	27bdffe8 	addiu	sp,sp,-24

		/* Call C handler */
 		jal   Handle_Interrupts
20002eec:	0c000ed8 	jal	20003b60 <Handle_Interrupts>
        nop
20002ef0:	00000000 	nop

        addu $sp, 24
20002ef4:	27bd0018 	addiu	sp,sp,24
		lwc1 $f31, 236($sp)
		ctc1 $t0, $31
#endif

		/* Restore all the key general purpose registers */
		lw $ra,   4($sp)
20002ef8:	8fbf0004 	lw	ra,4(sp)
        lw $t9,   8($sp)
20002efc:	8fb90008 	lw	t9,8(sp)
        lw $t8,  12($sp)
20002f00:	8fb8000c 	lw	t8,12(sp)
        lw $s7,  16($sp)
20002f04:	8fb70010 	lw	s7,16(sp)
        lw $s6,  20($sp)
20002f08:	8fb60014 	lw	s6,20(sp)
        lw $s5,  24($sp)
20002f0c:	8fb50018 	lw	s5,24(sp)
        lw $s4,  28($sp)
20002f10:	8fb4001c 	lw	s4,28(sp)
        lw $s3,  32($sp)
20002f14:	8fb30020 	lw	s3,32(sp)
        lw $s2,  36($sp)
20002f18:	8fb20024 	lw	s2,36(sp)
        lw $s1,  40($sp)
20002f1c:	8fb10028 	lw	s1,40(sp)
        lw $s0,  44($sp)
20002f20:	8fb0002c 	lw	s0,44(sp)
        lw $t7,  48($sp)
20002f24:	8faf0030 	lw	t7,48(sp)
        lw $t6,  52($sp)
20002f28:	8fae0034 	lw	t6,52(sp)
        lw $t5,  56($sp)
20002f2c:	8fad0038 	lw	t5,56(sp)
        lw $t4,  60($sp)
20002f30:	8fac003c 	lw	t4,60(sp)
        lw $t3,  64($sp)
20002f34:	8fab0040 	lw	t3,64(sp)
        lw $t2,  68($sp)
20002f38:	8faa0044 	lw	t2,68(sp)
        lw $t1,  72($sp)
20002f3c:	8fa90048 	lw	t1,72(sp)
        lw $t0,  76($sp)
20002f40:	8fa8004c 	lw	t0,76(sp)
        lw $a3,  80($sp)
20002f44:	8fa70050 	lw	a3,80(sp)
        lw $a2,  84($sp)
20002f48:	8fa60054 	lw	a2,84(sp)
        lw $a1,  88($sp)
20002f4c:	8fa50058 	lw	a1,88(sp)
        lw $a0,  92($sp)
20002f50:	8fa4005c 	lw	a0,92(sp)
        lw $v1,  96($sp)
20002f54:	8fa30060 	lw	v1,96(sp)
        lw $v0, 100($sp)
20002f58:	8fa20064 	lw	v0,100(sp)
        lw $at, 104($sp)
20002f5c:	8fa10068 	lw	at,104(sp)
        lw $k0, 108($sp)
20002f60:	8fba006c 	lw	k0,108(sp)

#ifndef FPU
		/* Restore the stack frame */
		lw	$fp,112($sp)
20002f64:	8fbe0070 	lw	s8,112(sp)

        /* Get the Return Address (EPC) */
        lw $k1, 116($sp)
20002f68:	8fbb0074 	lw	k1,116(sp)
        
        /* Restore the stack pointer */
        addu $sp, 120
20002f6c:	27bd0078 	addiu	sp,sp,120

        /* Restore the stack pointer */
        addu $sp, 252
#endif
        /* Load the User Stack Pointer */
        move $sp, $k0
20002f70:	0340e821 	move	sp,k0

        /* Return from interrupt */
        j  $k1
20002f74:	03600008 	jr	k1

20002f78 <End_IRQ_Ptr>:
End_IRQ_Ptr:
        rfe
20002f78:	42000010                                ...B

20002f7c <Enable_Interrupts>:
	.global Enable_Interrupts
	.ent Enable_Interrupts

        .set noreorder
Enable_Interrupts:
        addiu   $29, $29, -24
20002f7c:	27bdffe8 	addiu	sp,sp,-24
        .frame $29, 24, $31
        sw   $8, 4($29)
20002f80:	afa80004 	sw	t0,4(sp)

        mfc0   $8, $12
20002f84:	40086000 	mfc0	t0,c0_sr
        nop
20002f88:	00000000 	nop
        ori   $8, $8, 0x01
20002f8c:	35080001 	ori	t0,t0,0x1
        nop
20002f90:	00000000 	nop
        mtc0   $8, $12
20002f94:	40886000 	mtc0	t0,c0_sr
        nop
20002f98:	00000000 	nop

        lw   $8, 4($29)
20002f9c:	8fa80004 	lw	t0,4(sp)
        addiu   $29, $29, 24
20002fa0:	27bd0018 	addiu	sp,sp,24
        jr   $31
20002fa4:	03e00008 	jr	ra
        nop
20002fa8:	00000000 	nop

20002fac <Disable_Interrupts>:
	.global Disable_Interrupts
	.ent Disable_Interrupts

    	.set noreorder
Disable_Interrupts:
        addiu   $29, $29, -24
20002fac:	27bdffe8 	addiu	sp,sp,-24
        .frame $29, 24, $31
        sw   $8, 4($29)
20002fb0:	afa80004 	sw	t0,4(sp)

        mfc0    $8, $12
20002fb4:	40086000 	mfc0	t0,c0_sr
        lui     $9, 0xFFFF
20002fb8:	3c09ffff 	lui	t1,0xffff
        ori     $9, 0xFFFE
20002fbc:	3529fffe 	ori	t1,t1,0xfffe
        nop
20002fc0:	00000000 	nop
        and     $8, $8, $9
20002fc4:	01094024 	and	t0,t0,t1
        nop
20002fc8:	00000000 	nop
        mtc0   $8, $12
20002fcc:	40886000 	mtc0	t0,c0_sr
        nop
20002fd0:	00000000 	nop

        lw   $8, 4($29)
20002fd4:	8fa80004 	lw	t0,4(sp)
        addiu   $29, $29, 24
20002fd8:	27bd0018 	addiu	sp,sp,24
        jr   $31
20002fdc:	03e00008 	jr	ra
        nop
20002fe0:	00000000 	nop

20002fe4 <Enter_Sleep_Mode>:
	.global Sleep_Ptr
	.ent Enter_Sleep_Mode

    	.set noreorder
Enter_Sleep_Mode:
        addiu   $29, $29, -24
20002fe4:	27bdffe8 	addiu	sp,sp,-24
        .frame $29, 24, $31
        sw   $8, 4($29)
20002fe8:	afa80004 	sw	t0,4(sp)

        mfc0   $8, $16
20002fec:	40088000 	mfc0	t0,$16
        ori    $8, $8, 1
20002ff0:	35080001 	ori	t0,t0,0x1

20002ff4 <Sleep_Ptr>:
Sleep_Ptr:
        mtc0   $8, $16
20002ff4:	40888000 00000000 8fa80004 27bd0018     ...@...........'
        nop

        lw   $8, 4($29)
        addiu   $29, $29, 24
        jr   $31
20003004:	03e00008 00000000                       ........

2000300c <LOG_Trigger_Breakpoint>:
	.section .text.LOG_Trigger_Breakpoint
	.global LOG_Trigger_Breakpoint
	.ent LOG_Trigger_Breakpoint
	
LOG_Trigger_Breakpoint:
	jr $31
2000300c:	03e00008 	jr	ra
20003010:	00000000 	nop

20003014 <Scheduler_Tick>:

void Scheduler_Tick(void)
{
#if (Config_Hardware_Scheduler != TRUE)
#if (Config_Logging == TRUE)
	Log_Tick_Start(current_task);
20003014:	8f840004 	lw	a0,4(gp)

// Found in Scheduler_Tick, below.
extern void Hybrid_End_Label(void);

void Scheduler_Tick(void)
{
20003018:	27bdffd0 	addiu	sp,sp,-48
2000301c:	afb60028 	sw	s6,40(sp)
20003020:	afb50024 	sw	s5,36(sp)
20003024:	afb40020 	sw	s4,32(sp)
20003028:	afb3001c 	sw	s3,28(sp)
2000302c:	afb20018 	sw	s2,24(sp)
20003030:	afb00010 	sw	s0,16(sp)
20003034:	afbf002c 	sw	ra,44(sp)
#if (Config_Hardware_Scheduler != TRUE)
#if (Config_Logging == TRUE)
	Log_Tick_Start(current_task);
20003038:	0c000df5 	jal	200037d4 <Log_Tick_Start>
2000303c:	afb10014 	sw	s1,20(sp)
#endif

	system_time += tick_skip_time;
20003040:	8f820008 	lw	v0,8(gp)

	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
	{
		Tasks[i].delay_counter -= tick_skip_time;
20003044:	3c124000 	lui	s2,0x4000
#if (Config_Hardware_Scheduler != TRUE)
#if (Config_Logging == TRUE)
	Log_Tick_Start(current_task);
#endif

	system_time += tick_skip_time;
20003048:	24420001 	addiu	v0,v0,1
#if (Config_Hybrid_Tasks == TRUE)
		if (Task_Ready(i, TRUE))
		{
			Tasks[i].delay_counter = Tasks[i].period_reload;
#if (Config_Logging == TRUE)
			Log_Set_Address(TRUE, (uint32_t) Tasks[i].task_function,
2000304c:	3c162000 	lui	s6,0x2000
	Log_Tick_Start(current_task);
#endif

	system_time += tick_skip_time;

	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
20003050:	00008021 	move	s0,zero
#if (Config_Hardware_Scheduler != TRUE)
#if (Config_Logging == TRUE)
	Log_Tick_Start(current_task);
#endif

	system_time += tick_skip_time;
20003054:	af820008 	sw	v0,8(gp)

	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
	{
		Tasks[i].delay_counter -= tick_skip_time;
20003058:	26520158 	addiu	s2,s2,344
#if (Config_Hybrid_Tasks == TRUE)
		if (Task_Ready(i, TRUE))
		{
			Tasks[i].delay_counter = Tasks[i].period_reload;
#if (Config_Logging == TRUE)
			Log_Set_Address(TRUE, (uint32_t) Tasks[i].task_function,
2000305c:	26d630e8 	addiu	s6,s6,12520
	Log_Tick_Start(current_task);
#endif

	system_time += tick_skip_time;

	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
20003060:	8f95ffa4 	lw	s5,-92(gp)
	{
		Tasks[i].delay_counter -= tick_skip_time;
20003064:	24140003 	li	s4,3
	Log_Tick_Start(current_task);
#endif

	system_time += tick_skip_time;

	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
20003068:	08000c3f 	j	200030fc <Hybrid_End_Label+0x14>
2000306c:	24130018 	li	s3,24
	{
		Tasks[i].delay_counter -= tick_skip_time;
20003070:	00001012 	mflo	v0
20003074:	24420001 	addiu	v0,v0,1
20003078:	000210c0 	sll	v0,v0,0x3

static inline boolean_t Task_Ready(const uint32_t task_index,
								   TTE_UNUSED const boolean_t in_isr)
{
	// Avoid short-circuiting, to eliminate jitter.
	boolean_t ready = Tasks[task_index].task_function != NULL;
2000307c:	02130018 	mult	s0,s3

	system_time += tick_skip_time;

	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
	{
		Tasks[i].delay_counter -= tick_skip_time;
20003080:	00521021 	addu	v0,v0,s2
20003084:	8c430000 	lw	v1,0(v0)
20003088:	00000000 	nop
2000308c:	2463ffff 	addiu	v1,v1,-1
20003090:	ac430000 	sw	v1,0(v0)

static inline boolean_t Task_Ready(const uint32_t task_index,
								   TTE_UNUSED const boolean_t in_isr)
{
	// Avoid short-circuiting, to eliminate jitter.
	boolean_t ready = Tasks[task_index].task_function != NULL;
20003094:	00008812 	mflo	s1
20003098:	02328821 	addu	s1,s1,s2
2000309c:	8e250000 	lw	a1,0(s1)
	ready &= Tasks[task_index].delay_counter <= 0;
200030a0:	8c430000 	lw	v1,0(v0)
200030a4:	0005282b 	sltu	a1,zero,a1
200030a8:	28630001 	slti	v1,v1,1
#if (Config_Hybrid_Tasks == TRUE)
	ready &= Tasks[task_index].exec_from_isr == in_isr;
200030ac:	92240014 	lbu	a0,20(s1)

	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
	{
		Tasks[i].delay_counter -= tick_skip_time;
#if (Config_Hybrid_Tasks == TRUE)
		if (Task_Ready(i, TRUE))
200030b0:	00651824 	and	v1,v1,a1
200030b4:	00641824 	and	v1,v1,a0
200030b8:	1060000f 	beqz	v1,200030f8 <Hybrid_End_Label+0x10>
200030bc:	00000000 	nop
		{
			Tasks[i].delay_counter = Tasks[i].period_reload;
200030c0:	8e230004 	lw	v1,4(s1)
#if (Config_Logging == TRUE)
			Log_Set_Address(TRUE, (uint32_t) Tasks[i].task_function,
200030c4:	24040001 	li	a0,1
	{
		Tasks[i].delay_counter -= tick_skip_time;
#if (Config_Hybrid_Tasks == TRUE)
		if (Task_Ready(i, TRUE))
		{
			Tasks[i].delay_counter = Tasks[i].period_reload;
200030c8:	ac430000 	sw	v1,0(v0)
#if (Config_Logging == TRUE)
			Log_Set_Address(TRUE, (uint32_t) Tasks[i].task_function,
200030cc:	8e250000 	lw	a1,0(s1)
200030d0:	0c000d60 	jal	20003580 <Log_Set_Address>
200030d4:	02c03021 	move	a2,s6
							(uint32_t) Hybrid_End_Label);
#endif

			(*Tasks[i].task_function)();
200030d8:	8e220000 	lw	v0,0(s1)
200030dc:	00000000 	nop
200030e0:	0040f809 	jalr	v0
200030e4:	00000000 	nop

200030e8 <Hybrid_End_Label>:

			__asm__ volatile(".global Hybrid_End_Label");
			__asm__ volatile("Hybrid_End_Label:");

#if (Config_Logging == TRUE)
			Log_Hybrid_Start(i);
200030e8:	0c000e1f 02002021 0c000e13 02002021     ....! ......! ..
	Log_Tick_Start(current_task);
#endif

	system_time += tick_skip_time;

	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
200030f8:	26100001 0215102b 1440ffdb 02140018     ...&+.....@.....
		}
#endif
	}

#if (Config_Logging == TRUE)
	Log_Reset_Addresses();
20003108:	0c000d46 00000000 8f840004 8fbf002c     F...........,...
	tick_skip_time = Next_Tick();
	Timer_Set_Match(Config_Scheduler_Timer_Number,
			tick_skip_time * single_tick_time);
#endif
#endif
}
20003118:	8fb60028 8fb50024 8fb40020 8fb3001c     (...$... .......
20003128:	8fb20018 8fb10014 8fb00010 08000eb0     ................
#endif
	}

#if (Config_Logging == TRUE)
	Log_Reset_Addresses();
	Log_Tick_End(current_task);
20003138:	27bd0030                                0..'

2000313c <Scheduler_Dispatch>:

// Found in Scheduler_Dispatch, below.
extern void Task_End_Label(void);

void Scheduler_Dispatch(void)
{
2000313c:	27bdffd0 	addiu	sp,sp,-48
20003140:	afb60028 	sw	s6,40(sp)
20003144:	afb3001c 	sw	s3,28(sp)
		{
			if (Task_Ready(i, FALSE))
			{
				Tasks[i].delay_counter = Tasks[i].period_reload;
#if (Config_Logging == TRUE)
				Log_Set_Address(FALSE, (uint32_t) Tasks[i].task_function,
20003148:	3c162000 	lui	s6,0x2000

static inline boolean_t Task_Ready(const uint32_t task_index,
								   TTE_UNUSED const boolean_t in_isr)
{
	// Avoid short-circuiting, to eliminate jitter.
	boolean_t ready = Tasks[task_index].task_function != NULL;
2000314c:	3c134000 	lui	s3,0x4000

// Found in Scheduler_Dispatch, below.
extern void Task_End_Label(void);

void Scheduler_Dispatch(void)
{
20003150:	afb50024 	sw	s5,36(sp)
20003154:	afb40020 	sw	s4,32(sp)
20003158:	afb20018 	sw	s2,24(sp)
2000315c:	afbf002c 	sw	ra,44(sp)
20003160:	afb10014 	sw	s1,20(sp)
20003164:	afb00010 	sw	s0,16(sp)
#if (Config_Hardware_Scheduler != TRUE)
	Disable_Interrupt();
20003168:	0c000ee8 	jal	20003ba0 <Disable_Interrupt>
2000316c:	26730158 	addiu	s3,s3,344
		{
			if (Task_Ready(i, FALSE))
			{
				Tasks[i].delay_counter = Tasks[i].period_reload;
#if (Config_Logging == TRUE)
				Log_Set_Address(FALSE, (uint32_t) Tasks[i].task_function,
20003170:	26d631fc 	addiu	s6,s6,12796
{
#if (Config_Hardware_Scheduler != TRUE)
	Disable_Interrupt();
	while (Update_Required())
	{
		for (uint32_t i = 0; i < Config_Num_Tasks; i++)
20003174:	8f92ffa4 	lw	s2,-92(gp)

static inline boolean_t Task_Ready(const uint32_t task_index,
								   TTE_UNUSED const boolean_t in_isr)
{
	// Avoid short-circuiting, to eliminate jitter.
	boolean_t ready = Tasks[task_index].task_function != NULL;
20003178:	24150018 	li	s5,24

void Scheduler_Dispatch(void)
{
#if (Config_Hardware_Scheduler != TRUE)
	Disable_Interrupt();
	while (Update_Required())
2000317c:	08000c8a 	j	20003228 <Task_End_Label+0x2c>
20003180:	24140003 	li	s4,3
static inline boolean_t Task_Ready(const uint32_t task_index,
								   TTE_UNUSED const boolean_t in_isr)
{
	// Avoid short-circuiting, to eliminate jitter.
	boolean_t ready = Tasks[task_index].task_function != NULL;
	ready &= Tasks[task_index].delay_counter <= 0;
20003184:	00001012 	mflo	v0
20003188:	24420001 	addiu	v0,v0,1
2000318c:	000210c0 	sll	v0,v0,0x3

static inline boolean_t Task_Ready(const uint32_t task_index,
								   TTE_UNUSED const boolean_t in_isr)
{
	// Avoid short-circuiting, to eliminate jitter.
	boolean_t ready = Tasks[task_index].task_function != NULL;
20003190:	02150018 	mult	s0,s5
	ready &= Tasks[task_index].delay_counter <= 0;
20003194:	00531021 	addu	v0,v0,s3

static inline boolean_t Task_Ready(const uint32_t task_index,
								   TTE_UNUSED const boolean_t in_isr)
{
	// Avoid short-circuiting, to eliminate jitter.
	boolean_t ready = Tasks[task_index].task_function != NULL;
20003198:	00008812 	mflo	s1
2000319c:	02338821 	addu	s1,s1,s3
200031a0:	8e230000 	lw	v1,0(s1)
	ready &= Tasks[task_index].delay_counter <= 0;
200031a4:	8c450000 	lw	a1,0(v0)
#if (Config_Hybrid_Tasks == TRUE)
	ready &= Tasks[task_index].exec_from_isr == in_isr;
200031a8:	92240014 	lbu	a0,20(s1)
static inline boolean_t Task_Ready(const uint32_t task_index,
								   TTE_UNUSED const boolean_t in_isr)
{
	// Avoid short-circuiting, to eliminate jitter.
	boolean_t ready = Tasks[task_index].task_function != NULL;
	ready &= Tasks[task_index].delay_counter <= 0;
200031ac:	28a50001 	slti	a1,a1,1
200031b0:	0003182b 	sltu	v1,zero,v1
	Disable_Interrupt();
	while (Update_Required())
	{
		for (uint32_t i = 0; i < Config_Num_Tasks; i++)
		{
			if (Task_Ready(i, FALSE))
200031b4:	00a31824 	and	v1,a1,v1
200031b8:	2c840001 	sltiu	a0,a0,1
200031bc:	00641824 	and	v1,v1,a0
200031c0:	10600015 	beqz	v1,20003218 <Task_End_Label+0x1c>
200031c4:	00000000 	nop
			{
				Tasks[i].delay_counter = Tasks[i].period_reload;
200031c8:	8e230004 	lw	v1,4(s1)
#if (Config_Logging == TRUE)
				Log_Set_Address(FALSE, (uint32_t) Tasks[i].task_function,
200031cc:	00002021 	move	a0,zero
	{
		for (uint32_t i = 0; i < Config_Num_Tasks; i++)
		{
			if (Task_Ready(i, FALSE))
			{
				Tasks[i].delay_counter = Tasks[i].period_reload;
200031d0:	ac430000 	sw	v1,0(v0)
#if (Config_Logging == TRUE)
				Log_Set_Address(FALSE, (uint32_t) Tasks[i].task_function,
200031d4:	8e250000 	lw	a1,0(s1)
200031d8:	0c000d60 	jal	20003580 <Log_Set_Address>
200031dc:	02c03021 	move	a2,s6
								(uint32_t) Task_End_Label);
#endif

				current_task = i;
200031e0:	af900004 	sw	s0,4(gp)
				Enable_Interrupt();
200031e4:	0c000eda 	jal	20003b68 <Enable_Interrupt>
200031e8:	00000000 	nop

				(*Tasks[i].task_function)();
200031ec:	8e220000 	lw	v0,0(s1)
200031f0:	00000000 	nop
200031f4:	0040f809 	jalr	v0
200031f8:	00000000 	nop

200031fc <Task_End_Label>:

				__asm__ volatile(".global Task_End_Label");
				__asm__ volatile("Task_End_Label:");

				Disable_Interrupt();
200031fc:	0c000ee8 00000000 02002021 0c000e67     ........! ..g...
				current_task = Config_Num_Tasks;

#if (Config_Logging == TRUE)
				Log_Task_Start(i);
2000320c:	af920004 0c000e5b 02002021 26100001     ....[...! .....&
{
#if (Config_Hardware_Scheduler != TRUE)
	Disable_Interrupt();
	while (Update_Required())
	{
		for (uint32_t i = 0; i < Config_Num_Tasks; i++)
2000321c:	0212102b 1440ffd8 02140018 0c000ee8     +.....@.........

static inline boolean_t Update_Required(void)
{
	boolean_t update = FALSE;

	Disable_Interrupt();
2000322c:	00000000 8f820008 00000000 10400005     ..............@.
	if (system_time > 0)
2000323c:	00008021 8f820008 24100001 2442ffff     !..........$..B$
	{
		update = TRUE;
		system_time--;
2000324c:	af820008 0c000eda 00000000 1600fff0     ................

void Scheduler_Dispatch(void)
{
#if (Config_Hardware_Scheduler != TRUE)
	Disable_Interrupt();
	while (Update_Required())
2000325c:	00008021 0c000d56 00000000 0c000eda     !...V...........

#if (Config_Logging == TRUE)
	Log_Idle();
#endif

	Enable_Interrupt();
2000326c:	00000000 8fbf002c 8fb60028 8fb50024     ....,...(...$...
	Enter_Sleep_Mode();
#endif
}
2000327c:	8fb40020 8fb3001c 8fb20018 8fb10014      ...............
2000328c:	8fb00010 08000bf9 27bd0030              ........0..'

20003298 <Shutdown_System>:

// Found in the startup.strt assembly file.
extern void Enter_Sleep_Mode(void);

void Shutdown_System(void)
{
20003298:	27bdffe8 	addiu	sp,sp,-24
2000329c:	afbf0014 	sw	ra,20(sp)
#if (Config_Hardware_Scheduler == TRUE)
	hwsch_register[0].enable = 0;
#endif

	Disable_Interrupt();
200032a0:	0c000ee8 	jal	20003ba0 <Disable_Interrupt>
200032a4:	00000000 	nop
	Enter_Sleep_Mode();
}
200032a8:	8fbf0014 	lw	ra,20(sp)
#if (Config_Hardware_Scheduler == TRUE)
	hwsch_register[0].enable = 0;
#endif

	Disable_Interrupt();
	Enter_Sleep_Mode();
200032ac:	08000bf9 	j	20002fe4 <Enter_Sleep_Mode>
200032b0:	27bd0018 	addiu	sp,sp,24

200032b4 <Scheduler_Start>:
}

///////////////////////////////////////////////////////////////////////////////

void Scheduler_Start(void)
{
200032b4:	27bdffe8 	addiu	sp,sp,-24
200032b8:	afbf0014 	sw	ra,20(sp)
#if (Config_Logging == TRUE && Config_Hardware_Scheduler != TRUE)
	Log_Init();
200032bc:	0c000e73 	jal	200039cc <Log_Init>
200032c0:	00000000 	nop
		tmrbuf_register[1] = (Config_Log_Buffer_Size / 8) - 1;
	}
	tmrbuf_register[2] = Config_Log_Num_Ticks;
#endif
#else
	Enable_Interrupt();
200032c4:	0c000eda 	jal	20003b68 <Enable_Interrupt>
200032c8:	00000000 	nop
#endif

	Timer_Start(Config_Scheduler_Timer_Number);
}
200032cc:	8fbf0014 	lw	ra,20(sp)
#endif
#else
	Enable_Interrupt();
#endif

	Timer_Start(Config_Scheduler_Timer_Number);
200032d0:	00002021 	move	a0,zero
200032d4:	08000f22 	j	20003c88 <Timer_Start>
200032d8:	27bd0018 	addiu	sp,sp,24

200032dc <Scheduler_Init>:

///////////////////////////////////////////////////////////////////////////////

void Scheduler_Init(const uint32_t tick_us)
{
	single_tick_time = Timer_Init(Config_Scheduler_Timer_Number, tick_us,
200032dc:	3c0602fa 	lui	a2,0x2fa
200032e0:	00802821 	move	a1,a0
#endif

///////////////////////////////////////////////////////////////////////////////

void Scheduler_Init(const uint32_t tick_us)
{
200032e4:	27bdffe8 	addiu	sp,sp,-24
	single_tick_time = Timer_Init(Config_Scheduler_Timer_Number, tick_us,
200032e8:	00002021 	move	a0,zero
200032ec:	34c6f080 	ori	a2,a2,0xf080
#endif

///////////////////////////////////////////////////////////////////////////////

void Scheduler_Init(const uint32_t tick_us)
{
200032f0:	afbf0014 	sw	ra,20(sp)
	single_tick_time = Timer_Init(Config_Scheduler_Timer_Number, tick_us,
200032f4:	0c000ef2 	jal	20003bc8 <Timer_Init>
200032f8:	24070001 	li	a3,1
		}
		hwsch_register[i].bvector = (uint32_t) Tasks[i].recovery_task;
		hwsch_register[i].aot = gpt - 1;
	}
#else
	Init_Interrupt();
200032fc:	0c000ecf 	jal	20003b3c <Init_Interrupt>
20003300:	af82000c 	sw	v0,12(gp)
	current_task = Config_Num_Tasks;
20003304:	8f83ffa4 	lw	v1,-92(gp)
	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
	{
		Tasks[i].delay_counter++;
20003308:	3c054000 	lui	a1,0x4000
		hwsch_register[i].bvector = (uint32_t) Tasks[i].recovery_task;
		hwsch_register[i].aot = gpt - 1;
	}
#else
	Init_Interrupt();
	current_task = Config_Num_Tasks;
2000330c:	af830004 	sw	v1,4(gp)
	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
	{
		Tasks[i].delay_counter++;
20003310:	24a50158 	addiu	a1,a1,344
		hwsch_register[i].bvector = (uint32_t) Tasks[i].recovery_task;
		hwsch_register[i].aot = gpt - 1;
	}
#else
	Init_Interrupt();
	current_task = Config_Num_Tasks;
20003314:	00001021 	move	v0,zero
	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
20003318:	08000cd1 	j	20003344 <Scheduler_Init+0x68>
2000331c:	24040003 	li	a0,3
20003320:	24420001 	addiu	v0,v0,1
	{
		Tasks[i].delay_counter++;
20003324:	00003012 	mflo	a2
20003328:	24c60001 	addiu	a2,a2,1
2000332c:	000630c0 	sll	a2,a2,0x3
20003330:	00c53021 	addu	a2,a2,a1
20003334:	8cc70000 	lw	a3,0(a2)
20003338:	00000000 	nop
2000333c:	24e70001 	addiu	a3,a3,1
20003340:	acc70000 	sw	a3,0(a2)
		hwsch_register[i].aot = gpt - 1;
	}
#else
	Init_Interrupt();
	current_task = Config_Num_Tasks;
	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
20003344:	0043302b 	sltu	a2,v0,v1
20003348:	14c0fff5 	bnez	a2,20003320 <Scheduler_Init+0x44>
2000334c:	00440018 	mult	v0,a0
	{
		Tasks[i].delay_counter++;
	}
#endif
}
20003350:	8fbf0014 	lw	ra,20(sp)
20003354:	00000000 	nop
20003358:	03e00008 	jr	ra
2000335c:	27bd0018 	addiu	sp,sp,24

20003360 <Write_32>:

///////////////////////////////////////////////////////////////////////////////

void Write_32(const uint32_t value)
{
	Log_Buffer[buffer_index++] = (uint8_t) (value >> 24);
20003360:	8f820020 	lw	v0,32(gp)
20003364:	3c034000 	lui	v1,0x4000
20003368:	2463086c 	addiu	v1,v1,2156
2000336c:	24450001 	addiu	a1,v0,1
20003370:	00043602 	srl	a2,a0,0x18
20003374:	00431021 	addu	v0,v0,v1
20003378:	a0460000 	sb	a2,0(v0)
2000337c:	af850020 	sw	a1,32(gp)
	Log_Buffer[buffer_index++] = (uint8_t) (value >> 16);
20003380:	8f820020 	lw	v0,32(gp)
20003384:	00043402 	srl	a2,a0,0x10
20003388:	24450001 	addiu	a1,v0,1
2000338c:	30c600ff 	andi	a2,a2,0xff
20003390:	00431021 	addu	v0,v0,v1
20003394:	a0460000 	sb	a2,0(v0)
20003398:	af850020 	sw	a1,32(gp)
	Log_Buffer[buffer_index++] = (uint8_t) (value >> 8);
2000339c:	8f820020 	lw	v0,32(gp)
200033a0:	00043202 	srl	a2,a0,0x8
200033a4:	24450001 	addiu	a1,v0,1
200033a8:	30c600ff 	andi	a2,a2,0xff
200033ac:	00431021 	addu	v0,v0,v1
200033b0:	a0460000 	sb	a2,0(v0)
200033b4:	af850020 	sw	a1,32(gp)
	Log_Buffer[buffer_index++] = (uint8_t) value;
200033b8:	8f820020 	lw	v0,32(gp)
200033bc:	308400ff 	andi	a0,a0,0xff
200033c0:	00431821 	addu	v1,v0,v1
200033c4:	24420001 	addiu	v0,v0,1
200033c8:	a0640000 	sb	a0,0(v1)
200033cc:	af820020 	sw	v0,32(gp)
}
200033d0:	03e00008 	jr	ra
200033d4:	00000000 	nop

200033d8 <Set_Watch>:

///////////////////////////////////////////////////////////////////////////////

void Set_Watch(const uint8_t number, const uint32_t value)
{
200033d8:	308400ff 	andi	a0,a0,0xff
	switch (number)
200033dc:	24020002 	li	v0,2
200033e0:	10820017 	beq	a0,v0,20003440 <Set_Watch+0x68>
200033e4:	2c820003 	sltiu	v0,a0,3
200033e8:	10400007 	beqz	v0,20003408 <Set_Watch+0x30>
200033ec:	24020004 	li	v0,4
200033f0:	1080000d 	beqz	a0,20003428 <Set_Watch+0x50>
200033f4:	24020001 	li	v0,1
200033f8:	1482001b 	bne	a0,v0,20003468 <Set_Watch+0x90>
200033fc:	00000000 	nop
20003400:	08000d0d 	j	20003434 <Set_Watch+0x5c>
20003404:	00000000 	nop
20003408:	10820013 	beq	a0,v0,20003458 <Set_Watch+0x80>
2000340c:	2c820004 	sltiu	v0,a0,4
20003410:	1440000e 	bnez	v0,2000344c <Set_Watch+0x74>
20003414:	24020005 	li	v0,5
20003418:	14820013 	bne	a0,v0,20003468 <Set_Watch+0x90>
2000341c:	00000000 	nop
20003420:	08000d19 	j	20003464 <Set_Watch+0x8c>
20003424:	00000000 	nop
	{
	case 0:
		__asm__ volatile ("mtc0 %0, $18"::"r"(value));
20003428:	40859000 	mtc0	a1,$18
		break;
2000342c:	03e00008 	jr	ra
20003430:	00000000 	nop
	case 1:
		__asm__ volatile ("mtc0 %0, $19"::"r"(value));
20003434:	40859800 	mtc0	a1,$19
		break;
20003438:	03e00008 	jr	ra
2000343c:	00000000 	nop
	case 2:
		__asm__ volatile ("mtc0 %0, $20"::"r"(value));
20003440:	4085a000 	mtc0	a1,$20
		break;
20003444:	03e00008 	jr	ra
20003448:	00000000 	nop
	case 3:
		__asm__ volatile ("mtc0 %0, $21"::"r"(value));
2000344c:	4085a800 	mtc0	a1,$21
		break;
20003450:	03e00008 	jr	ra
20003454:	00000000 	nop
	case 4:
		__asm__ volatile ("mtc0 %0, $22"::"r"(value));
20003458:	4085b000 	mtc0	a1,$22
		break;
2000345c:	03e00008 	jr	ra
20003460:	00000000 	nop
	case 5:
		__asm__ volatile ("mtc0 %0, $23"::"r"(value));
20003464:	4085b800 	mtc0	a1,$23
20003468:	03e00008 	jr	ra
2000346c:	00000000 	nop

20003470 <Get_Watch>:
}

///////////////////////////////////////////////////////////////////////////////

uint32_t Get_Watch(const uint8_t number)
{
20003470:	308400ff 	andi	a0,a0,0xff
	uint32_t value = 0;

	switch (number)
20003474:	24020002 	li	v0,2
20003478:	1082001b 	beq	a0,v0,200034e8 <Get_Watch+0x78>
2000347c:	00000000 	nop
20003480:	2c820003 	sltiu	v0,a0,3
20003484:	10400008 	beqz	v0,200034a8 <Get_Watch+0x38>
20003488:	24020004 	li	v0,4
2000348c:	10800010 	beqz	a0,200034d0 <Get_Watch+0x60>
20003490:	00000000 	nop
20003494:	24020001 	li	v0,1
20003498:	1482000b 	bne	a0,v0,200034c8 <Get_Watch+0x58>
2000349c:	00000000 	nop
200034a0:	08000d37 	j	200034dc <Get_Watch+0x6c>
200034a4:	00000000 	nop
200034a8:	10820015 	beq	a0,v0,20003500 <Get_Watch+0x90>
200034ac:	00000000 	nop
200034b0:	2c820004 	sltiu	v0,a0,4
200034b4:	1440000f 	bnez	v0,200034f4 <Get_Watch+0x84>
200034b8:	00000000 	nop
200034bc:	24020005 	li	v0,5
200034c0:	10820012 	beq	a0,v0,2000350c <Get_Watch+0x9c>
200034c4:	00000000 	nop
200034c8:	03e00008 	jr	ra
200034cc:	00001021 	move	v0,zero
	{
	case 0:
		__asm__ volatile ("mfc0 %0, $18":"=r"(value));
200034d0:	40029000 	mfc0	v0,$18
		break;
200034d4:	03e00008 	jr	ra
200034d8:	00000000 	nop
	case 1:
		__asm__ volatile ("mfc0 %0, $19":"=r"(value));
200034dc:	40029800 	mfc0	v0,$19
		break;
200034e0:	03e00008 	jr	ra
200034e4:	00000000 	nop
	case 2:
		__asm__ volatile ("mfc0 %0, $20":"=r"(value));
200034e8:	4002a000 	mfc0	v0,$20
		break;
200034ec:	03e00008 	jr	ra
200034f0:	00000000 	nop
	case 3:
		__asm__ volatile ("mfc0 %0, $21":"=r"(value));
200034f4:	4002a800 	mfc0	v0,$21
		break;
200034f8:	03e00008 	jr	ra
200034fc:	00000000 	nop
	case 4:
		__asm__ volatile ("mfc0 %0, $22":"=r"(value));
20003500:	4002b000 	mfc0	v0,$22
		break;
20003504:	03e00008 	jr	ra
20003508:	00000000 	nop
	case 5:
		__asm__ volatile ("mfc0 %0, $23":"=r"(value));
2000350c:	4002b800 	mfc0	v0,$23
	default:
		value = 0;
	}

	return value;
}
20003510:	03e00008 	jr	ra
20003514:	00000000 	nop

20003518 <Log_Reset_Addresses>:
extern void End_IRQ_Ptr(void);
extern void Sleep_Ptr(void);

void Log_Reset_Addresses(void)
{
	Set_Watch(0, 0x20000008);
20003518:	3c052000 	lui	a1,0x2000
// Found in the startup.strt assembly file.
extern void End_IRQ_Ptr(void);
extern void Sleep_Ptr(void);

void Log_Reset_Addresses(void)
{
2000351c:	27bdffe8 	addiu	sp,sp,-24
	Set_Watch(0, 0x20000008);
20003520:	34a50008 	ori	a1,a1,0x8
// Found in the startup.strt assembly file.
extern void End_IRQ_Ptr(void);
extern void Sleep_Ptr(void);

void Log_Reset_Addresses(void)
{
20003524:	afbf0014 	sw	ra,20(sp)
	Set_Watch(0, 0x20000008);
20003528:	0c000cf6 	jal	200033d8 <Set_Watch>
2000352c:	00002021 	move	a0,zero
	Set_Watch(1, (uint32_t) End_IRQ_Ptr);
20003530:	3c052000 	lui	a1,0x2000
20003534:	24a52f78 	addiu	a1,a1,12152
20003538:	0c000cf6 	jal	200033d8 <Set_Watch>
2000353c:	24040001 	li	a0,1
	Set_Watch(4, (uint32_t) Sleep_Ptr);
20003540:	3c052000 	lui	a1,0x2000
}
20003544:	8fbf0014 	lw	ra,20(sp)

void Log_Reset_Addresses(void)
{
	Set_Watch(0, 0x20000008);
	Set_Watch(1, (uint32_t) End_IRQ_Ptr);
	Set_Watch(4, (uint32_t) Sleep_Ptr);
20003548:	24a52ff4 	addiu	a1,a1,12276
2000354c:	24040004 	li	a0,4
20003550:	08000cf6 	j	200033d8 <Set_Watch>
20003554:	27bd0018 	addiu	sp,sp,24

20003558 <Log_Idle>:
}

///////////////////////////////////////////////////////////////////////////////

void Log_Idle(void)
{
20003558:	27bdffe8 	addiu	sp,sp,-24
2000355c:	afbf0014 	sw	ra,20(sp)
	Disable_Interrupt();
20003560:	0c000ee8 	jal	20003ba0 <Disable_Interrupt>
20003564:	00000000 	nop
	idle_index = Config_Num_Tasks;
20003568:	8f82ffa4 	lw	v0,-92(gp)
	Enable_Interrupt();
}
2000356c:	8fbf0014 	lw	ra,20(sp)
20003570:	27bd0018 	addiu	sp,sp,24
///////////////////////////////////////////////////////////////////////////////

void Log_Idle(void)
{
	Disable_Interrupt();
	idle_index = Config_Num_Tasks;
20003574:	af82fff4 	sw	v0,-12(gp)
	Enable_Interrupt();
20003578:	08000eda 	j	20003b68 <Enable_Interrupt>
2000357c:	00000000 	nop

20003580 <Log_Set_Address>:

///////////////////////////////////////////////////////////////////////////////

void Log_Set_Address(const boolean_t in_isr, const uint32_t start,
					 const uint32_t finish)
{
20003580:	27bdffe0 	addiu	sp,sp,-32
	idle_index = UINT8_MAX;
20003584:	240200ff 	li	v0,255

///////////////////////////////////////////////////////////////////////////////

void Log_Set_Address(const boolean_t in_isr, const uint32_t start,
					 const uint32_t finish)
{
20003588:	308400ff 	andi	a0,a0,0xff
2000358c:	afb10018 	sw	s1,24(sp)
20003590:	afb00014 	sw	s0,20(sp)
20003594:	afbf001c 	sw	ra,28(sp)
	idle_index = UINT8_MAX;
20003598:	af82fff4 	sw	v0,-12(gp)

///////////////////////////////////////////////////////////////////////////////

void Log_Set_Address(const boolean_t in_isr, const uint32_t start,
					 const uint32_t finish)
{
2000359c:	00c08021 	move	s0,a2
	idle_index = UINT8_MAX;
	if (in_isr)
200035a0:	1080000a 	beqz	a0,200035cc <Log_Set_Address+0x4c>
200035a4:	00a08821 	move	s1,a1
	{
		Set_Watch(1, start);
200035a8:	0c000cf6 	jal	200033d8 <Set_Watch>
200035ac:	24040001 	li	a0,1
		Set_Watch(0, finish);
200035b0:	02002821 	move	a1,s0
		Disable_Interrupt();
		Set_Watch(2, start);
		Set_Watch(3, finish);
		Enable_Interrupt();
	}
}
200035b4:	8fbf001c 	lw	ra,28(sp)
200035b8:	8fb10018 	lw	s1,24(sp)
200035bc:	8fb00014 	lw	s0,20(sp)
{
	idle_index = UINT8_MAX;
	if (in_isr)
	{
		Set_Watch(1, start);
		Set_Watch(0, finish);
200035c0:	00002021 	move	a0,zero
200035c4:	08000cf6 	j	200033d8 <Set_Watch>
200035c8:	27bd0020 	addiu	sp,sp,32
	}
	else
	{
		Disable_Interrupt();
200035cc:	0c000ee8 	jal	20003ba0 <Disable_Interrupt>
200035d0:	00000000 	nop
		Set_Watch(2, start);
200035d4:	02202821 	move	a1,s1
200035d8:	0c000cf6 	jal	200033d8 <Set_Watch>
200035dc:	24040002 	li	a0,2
		Set_Watch(3, finish);
200035e0:	02002821 	move	a1,s0
200035e4:	0c000cf6 	jal	200033d8 <Set_Watch>
200035e8:	24040003 	li	a0,3
		Enable_Interrupt();
	}
}
200035ec:	8fbf001c 	lw	ra,28(sp)
200035f0:	8fb10018 	lw	s1,24(sp)
200035f4:	8fb00014 	lw	s0,20(sp)
	else
	{
		Disable_Interrupt();
		Set_Watch(2, start);
		Set_Watch(3, finish);
		Enable_Interrupt();
200035f8:	08000eda 	j	20003b68 <Enable_Interrupt>
200035fc:	27bd0020 	addiu	sp,sp,32

20003600 <Check_Buffer>:
// Found in the startup.strt assembly file.
extern void LOG_Trigger_Breakpoint(void);

void Check_Buffer(const uint32_t size)
{
	if (Config_Log_Buffer_Size - buffer_index < size + 1)
20003600:	8f820020 	lw	v0,32(gp)
20003604:	240303e8 	li	v1,1000
20003608:	00621023 	subu	v0,v1,v0
2000360c:	24840001 	addiu	a0,a0,1

// Found in the startup.strt assembly file.
extern void LOG_Trigger_Breakpoint(void);

void Check_Buffer(const uint32_t size)
{
20003610:	27bdffe8 	addiu	sp,sp,-24
	if (Config_Log_Buffer_Size - buffer_index < size + 1)
20003614:	0044102b 	sltu	v0,v0,a0
20003618:	1040000a 	beqz	v0,20003644 <Check_Buffer+0x44>
2000361c:	afbf0014 	sw	ra,20(sp)
	{
		Log_Buffer[buffer_index] = 'z';
20003620:	8f830020 	lw	v1,32(gp)
20003624:	3c024000 	lui	v0,0x4000
20003628:	2442086c 	addiu	v0,v0,2156
2000362c:	00621021 	addu	v0,v1,v0
20003630:	2403007a 	li	v1,122
20003634:	a0430000 	sb	v1,0(v0)
		LOG_Trigger_Breakpoint();
20003638:	0c000c03 	jal	2000300c <LOG_Trigger_Breakpoint>
2000363c:	00000000 	nop
		buffer_index = 0;
20003640:	af800020 	sw	zero,32(gp)
	}
}
20003644:	8fbf0014 	lw	ra,20(sp)
20003648:	00000000 	nop
2000364c:	03e00008 	jr	ra
20003650:	27bd0018 	addiu	sp,sp,24

20003654 <Log_Task_Address>:
}

///////////////////////////////////////////////////////////////////////////////

void Log_Task_Address(const task_function_t task, const uint8_t priority)
{
20003654:	27bdffe0 	addiu	sp,sp,-32
20003658:	afb00010 	sw	s0,16(sp)
2000365c:	00808021 	move	s0,a0
	Check_Buffer(7);
20003660:	24040007 	li	a0,7
}

///////////////////////////////////////////////////////////////////////////////

void Log_Task_Address(const task_function_t task, const uint8_t priority)
{
20003664:	afbf001c 	sw	ra,28(sp)
20003668:	afb20018 	sw	s2,24(sp)
2000366c:	afb10014 	sw	s1,20(sp)
20003670:	30b200ff 	andi	s2,a1,0xff
	Check_Buffer(7);
20003674:	0c000d80 	jal	20003600 <Check_Buffer>
20003678:	3c114000 	lui	s1,0x4000

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
2000367c:	8f820020 	lw	v0,32(gp)
20003680:	2631086c 	addiu	s1,s1,2156
20003684:	24430001 	addiu	v1,v0,1
20003688:	24050058 	li	a1,88
2000368c:	00511021 	addu	v0,v0,s1

void Log_Task_Address(const task_function_t task, const uint8_t priority)
{
	Check_Buffer(7);
	Write_8('X');
	Write_32((uint32_t) task);
20003690:	02002021 	move	a0,s0

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
20003694:	a0450000 	sb	a1,0(v0)
20003698:	af830020 	sw	v1,32(gp)

void Log_Task_Address(const task_function_t task, const uint8_t priority)
{
	Check_Buffer(7);
	Write_8('X');
	Write_32((uint32_t) task);
2000369c:	0c000cd8 	jal	20003360 <Write_32>
200036a0:	00000000 	nop

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
200036a4:	8f820020 	lw	v0,32(gp)
200036a8:	24040070 	li	a0,112
200036ac:	24430001 	addiu	v1,v0,1
200036b0:	00511021 	addu	v0,v0,s1
200036b4:	a0440000 	sb	a0,0(v0)
200036b8:	af830020 	sw	v1,32(gp)
200036bc:	8f820020 	lw	v0,32(gp)
200036c0:	00000000 	nop
200036c4:	00518821 	addu	s1,v0,s1
200036c8:	a2320000 	sb	s2,0(s1)
	Check_Buffer(7);
	Write_8('X');
	Write_32((uint32_t) task);
	Write_8('p');
	Write_8(priority);
}
200036cc:	8fbf001c 	lw	ra,28(sp)

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
200036d0:	24420001 	addiu	v0,v0,1
	Check_Buffer(7);
	Write_8('X');
	Write_32((uint32_t) task);
	Write_8('p');
	Write_8(priority);
}
200036d4:	8fb20018 	lw	s2,24(sp)
200036d8:	8fb10014 	lw	s1,20(sp)
200036dc:	8fb00010 	lw	s0,16(sp)

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
200036e0:	af820020 	sw	v0,32(gp)
	Check_Buffer(7);
	Write_8('X');
	Write_32((uint32_t) task);
	Write_8('p');
	Write_8(priority);
}
200036e4:	03e00008 	jr	ra
200036e8:	27bd0020 	addiu	sp,sp,32

200036ec <Log_ISR_Time>:
///////////////////////////////////////////////////////////////////////////////

void Log_ISR_Time(const log_type_t log_type, const uint32_t task_index,
				  const uint32_t cycle_count)
{
	const uint32_t time = Get_Relative_Time(previous_isr_time, cycle_count);
200036ec:	8f820018 	lw	v0,24(gp)

///////////////////////////////////////////////////////////////////////////////

void Log_ISR_Time(const log_type_t log_type, const uint32_t task_index,
				  const uint32_t cycle_count)
{
200036f0:	27bdffd8 	addiu	sp,sp,-40

///////////////////////////////////////////////////////////////////////////////

uint32_t Get_Relative_Time(const uint32_t first, const uint32_t second)
{
	if (second >= first)
200036f4:	00c2182b 	sltu	v1,a2,v0

///////////////////////////////////////////////////////////////////////////////

void Log_ISR_Time(const log_type_t log_type, const uint32_t task_index,
				  const uint32_t cycle_count)
{
200036f8:	afb20020 	sw	s2,32(sp)
200036fc:	afb1001c 	sw	s1,28(sp)
20003700:	afb00018 	sw	s0,24(sp)
20003704:	afbf0024 	sw	ra,36(sp)
20003708:	00808021 	move	s0,a0
2000370c:	00a08821 	move	s1,a1

///////////////////////////////////////////////////////////////////////////////

uint32_t Get_Relative_Time(const uint32_t first, const uint32_t second)
{
	if (second >= first)
20003710:	10600003 	beqz	v1,20003720 <Log_ISR_Time+0x34>
20003714:	00c29023 	subu	s2,a2,v0
	{
		return second - first;
	}

	return second + (UINT32_MAX - first);
20003718:	00029027 	nor	s2,zero,v0
2000371c:	00d29021 	addu	s2,a2,s2

void Log_ISR_Time(const log_type_t log_type, const uint32_t task_index,
				  const uint32_t cycle_count)
{
	const uint32_t time = Get_Relative_Time(previous_isr_time, cycle_count);
	Check_Buffer(7);
20003720:	24040007 	li	a0,7
20003724:	0c000d80 	jal	20003600 <Check_Buffer>
20003728:	afa60010 	sw	a2,16(sp)

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
2000372c:	8f820020 	lw	v0,32(gp)
20003730:	3c034000 	lui	v1,0x4000
20003734:	2463086c 	addiu	v1,v1,2156
20003738:	24440001 	addiu	a0,v0,1
2000373c:	24050079 	li	a1,121
20003740:	00431021 	addu	v0,v0,v1
20003744:	a0450000 	sb	a1,0(v0)
20003748:	af840020 	sw	a0,32(gp)
2000374c:	8f820020 	lw	v0,32(gp)
				  const uint32_t cycle_count)
{
	const uint32_t time = Get_Relative_Time(previous_isr_time, cycle_count);
	Check_Buffer(7);
	Write_8('y');
	Write_8(task_index);
20003750:	322500ff 	andi	a1,s1,0xff

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
20003754:	24440001 	addiu	a0,v0,1
20003758:	00431021 	addu	v0,v0,v1
2000375c:	a0450000 	sb	a1,0(v0)
20003760:	af840020 	sw	a0,32(gp)
{
	const uint32_t time = Get_Relative_Time(previous_isr_time, cycle_count);
	Check_Buffer(7);
	Write_8('y');
	Write_8(task_index);
	Write_8(log_char[log_type]);
20003764:	2782fff8 	addiu	v0,gp,-8
20003768:	00508021 	addu	s0,v0,s0

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
2000376c:	8f820020 	lw	v0,32(gp)
{
	const uint32_t time = Get_Relative_Time(previous_isr_time, cycle_count);
	Check_Buffer(7);
	Write_8('y');
	Write_8(task_index);
	Write_8(log_char[log_type]);
20003770:	92050000 	lbu	a1,0(s0)

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
20003774:	00431821 	addu	v1,v0,v1
	Write_8(task_index);
	Write_8(log_char[log_type]);
	Write_32(time);

	// Update if task_index is not 255; nasty bit-fiddling to avoid branching.
	const int32_t update = task_index != 255;
20003778:	3a3100ff 	xori	s1,s1,0xff

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
2000377c:	24420001 	addiu	v0,v0,1
20003780:	a0650000 	sb	a1,0(v1)
	const uint32_t time = Get_Relative_Time(previous_isr_time, cycle_count);
	Check_Buffer(7);
	Write_8('y');
	Write_8(task_index);
	Write_8(log_char[log_type]);
	Write_32(time);
20003784:	02402021 	move	a0,s2

	// Update if task_index is not 255; nasty bit-fiddling to avoid branching.
	const int32_t update = task_index != 255;
20003788:	0011882b 	sltu	s1,zero,s1

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
2000378c:	af820020 	sw	v0,32(gp)
	const uint32_t time = Get_Relative_Time(previous_isr_time, cycle_count);
	Check_Buffer(7);
	Write_8('y');
	Write_8(task_index);
	Write_8(log_char[log_type]);
	Write_32(time);
20003790:	0c000cd8 	jal	20003360 <Write_32>
20003794:	00000000 	nop

	// Update if task_index is not 255; nasty bit-fiddling to avoid branching.
	const int32_t update = task_index != 255;
	const int32_t no_update = !update;
	previous_isr_time = (-update & cycle_count) |
20003798:	3a220001 	xori	v0,s1,0x1
2000379c:	8f830018 	lw	v1,24(gp)
200037a0:	8fa60010 	lw	a2,16(sp)
200037a4:	00118823 	negu	s1,s1
200037a8:	00021023 	negu	v0,v0
200037ac:	02263024 	and	a2,s1,a2
200037b0:	00431024 	and	v0,v0,v1
						(-no_update & previous_isr_time);
}
200037b4:	8fbf0024 	lw	ra,36(sp)
	Write_32(time);

	// Update if task_index is not 255; nasty bit-fiddling to avoid branching.
	const int32_t update = task_index != 255;
	const int32_t no_update = !update;
	previous_isr_time = (-update & cycle_count) |
200037b8:	00463025 	or	a2,v0,a2
						(-no_update & previous_isr_time);
}
200037bc:	8fb20020 	lw	s2,32(sp)
200037c0:	8fb1001c 	lw	s1,28(sp)
200037c4:	8fb00018 	lw	s0,24(sp)
	Write_32(time);

	// Update if task_index is not 255; nasty bit-fiddling to avoid branching.
	const int32_t update = task_index != 255;
	const int32_t no_update = !update;
	previous_isr_time = (-update & cycle_count) |
200037c8:	af860018 	sw	a2,24(gp)
						(-no_update & previous_isr_time);
}
200037cc:	03e00008 	jr	ra
200037d0:	27bd0028 	addiu	sp,sp,40

200037d4 <Log_Tick_Start>:
}

///////////////////////////////////////////////////////////////////////////////

void Log_Tick_Start(const uint32_t task_index)
{
200037d4:	27bdffe0 	addiu	sp,sp,-32
	Log_ISR_Time(LOG_INTERRUPT_END, last_index, Get_Watch(1));
200037d8:	8f850010 	lw	a1,16(gp)
}

///////////////////////////////////////////////////////////////////////////////

void Log_Tick_Start(const uint32_t task_index)
{
200037dc:	afb00018 	sw	s0,24(sp)
200037e0:	00808021 	move	s0,a0
	Log_ISR_Time(LOG_INTERRUPT_END, last_index, Get_Watch(1));
200037e4:	24040001 	li	a0,1
}

///////////////////////////////////////////////////////////////////////////////

void Log_Tick_Start(const uint32_t task_index)
{
200037e8:	afbf001c 	sw	ra,28(sp)
	Log_ISR_Time(LOG_INTERRUPT_END, last_index, Get_Watch(1));
200037ec:	0c000d1c 	jal	20003470 <Get_Watch>
200037f0:	afa50010 	sw	a1,16(sp)
200037f4:	8fa50010 	lw	a1,16(sp)
200037f8:	00403021 	move	a2,v0
200037fc:	0c000dbb 	jal	200036ec <Log_ISR_Time>
20003800:	24040003 	li	a0,3
	Log_ISR_Time(LOG_INTERRUPT_END, idle_index, Get_Watch(4));
20003804:	8f85fff4 	lw	a1,-12(gp)
20003808:	24040004 	li	a0,4
2000380c:	0c000d1c 	jal	20003470 <Get_Watch>
20003810:	afa50010 	sw	a1,16(sp)
20003814:	8fa50010 	lw	a1,16(sp)
20003818:	00403021 	move	a2,v0
2000381c:	0c000dbb 	jal	200036ec <Log_ISR_Time>
20003820:	24040003 	li	a0,3

	last_index = task_index;

	Log_ISR_Time(LOG_INTERRUPT_START, task_index, Get_Watch(0));
20003824:	00002021 	move	a0,zero
20003828:	0c000d1c 	jal	20003470 <Get_Watch>
2000382c:	af900010 	sw	s0,16(gp)
20003830:	00403021 	move	a2,v0
20003834:	02002821 	move	a1,s0
}
20003838:	8fbf001c 	lw	ra,28(sp)
2000383c:	8fb00018 	lw	s0,24(sp)
	Log_ISR_Time(LOG_INTERRUPT_END, last_index, Get_Watch(1));
	Log_ISR_Time(LOG_INTERRUPT_END, idle_index, Get_Watch(4));

	last_index = task_index;

	Log_ISR_Time(LOG_INTERRUPT_START, task_index, Get_Watch(0));
20003840:	24040002 	li	a0,2
20003844:	08000dbb 	j	200036ec <Log_ISR_Time>
20003848:	27bd0020 	addiu	sp,sp,32

2000384c <Log_Hybrid_End>:
}

///////////////////////////////////////////////////////////////////////////////

void Log_Hybrid_End(const uint32_t task_index)
{
2000384c:	27bdffe0 	addiu	sp,sp,-32
20003850:	00802821 	move	a1,a0
	Log_ISR_Time(LOG_HYBRID_END, task_index, Get_Watch(0));
20003854:	00002021 	move	a0,zero
}

///////////////////////////////////////////////////////////////////////////////

void Log_Hybrid_End(const uint32_t task_index)
{
20003858:	afbf001c 	sw	ra,28(sp)
	Log_ISR_Time(LOG_HYBRID_END, task_index, Get_Watch(0));
2000385c:	0c000d1c 	jal	20003470 <Get_Watch>
20003860:	afa50010 	sw	a1,16(sp)
20003864:	8fa50010 	lw	a1,16(sp)
}
20003868:	8fbf001c 	lw	ra,28(sp)

///////////////////////////////////////////////////////////////////////////////

void Log_Hybrid_End(const uint32_t task_index)
{
	Log_ISR_Time(LOG_HYBRID_END, task_index, Get_Watch(0));
2000386c:	00403021 	move	a2,v0
20003870:	24040005 	li	a0,5
20003874:	08000dbb 	j	200036ec <Log_ISR_Time>
20003878:	27bd0020 	addiu	sp,sp,32

2000387c <Log_Hybrid_Start>:
}

///////////////////////////////////////////////////////////////////////////////

void Log_Hybrid_Start(const uint32_t task_index)
{
2000387c:	27bdffe0 	addiu	sp,sp,-32
20003880:	00802821 	move	a1,a0
	Log_ISR_Time(LOG_HYBRID_START, task_index, Get_Watch(1));
20003884:	24040001 	li	a0,1
}

///////////////////////////////////////////////////////////////////////////////

void Log_Hybrid_Start(const uint32_t task_index)
{
20003888:	afbf001c 	sw	ra,28(sp)
	Log_ISR_Time(LOG_HYBRID_START, task_index, Get_Watch(1));
2000388c:	0c000d1c 	jal	20003470 <Get_Watch>
20003890:	afa50010 	sw	a1,16(sp)
20003894:	8fa50010 	lw	a1,16(sp)
}
20003898:	8fbf001c 	lw	ra,28(sp)

///////////////////////////////////////////////////////////////////////////////

void Log_Hybrid_Start(const uint32_t task_index)
{
	Log_ISR_Time(LOG_HYBRID_START, task_index, Get_Watch(1));
2000389c:	00403021 	move	a2,v0
200038a0:	24040004 	li	a0,4
200038a4:	08000dbb 	j	200036ec <Log_ISR_Time>
200038a8:	27bd0020 	addiu	sp,sp,32

200038ac <Log_Time>:
///////////////////////////////////////////////////////////////////////////////

void Log_Time(const log_type_t log_type, const uint32_t task_index,
			  const uint32_t cycle_count)
{
	const uint32_t time = Get_Relative_Time(previous_time, cycle_count);
200038ac:	8f820014 	lw	v0,20(gp)

///////////////////////////////////////////////////////////////////////////////

void Log_Time(const log_type_t log_type, const uint32_t task_index,
			  const uint32_t cycle_count)
{
200038b0:	27bdffd8 	addiu	sp,sp,-40

///////////////////////////////////////////////////////////////////////////////

uint32_t Get_Relative_Time(const uint32_t first, const uint32_t second)
{
	if (second >= first)
200038b4:	00c2182b 	sltu	v1,a2,v0

///////////////////////////////////////////////////////////////////////////////

void Log_Time(const log_type_t log_type, const uint32_t task_index,
			  const uint32_t cycle_count)
{
200038b8:	afb10020 	sw	s1,32(sp)
200038bc:	afb0001c 	sw	s0,28(sp)
200038c0:	afbf0024 	sw	ra,36(sp)
200038c4:	00808021 	move	s0,a0

///////////////////////////////////////////////////////////////////////////////

uint32_t Get_Relative_Time(const uint32_t first, const uint32_t second)
{
	if (second >= first)
200038c8:	10600003 	beqz	v1,200038d8 <Log_Time+0x2c>
200038cc:	00c28823 	subu	s1,a2,v0
	{
		return second - first;
	}

	return second + (UINT32_MAX - first);
200038d0:	00028827 	nor	s1,zero,v0
200038d4:	00d18821 	addu	s1,a2,s1

void Log_Time(const log_type_t log_type, const uint32_t task_index,
			  const uint32_t cycle_count)
{
	const uint32_t time = Get_Relative_Time(previous_time, cycle_count);
	Check_Buffer(7);
200038d8:	24040007 	li	a0,7
200038dc:	afa60014 	sw	a2,20(sp)
200038e0:	0c000d80 	jal	20003600 <Check_Buffer>
200038e4:	afa50010 	sw	a1,16(sp)

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
200038e8:	8f820020 	lw	v0,32(gp)
200038ec:	3c034000 	lui	v1,0x4000
200038f0:	2463086c 	addiu	v1,v1,2156
200038f4:	24440001 	addiu	a0,v0,1
200038f8:	24070079 	li	a3,121
200038fc:	00431021 	addu	v0,v0,v1
20003900:	a0470000 	sb	a3,0(v0)
20003904:	af840020 	sw	a0,32(gp)
20003908:	8f820020 	lw	v0,32(gp)
			  const uint32_t cycle_count)
{
	const uint32_t time = Get_Relative_Time(previous_time, cycle_count);
	Check_Buffer(7);
	Write_8('y');
	Write_8(task_index);
2000390c:	8fa50010 	lw	a1,16(sp)

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
20003910:	24440001 	addiu	a0,v0,1
			  const uint32_t cycle_count)
{
	const uint32_t time = Get_Relative_Time(previous_time, cycle_count);
	Check_Buffer(7);
	Write_8('y');
	Write_8(task_index);
20003914:	30a500ff 	andi	a1,a1,0xff

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
20003918:	00431021 	addu	v0,v0,v1
2000391c:	a0450000 	sb	a1,0(v0)
20003920:	af840020 	sw	a0,32(gp)
{
	const uint32_t time = Get_Relative_Time(previous_time, cycle_count);
	Check_Buffer(7);
	Write_8('y');
	Write_8(task_index);
	Write_8(log_char[log_type]);
20003924:	2782fff8 	addiu	v0,gp,-8
20003928:	00508021 	addu	s0,v0,s0

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
2000392c:	8f820020 	lw	v0,32(gp)
{
	const uint32_t time = Get_Relative_Time(previous_time, cycle_count);
	Check_Buffer(7);
	Write_8('y');
	Write_8(task_index);
	Write_8(log_char[log_type]);
20003930:	92050000 	lbu	a1,0(s0)

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
20003934:	00431821 	addu	v1,v0,v1
	const uint32_t time = Get_Relative_Time(previous_time, cycle_count);
	Check_Buffer(7);
	Write_8('y');
	Write_8(task_index);
	Write_8(log_char[log_type]);
	Write_32(time);
20003938:	02202021 	move	a0,s1

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
2000393c:	24420001 	addiu	v0,v0,1
20003940:	a0650000 	sb	a1,0(v1)
20003944:	af820020 	sw	v0,32(gp)
	const uint32_t time = Get_Relative_Time(previous_time, cycle_count);
	Check_Buffer(7);
	Write_8('y');
	Write_8(task_index);
	Write_8(log_char[log_type]);
	Write_32(time);
20003948:	0c000cd8 	jal	20003360 <Write_32>
2000394c:	00000000 	nop
	previous_time = cycle_count;
20003950:	8fa60014 	lw	a2,20(sp)
}
20003954:	8fbf0024 	lw	ra,36(sp)
20003958:	8fb10020 	lw	s1,32(sp)
2000395c:	8fb0001c 	lw	s0,28(sp)
	Check_Buffer(7);
	Write_8('y');
	Write_8(task_index);
	Write_8(log_char[log_type]);
	Write_32(time);
	previous_time = cycle_count;
20003960:	af860014 	sw	a2,20(gp)
}
20003964:	03e00008 	jr	ra
20003968:	27bd0028 	addiu	sp,sp,40

2000396c <Log_Task_End>:
}

///////////////////////////////////////////////////////////////////////////////

void Log_Task_End(const uint32_t task_index)
{
2000396c:	27bdffe0 	addiu	sp,sp,-32
20003970:	00802821 	move	a1,a0
	Log_Time(LOG_TASK_END, task_index, Get_Watch(3));
20003974:	24040003 	li	a0,3
}

///////////////////////////////////////////////////////////////////////////////

void Log_Task_End(const uint32_t task_index)
{
20003978:	afbf001c 	sw	ra,28(sp)
	Log_Time(LOG_TASK_END, task_index, Get_Watch(3));
2000397c:	0c000d1c 	jal	20003470 <Get_Watch>
20003980:	afa50010 	sw	a1,16(sp)
20003984:	8fa50010 	lw	a1,16(sp)
}
20003988:	8fbf001c 	lw	ra,28(sp)

///////////////////////////////////////////////////////////////////////////////

void Log_Task_End(const uint32_t task_index)
{
	Log_Time(LOG_TASK_END, task_index, Get_Watch(3));
2000398c:	00403021 	move	a2,v0
20003990:	24040001 	li	a0,1
20003994:	08000e2b 	j	200038ac <Log_Time>
20003998:	27bd0020 	addiu	sp,sp,32

2000399c <Log_Task_Start>:
}

///////////////////////////////////////////////////////////////////////////////

void Log_Task_Start(const uint32_t task_index)
{
2000399c:	27bdffe0 	addiu	sp,sp,-32
200039a0:	00802821 	move	a1,a0
	Log_Time(LOG_TASK_START, task_index, Get_Watch(2));
200039a4:	24040002 	li	a0,2
}

///////////////////////////////////////////////////////////////////////////////

void Log_Task_Start(const uint32_t task_index)
{
200039a8:	afbf001c 	sw	ra,28(sp)
	Log_Time(LOG_TASK_START, task_index, Get_Watch(2));
200039ac:	0c000d1c 	jal	20003470 <Get_Watch>
200039b0:	afa50010 	sw	a1,16(sp)
200039b4:	8fa50010 	lw	a1,16(sp)
}
200039b8:	8fbf001c 	lw	ra,28(sp)

///////////////////////////////////////////////////////////////////////////////

void Log_Task_Start(const uint32_t task_index)
{
	Log_Time(LOG_TASK_START, task_index, Get_Watch(2));
200039bc:	00403021 	move	a2,v0
200039c0:	00002021 	move	a0,zero
200039c4:	08000e2b 	j	200038ac <Log_Time>
200039c8:	27bd0020 	addiu	sp,sp,32

200039cc <Log_Init>:
}

///////////////////////////////////////////////////////////////////////////////

void Log_Init(void)
{
200039cc:	27bdffd8 	addiu	sp,sp,-40
	Check_Buffer(5);
200039d0:	24040005 	li	a0,5
}

///////////////////////////////////////////////////////////////////////////////

void Log_Init(void)
{
200039d4:	afbf0024 	sw	ra,36(sp)
200039d8:	afb30020 	sw	s3,32(sp)
200039dc:	afb2001c 	sw	s2,28(sp)
200039e0:	afb10018 	sw	s1,24(sp)
	Check_Buffer(5);
200039e4:	0c000d80 	jal	20003600 <Check_Buffer>
200039e8:	afb00014 	sw	s0,20(sp)

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
200039ec:	8f820020 	lw	v0,32(gp)
200039f0:	3c034000 	lui	v1,0x4000
200039f4:	2463086c 	addiu	v1,v1,2156
200039f8:	00431821 	addu	v1,v0,v1
200039fc:	24050057 	li	a1,87

void Log_Init(void)
{
	Check_Buffer(5);
	Write_8('W');
	Write_32(Config_Oscillator_Frequency);
20003a00:	3c0402fa 	lui	a0,0x2fa

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
20003a04:	24420001 	addiu	v0,v0,1
20003a08:	a0650000 	sb	a1,0(v1)

void Log_Init(void)
{
	Check_Buffer(5);
	Write_8('W');
	Write_32(Config_Oscillator_Frequency);
20003a0c:	3484f080 	ori	a0,a0,0xf080

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
20003a10:	af820020 	sw	v0,32(gp)

void Log_Init(void)
{
	Check_Buffer(5);
	Write_8('W');
	Write_32(Config_Oscillator_Frequency);
20003a14:	0c000cd8 	jal	20003360 <Write_32>
20003a18:	3c124000 	lui	s2,0x4000

	last_index = Config_Num_Tasks;
20003a1c:	8f93ffa4 	lw	s3,-92(gp)
20003a20:	00000000 	nop
20003a24:	af930010 	sw	s3,16(gp)

	uint32_t priority = 0;
	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
	{
		if (Tasks[i].exec_from_isr == TRUE)
20003a28:	26520158 	addiu	s2,s2,344
{
	Check_Buffer(5);
	Write_8('W');
	Write_32(Config_Oscillator_Frequency);

	last_index = Config_Num_Tasks;
20003a2c:	00008021 	move	s0,zero

	uint32_t priority = 0;
	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
20003a30:	08000e9d 	j	20003a74 <Log_Init+0xa8>
20003a34:	24110018 	li	s1,24
20003a38:	8f850010 	lw	a1,16(gp)
20003a3c:	00000000 	nop
	{
		if (Tasks[i].exec_from_isr == TRUE)
		{
			priority = (last_index * 2) - i;
20003a40:	00051040 	sll	v0,a1,0x1
		}
		else
		{
			priority = last_index - i;
20003a44:	00b02823 	subu	a1,a1,s0
		}
		Log_Task_Address(Tasks[i].task_function, priority);
20003a48:	00001812 	mflo	v1
20003a4c:	00721821 	addu	v1,v1,s2
	last_index = Config_Num_Tasks;

	uint32_t priority = 0;
	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
	{
		if (Tasks[i].exec_from_isr == TRUE)
20003a50:	90640014 	lbu	a0,20(v1)
20003a54:	00000000 	nop
20003a58:	10800002 	beqz	a0,20003a64 <Log_Init+0x98>
20003a5c:	00000000 	nop
		{
			priority = (last_index * 2) - i;
20003a60:	00502823 	subu	a1,v0,s0
		}
		else
		{
			priority = last_index - i;
		}
		Log_Task_Address(Tasks[i].task_function, priority);
20003a64:	8c640000 	lw	a0,0(v1)
20003a68:	0c000d95 	jal	20003654 <Log_Task_Address>
20003a6c:	30a500ff 	andi	a1,a1,0xff
	Write_32(Config_Oscillator_Frequency);

	last_index = Config_Num_Tasks;

	uint32_t priority = 0;
	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
20003a70:	26100001 	addiu	s0,s0,1
20003a74:	0213102b 	sltu	v0,s0,s3
20003a78:	1440ffef 	bnez	v0,20003a38 <Log_Init+0x6c>
20003a7c:	02110018 	mult	s0,s1
			priority = last_index - i;
		}
		Log_Task_Address(Tasks[i].task_function, priority);
	}

	Log_Reset_Addresses();
20003a80:	0c000d46 	jal	20003518 <Log_Reset_Addresses>
20003a84:	00000000 	nop

	previous_time = Get_Watch(0);
20003a88:	0c000d1c 	jal	20003470 <Get_Watch>
20003a8c:	00002021 	move	a0,zero
	previous_isr_time = previous_time;
	Log_Time(LOG_TASK_START, last_index, 0);
20003a90:	8f850010 	lw	a1,16(gp)
}
20003a94:	8fbf0024 	lw	ra,36(sp)
20003a98:	8fb30020 	lw	s3,32(sp)
20003a9c:	8fb2001c 	lw	s2,28(sp)
20003aa0:	8fb10018 	lw	s1,24(sp)
20003aa4:	8fb00014 	lw	s0,20(sp)

	Log_Reset_Addresses();

	previous_time = Get_Watch(0);
	previous_isr_time = previous_time;
	Log_Time(LOG_TASK_START, last_index, 0);
20003aa8:	00002021 	move	a0,zero
20003aac:	00003021 	move	a2,zero
}
20003ab0:	27bd0028 	addiu	sp,sp,40
	}

	Log_Reset_Addresses();

	previous_time = Get_Watch(0);
	previous_isr_time = previous_time;
20003ab4:	af820018 	sw	v0,24(gp)
	Log_Time(LOG_TASK_START, last_index, 0);
20003ab8:	08000e2b 	j	200038ac <Log_Time>
20003abc:	af820014 	sw	v0,20(gp)

20003ac0 <Log_Tick_End>:

///////////////////////////////////////////////////////////////////////////////

void Log_Tick_End(const uint32_t task_index)
{
	current_tick++;
20003ac0:	8f82001c 	lw	v0,28(gp)
}

///////////////////////////////////////////////////////////////////////////////

void Log_Tick_End(const uint32_t task_index)
{
20003ac4:	27bdffe8 	addiu	sp,sp,-24
	current_tick++;
20003ac8:	24420001 	addiu	v0,v0,1
	if (current_tick > Config_Log_Num_Ticks)
20003acc:	2c430065 	sltiu	v1,v0,101
}

///////////////////////////////////////////////////////////////////////////////

void Log_Tick_End(const uint32_t task_index)
{
20003ad0:	afb00010 	sw	s0,16(sp)
20003ad4:	afbf0014 	sw	ra,20(sp)
20003ad8:	00808021 	move	s0,a0
	current_tick++;
	if (current_tick > Config_Log_Num_Ticks)
20003adc:	1460000d 	bnez	v1,20003b14 <Log_Tick_End+0x54>
20003ae0:	af82001c 	sw	v0,28(gp)
	{
		Check_Buffer(1);
20003ae4:	0c000d80 	jal	20003600 <Check_Buffer>
20003ae8:	24040001 	li	a0,1

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
20003aec:	8f820020 	lw	v0,32(gp)
20003af0:	3c034000 	lui	v1,0x4000
20003af4:	2463086c 	addiu	v1,v1,2156
20003af8:	00431821 	addu	v1,v0,v1
20003afc:	24040067 	li	a0,103
20003b00:	24420001 	addiu	v0,v0,1
20003b04:	a0640000 	sb	a0,0(v1)
20003b08:	af820020 	sw	v0,32(gp)
	current_tick++;
	if (current_tick > Config_Log_Num_Ticks)
	{
		Check_Buffer(1);
		Write_8('g');
		LOG_Trigger_Breakpoint();
20003b0c:	0c000c03 	jal	2000300c <LOG_Trigger_Breakpoint>
20003b10:	00000000 	nop
	}

	if (task_index >= Config_Num_Tasks)
20003b14:	8f82ffa4 	lw	v0,-92(gp)
20003b18:	00000000 	nop
20003b1c:	0202802b 	sltu	s0,s0,v0
20003b20:	16000002 	bnez	s0,20003b2c <Log_Tick_End+0x6c>
20003b24:	240200ff 	li	v0,255
	{
		idle_index = UINT8_MAX;
20003b28:	af82fff4 	sw	v0,-12(gp)
	}
}
20003b2c:	8fbf0014 	lw	ra,20(sp)
20003b30:	8fb00010 	lw	s0,16(sp)
20003b34:	03e00008 	jr	ra
20003b38:	27bd0018 	addiu	sp,sp,24

20003b3c <Init_Interrupt>:
///////////////////////////////////////////////////////////////////////////////


void Init_Interrupt(void)
{
	TableBase = (uint32_t)InterruptHandler;
20003b3c:	3c022000 	lui	v0,0x2000
20003b40:	24422e48 	addiu	v0,v0,11848
20003b44:	af82ff64 	sw	v0,-156(gp)
 *
 */
uint32_t Status_Reg_Get()
{
	uint32_t regValue;
	__asm volatile("mfc0 %0, $12" : "=d" (regValue) :);
20003b48:	40026000 	mfc0	v0,c0_sr
20003b4c:	00000000 	nop
 *
 * \param[in] The value to write.
 */
void Status_Reg_Set(uint32_t value)
{
	__asm volatile("mtc0 %0, $12" :: "d" ((unsigned long)(value)));
20003b50:	34420700 	ori	v0,v0,0x700
20003b54:	40826000 	mtc0	v0,c0_sr

void Init_Interrupt(void)
{
	TableBase = (uint32_t)InterruptHandler;
	Enable_System_Interrupt(Config_Scheduler_Interrupt_Number);
}
20003b58:	03e00008 	jr	ra
20003b5c:	00000000 	nop

20003b60 <Handle_Interrupts>:

///////////////////////////////////////////////////////////////////////////////

void Handle_Interrupts(void)
{
	Scheduler_Tick();
20003b60:	08000c05 	j	20003014 <Scheduler_Tick>
20003b64:	00000000 	nop

20003b68 <Enable_Interrupt>:

///////////////////////////////////////////////////////////////////////////////

void Enable_Interrupt(void)
{
	if (nesting_level > 0)
20003b68:	8f820024 	lw	v0,36(gp)
20003b6c:	00000000 	nop
20003b70:	10400005 	beqz	v0,20003b88 <Enable_Interrupt+0x20>
20003b74:	00000000 	nop
	{
		nesting_level--;
20003b78:	2442ffff 	addiu	v0,v0,-1
20003b7c:	af820024 	sw	v0,36(gp)
	}

	if (nesting_level == 0)
20003b80:	8f820024 	lw	v0,36(gp)
20003b84:	00000000 	nop
20003b88:	14400003 	bnez	v0,20003b98 <Enable_Interrupt+0x30>
20003b8c:	00000000 	nop
	{
		Enable_Interrupts();
20003b90:	08000bdf 	j	20002f7c <Enable_Interrupts>
20003b94:	00000000 	nop
20003b98:	03e00008 	jr	ra
20003b9c:	00000000 	nop

20003ba0 <Disable_Interrupt>:
}

///////////////////////////////////////////////////////////////////////////////

void Disable_Interrupt(void)
{
20003ba0:	27bdffe8 	addiu	sp,sp,-24
20003ba4:	afbf0014 	sw	ra,20(sp)
	Disable_Interrupts();
20003ba8:	0c000beb 	jal	20002fac <Disable_Interrupts>
20003bac:	00000000 	nop
	nesting_level++;
20003bb0:	8f820024 	lw	v0,36(gp)
}
20003bb4:	8fbf0014 	lw	ra,20(sp)
///////////////////////////////////////////////////////////////////////////////

void Disable_Interrupt(void)
{
	Disable_Interrupts();
	nesting_level++;
20003bb8:	24420001 	addiu	v0,v0,1
20003bbc:	af820024 	sw	v0,36(gp)
}
20003bc0:	03e00008 	jr	ra
20003bc4:	27bd0018 	addiu	sp,sp,24

20003bc8 <Timer_Init>:
	Timer_Set_Prescalar(timer, 0);
	Timer_Clear(timer);
	Timer_Overflow_Clear(timer);

	const uint32_t clock_frequency = oscillator_frequency;
	const uint32_t timer_frequency = clock_frequency / clock_divider;
20003bc8:	14e00002 	bnez	a3,20003bd4 <Timer_Init+0xc>
20003bcc:	00c7001b 	divu	zero,a2,a3
20003bd0:	0007000d 	break	0x7

///////////////////////////////////////////////////////////////////////////////

uint32_t Timer_Init(const uint8_t timer, const uint32_t tick_us,
		const uint32_t oscillator_frequency, const uint32_t clock_divider)
{
20003bd4:	308400ff 	andi	a0,a0,0xff

///////////////////////////////////////////////////////////////////////////////

void Timer_Stop(const uint8_t timer)
{
	timer_register[timer].control &= ~control_start;
20003bd8:	3c028000 	lui	v0,0x8000
20003bdc:	00042200 	sll	a0,a0,0x8
20003be0:	00822021 	addu	a0,a0,v0
20003be4:	8c870000 	lw	a3,0(a0)
20003be8:	2402fffe 	li	v0,-2
20003bec:	00e21024 	and	v0,a3,v0
20003bf0:	ac820000 	sw	v0,0(a0)
///////////////////////////////////////////////////////////////////////////////

void Timer_Set_Prescalar(const uint8_t timer, const uint32_t prescalar)
{
	const uint32_t value = prescalar > 0 ? prescalar - 1 : 0;
	timer_register[timer].prescalar_match = value;
20003bf4:	ac800008 	sw	zero,8(a0)

///////////////////////////////////////////////////////////////////////////////

void Timer_Clear(const uint8_t timer)
{
	timer_register[timer].timer_counter = 0;
20003bf8:	ac80000c 	sw	zero,12(a0)

///////////////////////////////////////////////////////////////////////////////

void Timer_Overflow_Clear(const uint8_t timer)
{
	timer_register[timer].control &= ~control_overflow;
20003bfc:	8c870000 	lw	a3,0(a0)
	Timer_Clear(timer);
	Timer_Overflow_Clear(timer);

	const uint32_t clock_frequency = oscillator_frequency;
	const uint32_t timer_frequency = clock_frequency / clock_divider;
	Timer_Set_Prescalar(timer, timer_frequency / 1000000);
20003c00:	3c06000f 	lui	a2,0xf

///////////////////////////////////////////////////////////////////////////////

void Timer_Overflow_Clear(const uint8_t timer)
{
	timer_register[timer].control &= ~control_overflow;
20003c04:	2402fffd 	li	v0,-3
20003c08:	00e21024 	and	v0,a3,v0
	Timer_Clear(timer);
	Timer_Overflow_Clear(timer);

	const uint32_t clock_frequency = oscillator_frequency;
	const uint32_t timer_frequency = clock_frequency / clock_divider;
	Timer_Set_Prescalar(timer, timer_frequency / 1000000);
20003c0c:	34c64240 	ori	a2,a2,0x4240

///////////////////////////////////////////////////////////////////////////////

void Timer_Overflow_Clear(const uint8_t timer)
{
	timer_register[timer].control &= ~control_overflow;
20003c10:	ac820000 	sw	v0,0(a0)
	Timer_Set_Prescalar(timer, 0);
	Timer_Clear(timer);
	Timer_Overflow_Clear(timer);

	const uint32_t clock_frequency = oscillator_frequency;
	const uint32_t timer_frequency = clock_frequency / clock_divider;
20003c14:	00001812 	mflo	v1
	...
	Timer_Set_Prescalar(timer, timer_frequency / 1000000);

	const uint32_t match = timer_frequency / (timer_frequency / tick_us);
20003c20:	14a00002 	bnez	a1,20003c2c <Timer_Init+0x64>
20003c24:	0065001b 	divu	zero,v1,a1
20003c28:	0007000d 	break	0x7
20003c2c:	00002812 	mflo	a1
	...
20003c38:	14a00002 	bnez	a1,20003c44 <Timer_Init+0x7c>
20003c3c:	0065001b 	divu	zero,v1,a1
20003c40:	0007000d 	break	0x7
20003c44:	00001012 	mflo	v0

///////////////////////////////////////////////////////////////////////////////

void Timer_Set_Match(const uint8_t timer, const uint32_t match)
{
	const uint32_t value = match > 0 ? match - 1 : 0;
20003c48:	0002282b 	sltu	a1,zero,v0
20003c4c:	00052823 	negu	a1,a1
	Timer_Clear(timer);
	Timer_Overflow_Clear(timer);

	const uint32_t clock_frequency = oscillator_frequency;
	const uint32_t timer_frequency = clock_frequency / clock_divider;
	Timer_Set_Prescalar(timer, timer_frequency / 1000000);
20003c50:	14c00002 	bnez	a2,20003c5c <Timer_Init+0x94>
20003c54:	0066001b 	divu	zero,v1,a2
20003c58:	0007000d 	break	0x7

///////////////////////////////////////////////////////////////////////////////

void Timer_Set_Match(const uint8_t timer, const uint32_t match)
{
	const uint32_t value = match > 0 ? match - 1 : 0;
20003c5c:	2447ffff 	addiu	a3,v0,-1
20003c60:	00e53824 	and	a3,a3,a1
	Timer_Clear(timer);
	Timer_Overflow_Clear(timer);

	const uint32_t clock_frequency = oscillator_frequency;
	const uint32_t timer_frequency = clock_frequency / clock_divider;
	Timer_Set_Prescalar(timer, timer_frequency / 1000000);
20003c64:	00001812 	mflo	v1

///////////////////////////////////////////////////////////////////////////////

void Timer_Set_Prescalar(const uint8_t timer, const uint32_t prescalar)
{
	const uint32_t value = prescalar > 0 ? prescalar - 1 : 0;
20003c68:	0003282b 	sltu	a1,zero,v1
20003c6c:	00052823 	negu	a1,a1
20003c70:	2463ffff 	addiu	v1,v1,-1
20003c74:	00651824 	and	v1,v1,a1
	timer_register[timer].prescalar_match = value;
20003c78:	ac830008 	sw	v1,8(a0)
///////////////////////////////////////////////////////////////////////////////

void Timer_Set_Match(const uint8_t timer, const uint32_t match)
{
	const uint32_t value = match > 0 ? match - 1 : 0;
	timer_register[timer].timer_match = value;
20003c7c:	ac870010 	sw	a3,16(a0)

	const uint32_t match = timer_frequency / (timer_frequency / tick_us);
	Timer_Set_Match(timer, match);

	return match;
}
20003c80:	03e00008 	jr	ra
20003c84:	00000000 	nop

20003c88 <Timer_Start>:
}

///////////////////////////////////////////////////////////////////////////////

void Timer_Start(const uint8_t timer)
{
20003c88:	308400ff 	andi	a0,a0,0xff
	timer_register[timer].control |= control_start;
20003c8c:	3c028000 	lui	v0,0x8000
20003c90:	00042200 	sll	a0,a0,0x8
20003c94:	00822021 	addu	a0,a0,v0
20003c98:	8c820000 	lw	v0,0(a0)
20003c9c:	00000000 	nop
20003ca0:	34420001 	ori	v0,v0,0x1
20003ca4:	ac820000 	sw	v0,0(a0)
}
20003ca8:	03e00008 	jr	ra
20003cac:	00000000 	nop

20003cb0 <SPI_Init>:
static const uint32_t control_cpol     = (1 << 2);

///////////////////////////////////////////////////////////////////////////////

void SPI_Init(const uint8_t spi, const uint32_t mode, const uint32_t clock_divider)
{
20003cb0:	308400ff 	andi	a0,a0,0xff
	spi_register[spi].control = ((mode & 0x03) << 1);
20003cb4:	3c028000 	lui	v0,0x8000
20003cb8:	34420a00 	ori	v0,v0,0xa00
20003cbc:	00042200 	sll	a0,a0,0x8
20003cc0:	00822021 	addu	a0,a0,v0
20003cc4:	30a50003 	andi	a1,a1,0x3
	spi_register[spi].clk_div = clock_divider & 0xFFFFFFFC;
20003cc8:	2402fffc 	li	v0,-4
20003ccc:	00c21024 	and	v0,a2,v0

///////////////////////////////////////////////////////////////////////////////

void SPI_Init(const uint8_t spi, const uint32_t mode, const uint32_t clock_divider)
{
	spi_register[spi].control = ((mode & 0x03) << 1);
20003cd0:	00052840 	sll	a1,a1,0x1
20003cd4:	ac850000 	sw	a1,0(a0)
	spi_register[spi].clk_div = clock_divider & 0xFFFFFFFC;
20003cd8:	ac820004 	sw	v0,4(a0)
}
20003cdc:	03e00008 	jr	ra
20003ce0:	00000000 	nop

20003ce4 <SPI_Swap>:
}

///////////////////////////////////////////////////////////////////////////////

uint8_t SPI_Swap(const uint8_t spi, const uint8_t data)
{
20003ce4:	308400ff 	andi	a0,a0,0xff

///////////////////////////////////////////////////////////////////////////////

boolean_t SPI_Ready(const uint8_t spi)
{
	return spi_register[spi].control & 0x01;
20003ce8:	3c028000 	lui	v0,0x8000
20003cec:	00042200 	sll	a0,a0,0x8
20003cf0:	34420a00 	ori	v0,v0,0xa00
20003cf4:	00822021 	addu	a0,a0,v0
}

///////////////////////////////////////////////////////////////////////////////

uint8_t SPI_Swap(const uint8_t spi, const uint8_t data)
{
20003cf8:	30a500ff 	andi	a1,a1,0xff

///////////////////////////////////////////////////////////////////////////////

boolean_t SPI_Ready(const uint8_t spi)
{
	return spi_register[spi].control & 0x01;
20003cfc:	8c820000 	lw	v0,0(a0)
20003d00:	00000000 	nop

///////////////////////////////////////////////////////////////////////////////

uint8_t SPI_Swap(const uint8_t spi, const uint8_t data)
{
	while(!SPI_Ready(spi));
20003d04:	30420001 	andi	v0,v0,0x1
20003d08:	1040fffc 	beqz	v0,20003cfc <SPI_Swap+0x18>
20003d0c:	00000000 	nop
	spi_register[spi].data = data;
20003d10:	ac850008 	sw	a1,8(a0)

///////////////////////////////////////////////////////////////////////////////

boolean_t SPI_Ready(const uint8_t spi)
{
	return spi_register[spi].control & 0x01;
20003d14:	8c820000 	lw	v0,0(a0)
20003d18:	00000000 	nop

uint8_t SPI_Swap(const uint8_t spi, const uint8_t data)
{
	while(!SPI_Ready(spi));
	spi_register[spi].data = data;
	while(!SPI_Ready(spi));
20003d1c:	30420001 	andi	v0,v0,0x1
20003d20:	1040fffc 	beqz	v0,20003d14 <SPI_Swap+0x30>
20003d24:	00000000 	nop
	return spi_register[spi].data;
20003d28:	8c820008 	lw	v0,8(a0)
}
20003d2c:	03e00008 	jr	ra
20003d30:	304200ff 	andi	v0,v0,0xff

20003d34 <Segment_Enable>:
											(1 << 2), (1 << 3) };

///////////////////////////////////////////////////////////////////////////////

void Segment_Enable(const segment_digit_t digit)
{
20003d34:	a7a40000 	sh	a0,0(sp)
	TTE_DEBUG_ASSERT(digit.segment < 1);
	TTE_DEBUG_ASSERT(digit.digit < 4);

	segment_register[digit.segment].enabled |= segment_enabled[digit.digit];
20003d38:	3c038000 	lui	v1,0x8000
20003d3c:	308400ff 	andi	a0,a0,0xff
20003d40:	93a20001 	lbu	v0,1(sp)
20003d44:	34630900 	ori	v1,v1,0x900
20003d48:	00042200 	sll	a0,a0,0x8
20003d4c:	00832021 	addu	a0,a0,v1
20003d50:	3c034000 	lui	v1,0x4000
20003d54:	24630020 	addiu	v1,v1,32
20003d58:	00021080 	sll	v0,v0,0x2
20003d5c:	00431021 	addu	v0,v0,v1
20003d60:	8c420000 	lw	v0,0(v0)
20003d64:	8c830000 	lw	v1,0(a0)
20003d68:	00000000 	nop
20003d6c:	00621025 	or	v0,v1,v0
20003d70:	ac820000 	sw	v0,0(a0)
}
20003d74:	03e00008 	jr	ra
20003d78:	00000000 	nop

20003d7c <Segment_Write>:
}

///////////////////////////////////////////////////////////////////////////////

void Segment_Write(const segment_digit_t digit, const uint8_t value)
{
20003d7c:	a7a40000 	sh	a0,0(sp)
	TTE_DEBUG_ASSERT(digit.segment < 1);
	TTE_DEBUG_ASSERT(digit.digit < 4);

	segment_register[digit.segment].values &= ~segment_value[digit.digit];
20003d80:	93a20001 	lbu	v0,1(sp)
20003d84:	3c034000 	lui	v1,0x4000
20003d88:	00021080 	sll	v0,v0,0x2
20003d8c:	308400ff 	andi	a0,a0,0xff
20003d90:	24630010 	addiu	v1,v1,16
20003d94:	3c068000 	lui	a2,0x8000
20003d98:	00431821 	addu	v1,v0,v1
20003d9c:	34c60900 	ori	a2,a2,0x900
20003da0:	00042200 	sll	a0,a0,0x8
20003da4:	00862021 	addu	a0,a0,a2
20003da8:	8c630000 	lw	v1,0(v1)
20003dac:	8c860004 	lw	a2,4(a0)
20003db0:	00031827 	nor	v1,zero,v1
20003db4:	00661824 	and	v1,v1,a2
20003db8:	ac830004 	sw	v1,4(a0)
	segment_register[digit.segment].values |= (value << (digit.digit * 4));
20003dbc:	8c830004 	lw	v1,4(a0)
}

///////////////////////////////////////////////////////////////////////////////

void Segment_Write(const segment_digit_t digit, const uint8_t value)
{
20003dc0:	30a500ff 	andi	a1,a1,0xff
	TTE_DEBUG_ASSERT(digit.segment < 1);
	TTE_DEBUG_ASSERT(digit.digit < 4);

	segment_register[digit.segment].values &= ~segment_value[digit.digit];
	segment_register[digit.segment].values |= (value << (digit.digit * 4));
20003dc4:	00451004 	sllv	v0,a1,v0
20003dc8:	00431025 	or	v0,v0,v1
20003dcc:	ac820004 	sw	v0,4(a0)
}
20003dd0:	03e00008 	jr	ra
20003dd4:	00000000 	nop

20003dd8 <Segment_Set_Decimal>:

///////////////////////////////////////////////////////////////////////////////

void Segment_Set_Decimal(const segment_digit_t digit)
{
20003dd8:	a7a40000 	sh	a0,0(sp)
	TTE_DEBUG_ASSERT(digit.segment < 1);
	TTE_DEBUG_ASSERT(digit.digit < 4);

	segment_register[digit.segment].decimals |= segment_decimal[digit.digit];
20003ddc:	3c038000 	lui	v1,0x8000
20003de0:	308400ff 	andi	a0,a0,0xff
20003de4:	93a20001 	lbu	v0,1(sp)
20003de8:	34630900 	ori	v1,v1,0x900
20003dec:	00042200 	sll	a0,a0,0x8
20003df0:	00832021 	addu	a0,a0,v1
20003df4:	3c034000 	lui	v1,0x4000
20003df8:	24630000 	addiu	v1,v1,0
20003dfc:	00021080 	sll	v0,v0,0x2
20003e00:	00431021 	addu	v0,v0,v1
20003e04:	8c420000 	lw	v0,0(v0)
20003e08:	8c830008 	lw	v1,8(a0)
20003e0c:	00000000 	nop
20003e10:	00621025 	or	v0,v1,v0
20003e14:	ac820008 	sw	v0,8(a0)
}
20003e18:	03e00008 	jr	ra
20003e1c:	00000000 	nop

20003e20 <Segment_Clear_Decimal>:

///////////////////////////////////////////////////////////////////////////////

void Segment_Clear_Decimal(const segment_digit_t digit)
{
20003e20:	a7a40000 	sh	a0,0(sp)
	TTE_DEBUG_ASSERT(digit.segment < 1);
	TTE_DEBUG_ASSERT(digit.digit < 4);

	segment_register[digit.segment].decimals &= ~segment_decimal[digit.digit];
20003e24:	93a20001 	lbu	v0,1(sp)
20003e28:	3c034000 	lui	v1,0x4000
20003e2c:	24630000 	addiu	v1,v1,0
20003e30:	00021080 	sll	v0,v0,0x2
20003e34:	00431021 	addu	v0,v0,v1
20003e38:	308400ff 	andi	a0,a0,0xff
20003e3c:	3c038000 	lui	v1,0x8000
20003e40:	34630900 	ori	v1,v1,0x900
20003e44:	00042200 	sll	a0,a0,0x8
20003e48:	00832021 	addu	a0,a0,v1
20003e4c:	8c420000 	lw	v0,0(v0)
20003e50:	8c830008 	lw	v1,8(a0)
20003e54:	00021027 	nor	v0,zero,v0
20003e58:	00431024 	and	v0,v0,v1
20003e5c:	ac820008 	sw	v0,8(a0)
}
20003e60:	03e00008 	jr	ra
20003e64:	00000000 	nop

20003e68 <Device_Add>:
20003e68:	3c034000 	lui	v1,0x4000
20003e6c:	8c650444 	lw	a1,1092(v1)
20003e70:	00000000 	nop
20003e74:	14a00004 	bnez	a1,20003e88 <Device_Add+0x20>
20003e78:	2402ffff 	li	v0,-1
20003e7c:	ac640444 	sw	a0,1092(v1)
20003e80:	00001021 	move	v0,zero
20003e84:	3c034000 	lui	v1,0x4000
20003e88:	24630444 	addiu	v1,v1,1092
20003e8c:	8c650004 	lw	a1,4(v1)
20003e90:	00000000 	nop
20003e94:	14a00003 	bnez	a1,20003ea4 <Device_Add+0x3c>
20003e98:	00000000 	nop
20003e9c:	ac640004 	sw	a0,4(v1)
20003ea0:	24020001 	li	v0,1
20003ea4:	3c034000 	lui	v1,0x4000
20003ea8:	24630444 	addiu	v1,v1,1092
20003eac:	8c650008 	lw	a1,8(v1)
20003eb0:	00000000 	nop
20003eb4:	14a00003 	bnez	a1,20003ec4 <Device_Add+0x5c>
20003eb8:	00000000 	nop
20003ebc:	ac640008 	sw	a0,8(v1)
20003ec0:	24020002 	li	v0,2
20003ec4:	3c034000 	lui	v1,0x4000
20003ec8:	24630444 	addiu	v1,v1,1092
20003ecc:	8c65000c 	lw	a1,12(v1)
20003ed0:	00000000 	nop
20003ed4:	14a00003 	bnez	a1,20003ee4 <Device_Add+0x7c>
20003ed8:	00000000 	nop
20003edc:	ac64000c 	sw	a0,12(v1)
20003ee0:	24020003 	li	v0,3
20003ee4:	03e00008 	jr	ra
20003ee8:	00000000 	nop

20003eec <memcpy>:
20003eec:	00801021 	move	v0,a0
20003ef0:	08000fc2 	j	20003f08 <memcpy+0x1c>
20003ef4:	00001821 	move	v1,zero
20003ef8:	90e70000 	lbu	a3,0(a3)
20003efc:	24630001 	addiu	v1,v1,1
20003f00:	a0870000 	sb	a3,0(a0)
20003f04:	24c6ffff 	addiu	a2,a2,-1
20003f08:	00a33821 	addu	a3,a1,v1
20003f0c:	14c0fffa 	bnez	a2,20003ef8 <memcpy+0xc>
20003f10:	00432021 	addu	a0,v0,v1
20003f14:	03e00008 	jr	ra
20003f18:	00000000 	nop

20003f1c <__fixunsdfsi>:
20003f1c:	27bdffe0 	addiu	sp,sp,-32
20003f20:	afb00010 	sw	s0,16(sp)
20003f24:	3c104000 	lui	s0,0x4000
20003f28:	8e060030 	lw	a2,48(s0)
20003f2c:	8e070034 	lw	a3,52(s0)
20003f30:	afb30018 	sw	s3,24(sp)
20003f34:	afb20014 	sw	s2,20(sp)
20003f38:	afbf001c 	sw	ra,28(sp)
20003f3c:	00809021 	move	s2,a0
20003f40:	0c00121a 	jal	20004868 <__gedf2>
20003f44:	00a09821 	move	s3,a1
20003f48:	04410009 	bgez	v0,20003f70 <__fixunsdfsi+0x54>
20003f4c:	02402021 	move	a0,s2
20003f50:	0c001272 	jal	200049c8 <__fixdfsi>
20003f54:	02602821 	move	a1,s3
20003f58:	8fbf001c 	lw	ra,28(sp)
20003f5c:	8fb30018 	lw	s3,24(sp)
20003f60:	8fb20014 	lw	s2,20(sp)
20003f64:	8fb00010 	lw	s0,16(sp)
20003f68:	03e00008 	jr	ra
20003f6c:	27bd0020 	addiu	sp,sp,32
20003f70:	8e060030 	lw	a2,48(s0)
20003f74:	8e070034 	lw	a3,52(s0)
20003f78:	0c00111b 	jal	2000446c <__subdf3>
20003f7c:	02602821 	move	a1,s3
20003f80:	00602821 	move	a1,v1
20003f84:	0c001272 	jal	200049c8 <__fixdfsi>
20003f88:	00402021 	move	a0,v0
20003f8c:	8fbf001c 	lw	ra,28(sp)
20003f90:	3c038000 	lui	v1,0x8000
20003f94:	00431021 	addu	v0,v0,v1
20003f98:	8fb30018 	lw	s3,24(sp)
20003f9c:	8fb20014 	lw	s2,20(sp)
20003fa0:	8fb00010 	lw	s0,16(sp)
20003fa4:	03e00008 	jr	ra
20003fa8:	27bd0020 	addiu	sp,sp,32

20003fac <_fpadd_parts>:
20003fac:	8c820000 	lw	v0,0(a0)
20003fb0:	27bdffb8 	addiu	sp,sp,-72
20003fb4:	2c430002 	sltiu	v1,v0,2
20003fb8:	afb20028 	sw	s2,40(sp)
20003fbc:	afb10024 	sw	s1,36(sp)
20003fc0:	afb00020 	sw	s0,32(sp)
20003fc4:	afbf0044 	sw	ra,68(sp)
20003fc8:	afbe0040 	sw	s8,64(sp)
20003fcc:	afb7003c 	sw	s7,60(sp)
20003fd0:	afb60038 	sw	s6,56(sp)
20003fd4:	afb50034 	sw	s5,52(sp)
20003fd8:	afb40030 	sw	s4,48(sp)
20003fdc:	afb3002c 	sw	s3,44(sp)
20003fe0:	00808821 	move	s1,a0
20003fe4:	00a09021 	move	s2,a1
20003fe8:	14600052 	bnez	v1,20004134 <_fpadd_parts+0x188>
20003fec:	00c08021 	move	s0,a2
20003ff0:	8ca30000 	lw	v1,0(a1)
20003ff4:	00000000 	nop
20003ff8:	2c640002 	sltiu	a0,v1,2
20003ffc:	148000df 	bnez	a0,2000437c <_fpadd_parts+0x3d0>
20004000:	00000000 	nop
20004004:	24040004 	li	a0,4
20004008:	1044010e 	beq	v0,a0,20004444 <_fpadd_parts+0x498>
2000400c:	00000000 	nop
20004010:	106400da 	beq	v1,a0,2000437c <_fpadd_parts+0x3d0>
20004014:	00000000 	nop
20004018:	24040002 	li	a0,2
2000401c:	1064009e 	beq	v1,a0,20004298 <_fpadd_parts+0x2ec>
20004020:	00000000 	nop
20004024:	104400d5 	beq	v0,a0,2000437c <_fpadd_parts+0x3d0>
20004028:	00000000 	nop
2000402c:	8e330008 	lw	s3,8(s1)
20004030:	8ca40008 	lw	a0,8(a1)
20004034:	8e360010 	lw	s6,16(s1)
20004038:	02641023 	subu	v0,s3,a0
2000403c:	8e370014 	lw	s7,20(s1)
20004040:	8cb40010 	lw	s4,16(a1)
20004044:	8cb50014 	lw	s5,20(a1)
20004048:	044000a9 	bltz	v0,200042f0 <_fpadd_parts+0x344>
2000404c:	00401821 	move	v1,v0
20004050:	28650040 	slti	a1,v1,64
20004054:	10a00044 	beqz	a1,20004168 <_fpadd_parts+0x1bc>
20004058:	00000000 	nop
2000405c:	184000c9 	blez	v0,20004384 <_fpadd_parts+0x3d8>
20004060:	00000000 	nop
20004064:	30620020 	andi	v0,v1,0x20
20004068:	104000a7 	beqz	v0,20004308 <_fpadd_parts+0x35c>
2000406c:	00152040 	sll	a0,s5,0x1
20004070:	24050001 	li	a1,1
20004074:	00652804 	sllv	a1,a1,v1
20004078:	0075f006 	srlv	s8,s5,v1
2000407c:	afa00010 	sw	zero,16(sp)
20004080:	00002021 	move	a0,zero
20004084:	2482ffff 	addiu	v0,a0,-1
20004088:	24a3ffff 	addiu	v1,a1,-1
2000408c:	0044202b 	sltu	a0,v0,a0
20004090:	00832021 	addu	a0,a0,v1
20004094:	00954824 	and	t1,a0,s5
20004098:	00544024 	and	t0,v0,s4
2000409c:	01002021 	move	a0,t0
200040a0:	01202821 	move	a1,t1
200040a4:	00003021 	move	a2,zero
200040a8:	00003821 	move	a3,zero
200040ac:	afa80018 	sw	t0,24(sp)
200040b0:	0c0012b0 	jal	20004ac0 <__ucmpdi2>
200040b4:	afa9001c 	sw	t1,28(sp)
200040b8:	24030001 	li	v1,1
200040bc:	8fa80018 	lw	t0,24(sp)
200040c0:	8fa9001c 	lw	t1,28(sp)
200040c4:	10430003 	beq	v0,v1,200040d4 <_fpadd_parts+0x128>
200040c8:	00000000 	nop
200040cc:	24080001 	li	t0,1
200040d0:	00004821 	move	t1,zero
200040d4:	8fa20010 	lw	v0,16(sp)
200040d8:	8e430004 	lw	v1,4(s2)
200040dc:	0122a825 	or	s5,t1,v0
200040e0:	8e220004 	lw	v0,4(s1)
200040e4:	00000000 	nop
200040e8:	1443002a 	bne	v0,v1,20004194 <_fpadd_parts+0x1e8>
200040ec:	011ea025 	or	s4,t0,s8
200040f0:	02961821 	addu	v1,s4,s6
200040f4:	02b72021 	addu	a0,s5,s7
200040f8:	0074a02b 	sltu	s4,v1,s4
200040fc:	0284a021 	addu	s4,s4,a0
20004100:	ae140014 	sw	s4,20(s0)
20004104:	ae020004 	sw	v0,4(s0)
20004108:	8e020014 	lw	v0,20(s0)
2000410c:	ae030010 	sw	v1,16(s0)
20004110:	3c032000 	lui	v1,0x2000
20004114:	24040003 	li	a0,3
20004118:	0043182b 	sltu	v1,v0,v1
2000411c:	ae040000 	sw	a0,0(s0)
20004120:	ae130008 	sw	s3,8(s0)
20004124:	8e040010 	lw	a0,16(s0)
20004128:	1060004f 	beqz	v1,20004268 <_fpadd_parts+0x2bc>
2000412c:	00041842 	srl	v1,a0,0x1
20004130:	02008821 	move	s1,s0
20004134:	8fbf0044 	lw	ra,68(sp)
20004138:	02201021 	move	v0,s1
2000413c:	8fbe0040 	lw	s8,64(sp)
20004140:	8fb7003c 	lw	s7,60(sp)
20004144:	8fb60038 	lw	s6,56(sp)
20004148:	8fb50034 	lw	s5,52(sp)
2000414c:	8fb40030 	lw	s4,48(sp)
20004150:	8fb3002c 	lw	s3,44(sp)
20004154:	8fb20028 	lw	s2,40(sp)
20004158:	8fb10024 	lw	s1,36(sp)
2000415c:	8fb00020 	lw	s0,32(sp)
20004160:	03e00008 	jr	ra
20004164:	27bd0048 	addiu	sp,sp,72
20004168:	0093102a 	slt	v0,a0,s3
2000416c:	1440005d 	bnez	v0,200042e4 <_fpadd_parts+0x338>
20004170:	00000000 	nop
20004174:	00809821 	move	s3,a0
20004178:	0000b021 	move	s6,zero
2000417c:	0000b821 	move	s7,zero
20004180:	8e220004 	lw	v0,4(s1)
20004184:	8e430004 	lw	v1,4(s2)
20004188:	00000000 	nop
2000418c:	1043ffd9 	beq	v0,v1,200040f4 <_fpadd_parts+0x148>
20004190:	02961821 	addu	v1,s4,s6
20004194:	1040006a 	beqz	v0,20004340 <_fpadd_parts+0x394>
20004198:	02d41023 	subu	v0,s6,s4
2000419c:	02961023 	subu	v0,s4,s6
200041a0:	0282a02b 	sltu	s4,s4,v0
200041a4:	02b7b023 	subu	s6,s5,s7
200041a8:	02d4a023 	subu	s4,s6,s4
200041ac:	06800069 	bltz	s4,20004354 <_fpadd_parts+0x3a8>
200041b0:	00000000 	nop
200041b4:	ae130008 	sw	s3,8(s0)
200041b8:	ae000004 	sw	zero,4(s0)
200041bc:	ae020010 	sw	v0,16(s0)
200041c0:	ae140014 	sw	s4,20(s0)
200041c4:	2444ffff 	addiu	a0,v0,-1
200041c8:	0082282b 	sltu	a1,a0,v0
200041cc:	2683ffff 	addiu	v1,s4,-1
200041d0:	00a31821 	addu	v1,a1,v1
200041d4:	3c051000 	lui	a1,0x1000
200041d8:	0065282b 	sltu	a1,v1,a1
200041dc:	10a0001a 	beqz	a1,20004248 <_fpadd_parts+0x29c>
200041e0:	3c050fff 	lui	a1,0xfff
200041e4:	34a5ffff 	ori	a1,a1,0xffff
200041e8:	10650088 	beq	v1,a1,2000440c <_fpadd_parts+0x460>
200041ec:	2c84ffff 	sltiu	a0,a0,-1
200041f0:	3c090fff 	lui	t1,0xfff
200041f4:	8e050008 	lw	a1,8(s0)
200041f8:	3529ffff 	ori	t1,t1,0xffff
200041fc:	08001083 	j	2000420c <_fpadd_parts+0x260>
20004200:	3c081000 	lui	t0,0x1000
20004204:	1089004a 	beq	a0,t1,20004330 <_fpadd_parts+0x384>
20004208:	2cc6ffff 	sltiu	a2,a2,-1
2000420c:	000227c2 	srl	a0,v0,0x1f
20004210:	00141840 	sll	v1,s4,0x1
20004214:	00021040 	sll	v0,v0,0x1
20004218:	00831825 	or	v1,a0,v1
2000421c:	2446ffff 	addiu	a2,v0,-1
20004220:	00c2382b 	sltu	a3,a2,v0
20004224:	2464ffff 	addiu	a0,v1,-1
20004228:	00e42021 	addu	a0,a3,a0
2000422c:	0088382b 	sltu	a3,a0,t0
20004230:	0060a021 	move	s4,v1
20004234:	14e0fff3 	bnez	a3,20004204 <_fpadd_parts+0x258>
20004238:	24a5ffff 	addiu	a1,a1,-1
2000423c:	ae020010 	sw	v0,16(s0)
20004240:	ae030014 	sw	v1,20(s0)
20004244:	ae050008 	sw	a1,8(s0)
20004248:	8e020014 	lw	v0,20(s0)
2000424c:	3c032000 	lui	v1,0x2000
20004250:	24040003 	li	a0,3
20004254:	0043182b 	sltu	v1,v0,v1
20004258:	ae040000 	sw	a0,0(s0)
2000425c:	8e040010 	lw	a0,16(s0)
20004260:	1460ffb3 	bnez	v1,20004130 <_fpadd_parts+0x184>
20004264:	00041842 	srl	v1,a0,0x1
20004268:	8e050008 	lw	a1,8(s0)
2000426c:	000237c0 	sll	a2,v0,0x1f
20004270:	00c31825 	or	v1,a2,v1
20004274:	30840001 	andi	a0,a0,0x1
20004278:	00831825 	or	v1,a0,v1
2000427c:	00021042 	srl	v0,v0,0x1
20004280:	24a50001 	addiu	a1,a1,1
20004284:	ae030010 	sw	v1,16(s0)
20004288:	ae020014 	sw	v0,20(s0)
2000428c:	ae050008 	sw	a1,8(s0)
20004290:	0800104d 	j	20004134 <_fpadd_parts+0x188>
20004294:	02008821 	move	s1,s0
20004298:	1443ffa6 	bne	v0,v1,20004134 <_fpadd_parts+0x188>
2000429c:	00000000 	nop
200042a0:	8e230014 	lw	v1,20(s1)
200042a4:	8e270004 	lw	a3,4(s1)
200042a8:	8e260008 	lw	a2,8(s1)
200042ac:	8e25000c 	lw	a1,12(s1)
200042b0:	8e240010 	lw	a0,16(s1)
200042b4:	ae070004 	sw	a3,4(s0)
200042b8:	ae020000 	sw	v0,0(s0)
200042bc:	ae060008 	sw	a2,8(s0)
200042c0:	ae05000c 	sw	a1,12(s0)
200042c4:	ae040010 	sw	a0,16(s0)
200042c8:	ae030014 	sw	v1,20(s0)
200042cc:	8e220004 	lw	v0,4(s1)
200042d0:	8e430004 	lw	v1,4(s2)
200042d4:	02008821 	move	s1,s0
200042d8:	00621024 	and	v0,v1,v0
200042dc:	0800104d 	j	20004134 <_fpadd_parts+0x188>
200042e0:	ae020004 	sw	v0,4(s0)
200042e4:	0000a021 	move	s4,zero
200042e8:	08001060 	j	20004180 <_fpadd_parts+0x1d4>
200042ec:	0000a821 	move	s5,zero
200042f0:	00021823 	negu	v1,v0
200042f4:	28650040 	slti	a1,v1,64
200042f8:	10a0ff9b 	beqz	a1,20004168 <_fpadd_parts+0x1bc>
200042fc:	00000000 	nop
20004300:	08001017 	j	2000405c <_fpadd_parts+0xb0>
20004304:	00000000 	nop
20004308:	00031027 	nor	v0,zero,v1
2000430c:	00441004 	sllv	v0,a0,v0
20004310:	24040001 	li	a0,1
20004314:	0074f006 	srlv	s8,s4,v1
20004318:	00642004 	sllv	a0,a0,v1
2000431c:	00751806 	srlv	v1,s5,v1
20004320:	005ef025 	or	s8,v0,s8
20004324:	afa30010 	sw	v1,16(sp)
20004328:	08001021 	j	20004084 <_fpadd_parts+0xd8>
2000432c:	00002821 	move	a1,zero
20004330:	14c0ffb7 	bnez	a2,20004210 <_fpadd_parts+0x264>
20004334:	000227c2 	srl	a0,v0,0x1f
20004338:	08001090 	j	20004240 <_fpadd_parts+0x294>
2000433c:	ae020010 	sw	v0,16(s0)
20004340:	02c2b02b 	sltu	s6,s6,v0
20004344:	02f5a023 	subu	s4,s7,s5
20004348:	0296a023 	subu	s4,s4,s6
2000434c:	0681ff99 	bgez	s4,200041b4 <_fpadd_parts+0x208>
20004350:	00000000 	nop
20004354:	00021023 	negu	v0,v0
20004358:	0002182b 	sltu	v1,zero,v0
2000435c:	0014a023 	negu	s4,s4
20004360:	0283a023 	subu	s4,s4,v1
20004364:	24030001 	li	v1,1
20004368:	ae030004 	sw	v1,4(s0)
2000436c:	ae130008 	sw	s3,8(s0)
20004370:	ae020010 	sw	v0,16(s0)
20004374:	08001071 	j	200041c4 <_fpadd_parts+0x218>
20004378:	ae140014 	sw	s4,20(s0)
2000437c:	0800104d 	j	20004134 <_fpadd_parts+0x188>
20004380:	02408821 	move	s1,s2
20004384:	1040ff7e 	beqz	v0,20004180 <_fpadd_parts+0x1d4>
20004388:	30620020 	andi	v0,v1,0x20
2000438c:	10400023 	beqz	v0,2000441c <_fpadd_parts+0x470>
20004390:	02639821 	addu	s3,s3,v1
20004394:	24050001 	li	a1,1
20004398:	00652804 	sllv	a1,a1,v1
2000439c:	0077f006 	srlv	s8,s7,v1
200043a0:	00002021 	move	a0,zero
200043a4:	00001821 	move	v1,zero
200043a8:	2482ffff 	addiu	v0,a0,-1
200043ac:	0044202b 	sltu	a0,v0,a0
200043b0:	24a5ffff 	addiu	a1,a1,-1
200043b4:	00852021 	addu	a0,a0,a1
200043b8:	00974824 	and	t1,a0,s7
200043bc:	00564024 	and	t0,v0,s6
200043c0:	01002021 	move	a0,t0
200043c4:	01202821 	move	a1,t1
200043c8:	00003021 	move	a2,zero
200043cc:	00003821 	move	a3,zero
200043d0:	afa30014 	sw	v1,20(sp)
200043d4:	afa80018 	sw	t0,24(sp)
200043d8:	0c0012b0 	jal	20004ac0 <__ucmpdi2>
200043dc:	afa9001c 	sw	t1,28(sp)
200043e0:	24040001 	li	a0,1
200043e4:	8fa30014 	lw	v1,20(sp)
200043e8:	8fa80018 	lw	t0,24(sp)
200043ec:	8fa9001c 	lw	t1,28(sp)
200043f0:	10440003 	beq	v0,a0,20004400 <_fpadd_parts+0x454>
200043f4:	00000000 	nop
200043f8:	24080001 	li	t0,1
200043fc:	00004821 	move	t1,zero
20004400:	011eb025 	or	s6,t0,s8
20004404:	08001060 	j	20004180 <_fpadd_parts+0x1d4>
20004408:	0123b825 	or	s7,t1,v1
2000440c:	1480ff78 	bnez	a0,200041f0 <_fpadd_parts+0x244>
20004410:	00000000 	nop
20004414:	08001092 	j	20004248 <_fpadd_parts+0x29c>
20004418:	00000000 	nop
2000441c:	00172040 	sll	a0,s7,0x1
20004420:	00031027 	nor	v0,zero,v1
20004424:	00441004 	sllv	v0,a0,v0
20004428:	0076f006 	srlv	s8,s6,v1
2000442c:	24040001 	li	a0,1
20004430:	00642004 	sllv	a0,a0,v1
20004434:	005ef025 	or	s8,v0,s8
20004438:	00771806 	srlv	v1,s7,v1
2000443c:	080010ea 	j	200043a8 <_fpadd_parts+0x3fc>
20004440:	00002821 	move	a1,zero
20004444:	1462ff3b 	bne	v1,v0,20004134 <_fpadd_parts+0x188>
20004448:	00000000 	nop
2000444c:	8ca20004 	lw	v0,4(a1)
20004450:	8e230004 	lw	v1,4(s1)
20004454:	00000000 	nop
20004458:	1062ff36 	beq	v1,v0,20004134 <_fpadd_parts+0x188>
2000445c:	00000000 	nop
20004460:	3c114000 	lui	s1,0x4000
20004464:	0800104d 	j	20004134 <_fpadd_parts+0x188>
20004468:	26310040 	addiu	s1,s1,64

2000446c <__subdf3>:
2000446c:	27bdff88 	addiu	sp,sp,-120
20004470:	afb0006c 	sw	s0,108(sp)
20004474:	27b00020 	addiu	s0,sp,32
20004478:	afb10070 	sw	s1,112(sp)
2000447c:	afa40010 	sw	a0,16(sp)
20004480:	27b10038 	addiu	s1,sp,56
20004484:	afa50014 	sw	a1,20(sp)
20004488:	27a40010 	addiu	a0,sp,16
2000448c:	02002821 	move	a1,s0
20004490:	afbf0074 	sw	ra,116(sp)
20004494:	afa7001c 	sw	a3,28(sp)
20004498:	0c001392 	jal	20004e48 <__unpack_d>
2000449c:	afa60018 	sw	a2,24(sp)
200044a0:	27a40018 	addiu	a0,sp,24
200044a4:	0c001392 	jal	20004e48 <__unpack_d>
200044a8:	02202821 	move	a1,s1
200044ac:	8fa2003c 	lw	v0,60(sp)
200044b0:	02202821 	move	a1,s1
200044b4:	02002021 	move	a0,s0
200044b8:	27a60050 	addiu	a2,sp,80
200044bc:	38420001 	xori	v0,v0,0x1
200044c0:	0c000feb 	jal	20003fac <_fpadd_parts>
200044c4:	afa2003c 	sw	v0,60(sp)
200044c8:	0c0012ec 	jal	20004bb0 <__pack_d>
200044cc:	00402021 	move	a0,v0
200044d0:	8fbf0074 	lw	ra,116(sp)
200044d4:	8fb10070 	lw	s1,112(sp)
200044d8:	8fb0006c 	lw	s0,108(sp)
200044dc:	03e00008 	jr	ra
200044e0:	27bd0078 	addiu	sp,sp,120

200044e4 <__adddf3>:
200044e4:	27bdff88 	addiu	sp,sp,-120
200044e8:	afb10070 	sw	s1,112(sp)
200044ec:	27b10020 	addiu	s1,sp,32
200044f0:	afb0006c 	sw	s0,108(sp)
200044f4:	afa40010 	sw	a0,16(sp)
200044f8:	27b00038 	addiu	s0,sp,56
200044fc:	afa50014 	sw	a1,20(sp)
20004500:	27a40010 	addiu	a0,sp,16
20004504:	02202821 	move	a1,s1
20004508:	afbf0074 	sw	ra,116(sp)
2000450c:	afa7001c 	sw	a3,28(sp)
20004510:	0c001392 	jal	20004e48 <__unpack_d>
20004514:	afa60018 	sw	a2,24(sp)
20004518:	27a40018 	addiu	a0,sp,24
2000451c:	0c001392 	jal	20004e48 <__unpack_d>
20004520:	02002821 	move	a1,s0
20004524:	02202021 	move	a0,s1
20004528:	02002821 	move	a1,s0
2000452c:	0c000feb 	jal	20003fac <_fpadd_parts>
20004530:	27a60050 	addiu	a2,sp,80
20004534:	0c0012ec 	jal	20004bb0 <__pack_d>
20004538:	00402021 	move	a0,v0
2000453c:	8fbf0074 	lw	ra,116(sp)
20004540:	8fb10070 	lw	s1,112(sp)
20004544:	8fb0006c 	lw	s0,108(sp)
20004548:	03e00008 	jr	ra
2000454c:	27bd0078 	addiu	sp,sp,120

20004550 <__muldf3>:
20004550:	27bdff88 	addiu	sp,sp,-120
20004554:	afb0006c 	sw	s0,108(sp)
20004558:	27b00020 	addiu	s0,sp,32
2000455c:	afb10070 	sw	s1,112(sp)
20004560:	afa40010 	sw	a0,16(sp)
20004564:	afa50014 	sw	a1,20(sp)
20004568:	27a40010 	addiu	a0,sp,16
2000456c:	02002821 	move	a1,s0
20004570:	27b10038 	addiu	s1,sp,56
20004574:	afbf0074 	sw	ra,116(sp)
20004578:	afa60018 	sw	a2,24(sp)
2000457c:	0c001392 	jal	20004e48 <__unpack_d>
20004580:	afa7001c 	sw	a3,28(sp)
20004584:	27a40018 	addiu	a0,sp,24
20004588:	0c001392 	jal	20004e48 <__unpack_d>
2000458c:	02202821 	move	a1,s1
20004590:	8fa20020 	lw	v0,32(sp)
20004594:	00000000 	nop
20004598:	2c430002 	sltiu	v1,v0,2
2000459c:	1060000e 	beqz	v1,200045d8 <__muldf3+0x88>
200045a0:	00000000 	nop
200045a4:	8fa30024 	lw	v1,36(sp)
200045a8:	8fa2003c 	lw	v0,60(sp)
200045ac:	02002021 	move	a0,s0
200045b0:	00621026 	xor	v0,v1,v0
200045b4:	0002102b 	sltu	v0,zero,v0
200045b8:	afa20024 	sw	v0,36(sp)
200045bc:	0c0012ec 	jal	20004bb0 <__pack_d>
200045c0:	00000000 	nop
200045c4:	8fbf0074 	lw	ra,116(sp)
200045c8:	8fb10070 	lw	s1,112(sp)
200045cc:	8fb0006c 	lw	s0,108(sp)
200045d0:	03e00008 	jr	ra
200045d4:	27bd0078 	addiu	sp,sp,120
200045d8:	8fa30038 	lw	v1,56(sp)
200045dc:	00000000 	nop
200045e0:	2c640002 	sltiu	a0,v1,2
200045e4:	1080000d 	beqz	a0,2000461c <__muldf3+0xcc>
200045e8:	24040004 	li	a0,4
200045ec:	8fa2003c 	lw	v0,60(sp)
200045f0:	8fa30024 	lw	v1,36(sp)
200045f4:	02202021 	move	a0,s1
200045f8:	00621026 	xor	v0,v1,v0
200045fc:	0002102b 	sltu	v0,zero,v0
20004600:	0c0012ec 	jal	20004bb0 <__pack_d>
20004604:	afa2003c 	sw	v0,60(sp)
20004608:	8fbf0074 	lw	ra,116(sp)
2000460c:	8fb10070 	lw	s1,112(sp)
20004610:	8fb0006c 	lw	s0,108(sp)
20004614:	03e00008 	jr	ra
20004618:	27bd0078 	addiu	sp,sp,120
2000461c:	14440006 	bne	v0,a0,20004638 <__muldf3+0xe8>
20004620:	00000000 	nop
20004624:	24020002 	li	v0,2
20004628:	1462ffde 	bne	v1,v0,200045a4 <__muldf3+0x54>
2000462c:	3c044000 	lui	a0,0x4000
20004630:	0800116f 	j	200045bc <__muldf3+0x6c>
20004634:	24840040 	addiu	a0,a0,64
20004638:	1064006e 	beq	v1,a0,200047f4 <__muldf3+0x2a4>
2000463c:	24040002 	li	a0,2
20004640:	1044ffd8 	beq	v0,a0,200045a4 <__muldf3+0x54>
20004644:	00000000 	nop
20004648:	1064ffe8 	beq	v1,a0,200045ec <__muldf3+0x9c>
2000464c:	00000000 	nop
20004650:	8fa20030 	lw	v0,48(sp)
20004654:	8fa60048 	lw	a2,72(sp)
20004658:	8fac004c 	lw	t4,76(sp)
2000465c:	00460019 	multu	v0,a2
20004660:	8fad0034 	lw	t5,52(sp)
20004664:	00005012 	mflo	t2
20004668:	00005810 	mfhi	t3
	...
20004674:	01820019 	multu	t4,v0
20004678:	00001810 	mfhi	v1
2000467c:	00001012 	mflo	v0
	...
20004688:	01a60019 	multu	t5,a2
2000468c:	00003012 	mflo	a2
20004690:	00c22021 	addu	a0,a2,v0
20004694:	0086302b 	sltu	a2,a0,a2
20004698:	00003810 	mfhi	a3
2000469c:	00e32821 	addu	a1,a3,v1
200046a0:	00c53821 	addu	a3,a2,a1
200046a4:	00e3282b 	sltu	a1,a3,v1
200046a8:	14a00057 	bnez	a1,20004808 <__muldf3+0x2b8>
200046ac:	00004021 	move	t0,zero
200046b0:	14e30006 	bne	a3,v1,200046cc <__muldf3+0x17c>
200046b4:	00004821 	move	t1,zero
200046b8:	0082102b 	sltu	v0,a0,v0
200046bc:	14400003 	bnez	v0,200046cc <__muldf3+0x17c>
200046c0:	24090001 	li	t1,1
200046c4:	00004021 	move	t0,zero
200046c8:	00004821 	move	t1,zero
200046cc:	008b2021 	addu	a0,a0,t3
200046d0:	008b102b 	sltu	v0,a0,t3
200046d4:	10400007 	beqz	v0,200046f4 <__muldf3+0x1a4>
200046d8:	01402821 	move	a1,t2
200046dc:	25060001 	addiu	a2,t0,1
200046e0:	00c05021 	move	t2,a2
200046e4:	00c8302b 	sltu	a2,a2,t0
200046e8:	00c93021 	addu	a2,a2,t1
200046ec:	01404021 	move	t0,t2
200046f0:	00c04821 	move	t1,a2
200046f4:	01ac0019 	multu	t5,t4
200046f8:	8faa0040 	lw	t2,64(sp)
200046fc:	8fa60028 	lw	a2,40(sp)
20004700:	8fab0024 	lw	t3,36(sp)
20004704:	01463021 	addu	a2,t2,a2
20004708:	8faa003c 	lw	t2,60(sp)
2000470c:	00000000 	nop
20004710:	016a5026 	xor	t2,t3,t2
20004714:	000a502b 	sltu	t2,zero,t2
20004718:	afaa0054 	sw	t2,84(sp)
2000471c:	24cb0004 	addiu	t3,a2,4
20004720:	00001012 	mflo	v0
20004724:	00e25021 	addu	t2,a3,v0
20004728:	0147382b 	sltu	a3,t2,a3
2000472c:	00001810 	mfhi	v1
20004730:	01481021 	addu	v0,t2,t0
20004734:	00e31821 	addu	v1,a3,v1
20004738:	00691821 	addu	v1,v1,t1
2000473c:	004a502b 	sltu	t2,v0,t2
20004740:	01431821 	addu	v1,t2,v1
20004744:	3c072000 	lui	a3,0x2000
20004748:	0067382b 	sltu	a3,v1,a3
2000474c:	14e00014 	bnez	a3,200047a0 <__muldf3+0x250>
20004750:	afab0058 	sw	t3,88(sp)
20004754:	24c60005 	addiu	a2,a2,5
20004758:	3c0f8000 	lui	t7,0x8000
2000475c:	3c0e2000 	lui	t6,0x2000
20004760:	000357c0 	sll	t2,v1,0x1f
20004764:	00024842 	srl	t1,v0,0x1
20004768:	00031842 	srl	v1,v1,0x1
2000476c:	30480001 	andi	t0,v0,0x1
20004770:	00056042 	srl	t4,a1,0x1
20004774:	01491025 	or	v0,t2,t1
20004778:	00045842 	srl	t3,a0,0x1
2000477c:	006e382b 	sltu	a3,v1,t6
20004780:	00046fc0 	sll	t5,a0,0x1f
20004784:	11000003 	beqz	t0,20004794 <__muldf3+0x244>
20004788:	00c04821 	move	t1,a2
2000478c:	01ac2825 	or	a1,t5,t4
20004790:	016f2025 	or	a0,t3,t7
20004794:	10e0fff2 	beqz	a3,20004760 <__muldf3+0x210>
20004798:	24c60001 	addiu	a2,a2,1
2000479c:	afa90058 	sw	t1,88(sp)
200047a0:	3c061000 	lui	a2,0x1000
200047a4:	0066302b 	sltu	a2,v1,a2
200047a8:	10c0001a 	beqz	a2,20004814 <__muldf3+0x2c4>
200047ac:	3c0a1000 	lui	t2,0x1000
200047b0:	8fa60058 	lw	a2,88(sp)
200047b4:	080011f2 	j	200047c8 <__muldf3+0x278>
200047b8:	00023fc2 	srl	a3,v0,0x1f
200047bc:	10e00014 	beqz	a3,20004810 <__muldf3+0x2c0>
200047c0:	01282025 	or	a0,t1,t0
200047c4:	00023fc2 	srl	a3,v0,0x1f
200047c8:	00031840 	sll	v1,v1,0x1
200047cc:	00e31825 	or	v1,a3,v1
200047d0:	00054fc2 	srl	t1,a1,0x1f
200047d4:	00044040 	sll	t0,a0,0x1
200047d8:	006a382b 	sltu	a3,v1,t2
200047dc:	00021040 	sll	v0,v0,0x1
200047e0:	24c6ffff 	addiu	a2,a2,-1
200047e4:	0481fff5 	bgez	a0,200047bc <__muldf3+0x26c>
200047e8:	00052840 	sll	a1,a1,0x1
200047ec:	080011ef 	j	200047bc <__muldf3+0x26c>
200047f0:	34420001 	ori	v0,v0,0x1
200047f4:	24030002 	li	v1,2
200047f8:	1443ff7c 	bne	v0,v1,200045ec <__muldf3+0x9c>
200047fc:	3c044000 	lui	a0,0x4000
20004800:	0800116f 	j	200045bc <__muldf3+0x6c>
20004804:	24840040 	addiu	a0,a0,64
20004808:	080011b3 	j	200046cc <__muldf3+0x17c>
2000480c:	24090001 	li	t1,1
20004810:	afa60058 	sw	a2,88(sp)
20004814:	304700ff 	andi	a3,v0,0xff
20004818:	24060080 	li	a2,128
2000481c:	10e60007 	beq	a3,a2,2000483c <__muldf3+0x2ec>
20004820:	30460100 	andi	a2,v0,0x100
20004824:	afa20060 	sw	v0,96(sp)
20004828:	24020003 	li	v0,3
2000482c:	afa30064 	sw	v1,100(sp)
20004830:	afa20050 	sw	v0,80(sp)
20004834:	0800116f 	j	200045bc <__muldf3+0x6c>
20004838:	27a40050 	addiu	a0,sp,80
2000483c:	14c0fff9 	bnez	a2,20004824 <__muldf3+0x2d4>
20004840:	00000000 	nop
20004844:	00a42025 	or	a0,a1,a0
20004848:	1080fff6 	beqz	a0,20004824 <__muldf3+0x2d4>
2000484c:	00000000 	nop
20004850:	24440080 	addiu	a0,v0,128
20004854:	0082282b 	sltu	a1,a0,v0
20004858:	2402ff00 	li	v0,-256
2000485c:	00821024 	and	v0,a0,v0
20004860:	08001209 	j	20004824 <__muldf3+0x2d4>
20004864:	00a31821 	addu	v1,a1,v1

20004868 <__gedf2>:
20004868:	27bdffa0 	addiu	sp,sp,-96
2000486c:	afb10058 	sw	s1,88(sp)
20004870:	27b10020 	addiu	s1,sp,32
20004874:	afb00054 	sw	s0,84(sp)
20004878:	afa40010 	sw	a0,16(sp)
2000487c:	afa50014 	sw	a1,20(sp)
20004880:	27a40010 	addiu	a0,sp,16
20004884:	02202821 	move	a1,s1
20004888:	27b00038 	addiu	s0,sp,56
2000488c:	afbf005c 	sw	ra,92(sp)
20004890:	afa60018 	sw	a2,24(sp)
20004894:	0c001392 	jal	20004e48 <__unpack_d>
20004898:	afa7001c 	sw	a3,28(sp)
2000489c:	27a40018 	addiu	a0,sp,24
200048a0:	0c001392 	jal	20004e48 <__unpack_d>
200048a4:	02002821 	move	a1,s0
200048a8:	8fa20020 	lw	v0,32(sp)
200048ac:	00000000 	nop
200048b0:	2c420002 	sltiu	v0,v0,2
200048b4:	14400008 	bnez	v0,200048d8 <__gedf2+0x70>
200048b8:	2402ffff 	li	v0,-1
200048bc:	8fa20038 	lw	v0,56(sp)
200048c0:	00000000 	nop
200048c4:	2c420002 	sltiu	v0,v0,2
200048c8:	14400008 	bnez	v0,200048ec <__gedf2+0x84>
200048cc:	02202021 	move	a0,s1
200048d0:	0c0013d4 	jal	20004f50 <__fpcmp_parts_d>
200048d4:	02002821 	move	a1,s0
200048d8:	8fbf005c 	lw	ra,92(sp)
200048dc:	8fb10058 	lw	s1,88(sp)
200048e0:	8fb00054 	lw	s0,84(sp)
200048e4:	03e00008 	jr	ra
200048e8:	27bd0060 	addiu	sp,sp,96
200048ec:	08001236 	j	200048d8 <__gedf2+0x70>
200048f0:	2402ffff 	li	v0,-1

200048f4 <__floatsidf>:
200048f4:	27bdffd0 	addiu	sp,sp,-48
200048f8:	000417c2 	srl	v0,a0,0x1f
200048fc:	24030003 	li	v1,3
20004900:	afbf002c 	sw	ra,44(sp)
20004904:	afb00028 	sw	s0,40(sp)
20004908:	afa30010 	sw	v1,16(sp)
2000490c:	1480000b 	bnez	a0,2000493c <__floatsidf+0x48>
20004910:	afa20014 	sw	v0,20(sp)
20004914:	24020002 	li	v0,2
20004918:	afa20010 	sw	v0,16(sp)
2000491c:	0c0012ec 	jal	20004bb0 <__pack_d>
20004920:	27a40010 	addiu	a0,sp,16
20004924:	00602021 	move	a0,v1
20004928:	8fbf002c 	lw	ra,44(sp)
2000492c:	00801821 	move	v1,a0
20004930:	8fb00028 	lw	s0,40(sp)
20004934:	03e00008 	jr	ra
20004938:	27bd0030 	addiu	sp,sp,48
2000493c:	14400014 	bnez	v0,20004990 <__floatsidf+0x9c>
20004940:	3c028000 	lui	v0,0x8000
20004944:	00808021 	move	s0,a0
20004948:	2402003c 	li	v0,60
2000494c:	02002021 	move	a0,s0
20004950:	afa20018 	sw	v0,24(sp)
20004954:	afb00020 	sw	s0,32(sp)
20004958:	0c0012c0 	jal	20004b00 <__clzsi2>
2000495c:	afa00024 	sw	zero,36(sp)
20004960:	2442001d 	addiu	v0,v0,29
20004964:	1840ffed 	blez	v0,2000491c <__floatsidf+0x28>
20004968:	30430020 	andi	v1,v0,0x20
2000496c:	1060000c 	beqz	v1,200049a0 <__floatsidf+0xac>
20004970:	00102042 	srl	a0,s0,0x1
20004974:	00508004 	sllv	s0,s0,v0
20004978:	afb00024 	sw	s0,36(sp)
2000497c:	afa00020 	sw	zero,32(sp)
20004980:	2403003c 	li	v1,60
20004984:	00621023 	subu	v0,v1,v0
20004988:	08001247 	j	2000491c <__floatsidf+0x28>
2000498c:	afa20018 	sw	v0,24(sp)
20004990:	10820009 	beq	a0,v0,200049b8 <__floatsidf+0xc4>
20004994:	00048023 	negu	s0,a0
20004998:	08001253 	j	2000494c <__floatsidf+0x58>
2000499c:	2402003c 	li	v0,60
200049a0:	00021827 	nor	v1,zero,v0
200049a4:	00641806 	srlv	v1,a0,v1
200049a8:	00508004 	sllv	s0,s0,v0
200049ac:	afa30024 	sw	v1,36(sp)
200049b0:	08001260 	j	20004980 <__floatsidf+0x8c>
200049b4:	afb00020 	sw	s0,32(sp)
200049b8:	3c024000 	lui	v0,0x4000
200049bc:	8c44003c 	lw	a0,60(v0)
200049c0:	0800124a 	j	20004928 <__floatsidf+0x34>
200049c4:	00001021 	move	v0,zero

200049c8 <__fixdfsi>:
200049c8:	27bdffc8 	addiu	sp,sp,-56
200049cc:	afa40010 	sw	a0,16(sp)
200049d0:	afa50014 	sw	a1,20(sp)
200049d4:	27a40010 	addiu	a0,sp,16
200049d8:	afbf0034 	sw	ra,52(sp)
200049dc:	0c001392 	jal	20004e48 <__unpack_d>
200049e0:	27a50018 	addiu	a1,sp,24
200049e4:	8fa20018 	lw	v0,24(sp)
200049e8:	24030002 	li	v1,2
200049ec:	10430022 	beq	v0,v1,20004a78 <__fixdfsi+0xb0>
200049f0:	2c430002 	sltiu	v1,v0,2
200049f4:	14600020 	bnez	v1,20004a78 <__fixdfsi+0xb0>
200049f8:	24030004 	li	v1,4
200049fc:	10430007 	beq	v0,v1,20004a1c <__fixdfsi+0x54>
20004a00:	00000000 	nop
20004a04:	8fa20020 	lw	v0,32(sp)
20004a08:	00000000 	nop
20004a0c:	0440001a 	bltz	v0,20004a78 <__fixdfsi+0xb0>
20004a10:	2843001f 	slti	v1,v0,31
20004a14:	14600009 	bnez	v1,20004a3c <__fixdfsi+0x74>
20004a18:	2403003c 	li	v1,60
20004a1c:	8fa2001c 	lw	v0,28(sp)
20004a20:	00000000 	nop
20004a24:	14400022 	bnez	v0,20004ab0 <__fixdfsi+0xe8>
20004a28:	3c027fff 	lui	v0,0x7fff
20004a2c:	8fbf0034 	lw	ra,52(sp)
20004a30:	3442ffff 	ori	v0,v0,0xffff
20004a34:	03e00008 	jr	ra
20004a38:	27bd0038 	addiu	sp,sp,56
20004a3c:	00621023 	subu	v0,v1,v0
20004a40:	30430020 	andi	v1,v0,0x20
20004a44:	10600011 	beqz	v1,20004a8c <__fixdfsi+0xc4>
20004a48:	00022027 	nor	a0,zero,v0
20004a4c:	8fa3002c 	lw	v1,44(sp)
20004a50:	00000000 	nop
20004a54:	00431006 	srlv	v0,v1,v0
20004a58:	8fa3001c 	lw	v1,28(sp)
20004a5c:	00000000 	nop
20004a60:	10600006 	beqz	v1,20004a7c <__fixdfsi+0xb4>
20004a64:	00000000 	nop
20004a68:	8fbf0034 	lw	ra,52(sp)
20004a6c:	00021023 	negu	v0,v0
20004a70:	03e00008 	jr	ra
20004a74:	27bd0038 	addiu	sp,sp,56
20004a78:	00001021 	move	v0,zero
20004a7c:	8fbf0034 	lw	ra,52(sp)
20004a80:	00000000 	nop
20004a84:	03e00008 	jr	ra
20004a88:	27bd0038 	addiu	sp,sp,56
20004a8c:	8fa3002c 	lw	v1,44(sp)
20004a90:	00000000 	nop
20004a94:	00031840 	sll	v1,v1,0x1
20004a98:	00831804 	sllv	v1,v1,a0
20004a9c:	8fa40028 	lw	a0,40(sp)
20004aa0:	00000000 	nop
20004aa4:	00441006 	srlv	v0,a0,v0
20004aa8:	08001296 	j	20004a58 <__fixdfsi+0x90>
20004aac:	00621025 	or	v0,v1,v0
20004ab0:	8fbf0034 	lw	ra,52(sp)
20004ab4:	3c028000 	lui	v0,0x8000
20004ab8:	03e00008 	jr	ra
20004abc:	27bd0038 	addiu	sp,sp,56

20004ac0 <__ucmpdi2>:
20004ac0:	00a7102b 	sltu	v0,a1,a3
20004ac4:	1440000c 	bnez	v0,20004af8 <__ucmpdi2+0x38>
20004ac8:	00e5282b 	sltu	a1,a3,a1
20004acc:	14a00008 	bnez	a1,20004af0 <__ucmpdi2+0x30>
20004ad0:	00000000 	nop
20004ad4:	0086102b 	sltu	v0,a0,a2
20004ad8:	14400007 	bnez	v0,20004af8 <__ucmpdi2+0x38>
20004adc:	00c4302b 	sltu	a2,a2,a0
20004ae0:	14c00003 	bnez	a2,20004af0 <__ucmpdi2+0x30>
20004ae4:	00000000 	nop
20004ae8:	03e00008 	jr	ra
20004aec:	24020001 	li	v0,1
20004af0:	03e00008 	jr	ra
20004af4:	24020002 	li	v0,2
20004af8:	03e00008 	jr	ra
20004afc:	00001021 	move	v0,zero

20004b00 <__clzsi2>:
20004b00:	3c020001 	lui	v0,0x1
20004b04:	0082102b 	sltu	v0,a0,v0
20004b08:	1040000c 	beqz	v0,20004b3c <__clzsi2+0x3c>
20004b0c:	3c020100 	lui	v0,0x100
20004b10:	2c820100 	sltiu	v0,a0,256
20004b14:	1440001d 	bnez	v0,20004b8c <__clzsi2+0x8c>
20004b18:	24030018 	li	v1,24
20004b1c:	24020008 	li	v0,8
20004b20:	00442006 	srlv	a0,a0,v0
20004b24:	3c024000 	lui	v0,0x4000
20004b28:	24420058 	addiu	v0,v0,88
20004b2c:	00822021 	addu	a0,a0,v0
20004b30:	90820000 	lbu	v0,0(a0)
20004b34:	03e00008 	jr	ra
20004b38:	00621023 	subu	v0,v1,v0
20004b3c:	0082102b 	sltu	v0,a0,v0
20004b40:	1040000a 	beqz	v0,20004b6c <__clzsi2+0x6c>
20004b44:	24030008 	li	v1,8
20004b48:	24020010 	li	v0,16
20004b4c:	00442006 	srlv	a0,a0,v0
20004b50:	3c024000 	lui	v0,0x4000
20004b54:	24420058 	addiu	v0,v0,88
20004b58:	00822021 	addu	a0,a0,v0
20004b5c:	90820000 	lbu	v0,0(a0)
20004b60:	24030010 	li	v1,16
20004b64:	03e00008 	jr	ra
20004b68:	00621023 	subu	v0,v1,v0
20004b6c:	24020018 	li	v0,24
20004b70:	00442006 	srlv	a0,a0,v0
20004b74:	3c024000 	lui	v0,0x4000
20004b78:	24420058 	addiu	v0,v0,88
20004b7c:	00822021 	addu	a0,a0,v0
20004b80:	90820000 	lbu	v0,0(a0)
20004b84:	03e00008 	jr	ra
20004b88:	00621023 	subu	v0,v1,v0
20004b8c:	00001021 	move	v0,zero
20004b90:	00442006 	srlv	a0,a0,v0
20004b94:	3c024000 	lui	v0,0x4000
20004b98:	24420058 	addiu	v0,v0,88
20004b9c:	00822021 	addu	a0,a0,v0
20004ba0:	90820000 	lbu	v0,0(a0)
20004ba4:	24030020 	li	v1,32
20004ba8:	03e00008 	jr	ra
20004bac:	00621023 	subu	v0,v1,v0

20004bb0 <__pack_d>:
20004bb0:	8c820000 	lw	v0,0(a0)
20004bb4:	27bdffd0 	addiu	sp,sp,-48
20004bb8:	afb00010 	sw	s0,16(sp)
20004bbc:	afbf002c 	sw	ra,44(sp)
20004bc0:	afb70028 	sw	s7,40(sp)
20004bc4:	afb60024 	sw	s6,36(sp)
20004bc8:	afb40020 	sw	s4,32(sp)
20004bcc:	afb3001c 	sw	s3,28(sp)
20004bd0:	afb20018 	sw	s2,24(sp)
20004bd4:	afb10014 	sw	s1,20(sp)
20004bd8:	2c430002 	sltiu	v1,v0,2
20004bdc:	8c940010 	lw	s4,16(a0)
20004be0:	8c930014 	lw	s3,20(a0)
20004be4:	8c900004 	lw	s0,4(a0)
20004be8:	1460004d 	bnez	v1,20004d20 <__pack_d+0x170>
20004bec:	24030004 	li	v1,4
20004bf0:	10430047 	beq	v0,v1,20004d10 <__pack_d+0x160>
20004bf4:	24030002 	li	v1,2
20004bf8:	10430027 	beq	v0,v1,20004c98 <__pack_d+0xe8>
20004bfc:	02931025 	or	v0,s4,s3
20004c00:	10400026 	beqz	v0,20004c9c <__pack_d+0xec>
20004c04:	0000b021 	move	s6,zero
20004c08:	8c960008 	lw	s6,8(a0)
20004c0c:	00000000 	nop
20004c10:	2ac2fc02 	slti	v0,s6,-1022
20004c14:	1440004f 	bnez	v0,20004d54 <__pack_d+0x1a4>
20004c18:	2ac20400 	slti	v0,s6,1024
20004c1c:	1040003c 	beqz	v0,20004d10 <__pack_d+0x160>
20004c20:	328300ff 	andi	v1,s4,0xff
20004c24:	24020080 	li	v0,128
20004c28:	10620031 	beq	v1,v0,20004cf0 <__pack_d+0x140>
20004c2c:	26d603ff 	addiu	s6,s6,1023
20004c30:	2682007f 	addiu	v0,s4,127
20004c34:	0054a02b 	sltu	s4,v0,s4
20004c38:	02939821 	addu	s3,s4,s3
20004c3c:	0040a021 	move	s4,v0
20004c40:	3c022000 	lui	v0,0x2000
20004c44:	0262102b 	sltu	v0,s3,v0
20004c48:	14400007 	bnez	v0,20004c68 <__pack_d+0xb8>
20004c4c:	00133600 	sll	a2,s3,0x18
20004c50:	001317c0 	sll	v0,s3,0x1f
20004c54:	0014a042 	srl	s4,s4,0x1
20004c58:	0054a025 	or	s4,v0,s4
20004c5c:	00139842 	srl	s3,s3,0x1
20004c60:	26d60001 	addiu	s6,s6,1
20004c64:	00133600 	sll	a2,s3,0x18
20004c68:	00142202 	srl	a0,s4,0x8
20004c6c:	3c07000f 	lui	a3,0xf
20004c70:	00c42025 	or	a0,a2,a0
20004c74:	00132a02 	srl	a1,s3,0x8
20004c78:	34e7ffff 	ori	a3,a3,0xffff
20004c7c:	00803021 	move	a2,a0
20004c80:	00e52024 	and	a0,a3,a1
20004c84:	00801821 	move	v1,a0
20004c88:	00602821 	move	a1,v1
20004c8c:	00c02021 	move	a0,a2
20004c90:	08001329 	j	20004ca4 <__pack_d+0xf4>
20004c94:	32d607ff 	andi	s6,s6,0x7ff
20004c98:	0000b021 	move	s6,zero
20004c9c:	00002021 	move	a0,zero
20004ca0:	00002821 	move	a1,zero
20004ca4:	3c06000f 	lui	a2,0xf
20004ca8:	34c6ffff 	ori	a2,a2,0xffff
20004cac:	0016b500 	sll	s6,s6,0x14
20004cb0:	00c53024 	and	a2,a2,a1
20004cb4:	00d6b025 	or	s6,a2,s6
20004cb8:	001087c0 	sll	s0,s0,0x1f
20004cbc:	8fbf002c 	lw	ra,44(sp)
20004cc0:	02d08025 	or	s0,s6,s0
20004cc4:	02001821 	move	v1,s0
20004cc8:	00801021 	move	v0,a0
20004ccc:	8fb70028 	lw	s7,40(sp)
20004cd0:	8fb60024 	lw	s6,36(sp)
20004cd4:	8fb40020 	lw	s4,32(sp)
20004cd8:	8fb3001c 	lw	s3,28(sp)
20004cdc:	8fb20018 	lw	s2,24(sp)
20004ce0:	8fb10014 	lw	s1,20(sp)
20004ce4:	8fb00010 	lw	s0,16(sp)
20004ce8:	03e00008 	jr	ra
20004cec:	27bd0030 	addiu	sp,sp,48
20004cf0:	32820100 	andi	v0,s4,0x100
20004cf4:	1040ffd3 	beqz	v0,20004c44 <__pack_d+0x94>
20004cf8:	3c022000 	lui	v0,0x2000
20004cfc:	26820080 	addiu	v0,s4,128
20004d00:	0054a02b 	sltu	s4,v0,s4
20004d04:	02939821 	addu	s3,s4,s3
20004d08:	08001310 	j	20004c40 <__pack_d+0x90>
20004d0c:	0040a021 	move	s4,v0
20004d10:	241607ff 	li	s6,2047
20004d14:	00002021 	move	a0,zero
20004d18:	08001329 	j	20004ca4 <__pack_d+0xf4>
20004d1c:	00002821 	move	a1,zero
20004d20:	3c060007 	lui	a2,0x7
20004d24:	34c6ffff 	ori	a2,a2,0xffff
20004d28:	3c07000f 	lui	a3,0xf
20004d2c:	02662825 	or	a1,s3,a2
20004d30:	2404ffff 	li	a0,-1
20004d34:	34e7ffff 	ori	a3,a3,0xffff
20004d38:	00803021 	move	a2,a0
20004d3c:	00e52024 	and	a0,a3,a1
20004d40:	00801821 	move	v1,a0
20004d44:	00602821 	move	a1,v1
20004d48:	00c02021 	move	a0,a2
20004d4c:	08001329 	j	20004ca4 <__pack_d+0xf4>
20004d50:	241607ff 	li	s6,2047
20004d54:	2402fc02 	li	v0,-1022
20004d58:	0056b023 	subu	s6,v0,s6
20004d5c:	2ac20039 	slti	v0,s6,57
20004d60:	10400034 	beqz	v0,20004e34 <__pack_d+0x284>
20004d64:	00001021 	move	v0,zero
20004d68:	02c03021 	move	a2,s6
20004d6c:	02802021 	move	a0,s4
20004d70:	0c001424 	jal	20005090 <__lshrdi3>
20004d74:	02602821 	move	a1,s3
20004d78:	02c03021 	move	a2,s6
20004d7c:	24040001 	li	a0,1
20004d80:	00002821 	move	a1,zero
20004d84:	00409021 	move	s2,v0
20004d88:	0c001435 	jal	200050d4 <__ashldi3>
20004d8c:	00608821 	move	s1,v1
20004d90:	2444ffff 	addiu	a0,v0,-1
20004d94:	2463ffff 	addiu	v1,v1,-1
20004d98:	0082102b 	sltu	v0,a0,v0
20004d9c:	00431021 	addu	v0,v0,v1
20004da0:	0053b824 	and	s7,v0,s3
20004da4:	0094b024 	and	s6,a0,s4
20004da8:	02c02021 	move	a0,s6
20004dac:	02e02821 	move	a1,s7
20004db0:	00003021 	move	a2,zero
20004db4:	0c0012b0 	jal	20004ac0 <__ucmpdi2>
20004db8:	00003821 	move	a3,zero
20004dbc:	24030001 	li	v1,1
20004dc0:	10430003 	beq	v0,v1,20004dd0 <__pack_d+0x220>
20004dc4:	00000000 	nop
20004dc8:	24160001 	li	s6,1
20004dcc:	0000b821 	move	s7,zero
20004dd0:	02569025 	or	s2,s2,s6
20004dd4:	324300ff 	andi	v1,s2,0xff
20004dd8:	24020080 	li	v0,128
20004ddc:	14620018 	bne	v1,v0,20004e40 <__pack_d+0x290>
20004de0:	02378825 	or	s1,s1,s7
20004de4:	32420100 	andi	v0,s2,0x100
20004de8:	10400005 	beqz	v0,20004e00 <__pack_d+0x250>
20004dec:	00121202 	srl	v0,s2,0x8
20004df0:	26440080 	addiu	a0,s2,128
20004df4:	0092902b 	sltu	s2,a0,s2
20004df8:	02518821 	addu	s1,s2,s1
20004dfc:	00041202 	srl	v0,a0,0x8
20004e00:	3c041000 	lui	a0,0x1000
20004e04:	00112e00 	sll	a1,s1,0x18
20004e08:	0224202b 	sltu	a0,s1,a0
20004e0c:	00a21025 	or	v0,a1,v0
20004e10:	00111a02 	srl	v1,s1,0x8
20004e14:	14800002 	bnez	a0,20004e20 <__pack_d+0x270>
20004e18:	0000b021 	move	s6,zero
20004e1c:	24160001 	li	s6,1
20004e20:	3c06000f 	lui	a2,0xf
20004e24:	34c6ffff 	ori	a2,a2,0xffff
20004e28:	00402021 	move	a0,v0
20004e2c:	08001329 	j	20004ca4 <__pack_d+0xf4>
20004e30:	00662824 	and	a1,v1,a2
20004e34:	0000b021 	move	s6,zero
20004e38:	08001388 	j	20004e20 <__pack_d+0x270>
20004e3c:	00001821 	move	v1,zero
20004e40:	0800137d 	j	20004df4 <__pack_d+0x244>
20004e44:	2644007f 	addiu	a0,s2,127

20004e48 <__unpack_d>:
20004e48:	8c820004 	lw	v0,4(a0)
20004e4c:	3c07000f 	lui	a3,0xf
20004e50:	00021d02 	srl	v1,v0,0x14
20004e54:	000237c2 	srl	a2,v0,0x1f
20004e58:	34e7ffff 	ori	a3,a3,0xffff
20004e5c:	306307ff 	andi	v1,v1,0x7ff
20004e60:	8c840000 	lw	a0,0(a0)
20004e64:	00471024 	and	v0,v0,a3
20004e68:	14600019 	bnez	v1,20004ed0 <__unpack_d+0x88>
20004e6c:	aca60004 	sw	a2,4(a1)
20004e70:	00821825 	or	v1,a0,v0
20004e74:	10600025 	beqz	v1,20004f0c <__unpack_d+0xc4>
20004e78:	00041e02 	srl	v1,a0,0x18
20004e7c:	00021200 	sll	v0,v0,0x8
20004e80:	2406fc02 	li	a2,-1022
20004e84:	00621025 	or	v0,v1,v0
20004e88:	24030003 	li	v1,3
20004e8c:	aca30000 	sw	v1,0(a1)
20004e90:	aca60008 	sw	a2,8(a1)
20004e94:	00041a00 	sll	v1,a0,0x8
20004e98:	3c071000 	lui	a3,0x1000
20004e9c:	2404fc01 	li	a0,-1023
20004ea0:	000337c2 	srl	a2,v1,0x1f
20004ea4:	00021040 	sll	v0,v0,0x1
20004ea8:	00c21025 	or	v0,a2,v0
20004eac:	0047302b 	sltu	a2,v0,a3
20004eb0:	00804021 	move	t0,a0
20004eb4:	00031840 	sll	v1,v1,0x1
20004eb8:	14c0fff9 	bnez	a2,20004ea0 <__unpack_d+0x58>
20004ebc:	2484ffff 	addiu	a0,a0,-1
20004ec0:	aca20014 	sw	v0,20(a1)
20004ec4:	aca80008 	sw	t0,8(a1)
20004ec8:	03e00008 	jr	ra
20004ecc:	aca30010 	sw	v1,16(a1)
20004ed0:	240607ff 	li	a2,2047
20004ed4:	10660010 	beq	v1,a2,20004f18 <__unpack_d+0xd0>
20004ed8:	00043602 	srl	a2,a0,0x18
20004edc:	00021200 	sll	v0,v0,0x8
20004ee0:	00c21025 	or	v0,a2,v0
20004ee4:	3c061000 	lui	a2,0x1000
20004ee8:	00461025 	or	v0,v0,a2
20004eec:	2463fc01 	addiu	v1,v1,-1023
20004ef0:	00042200 	sll	a0,a0,0x8
20004ef4:	aca20014 	sw	v0,20(a1)
20004ef8:	24020003 	li	v0,3
20004efc:	aca30008 	sw	v1,8(a1)
20004f00:	aca20000 	sw	v0,0(a1)
20004f04:	03e00008 	jr	ra
20004f08:	aca40010 	sw	a0,16(a1)
20004f0c:	24020002 	li	v0,2
20004f10:	03e00008 	jr	ra
20004f14:	aca20000 	sw	v0,0(a1)
20004f18:	00821825 	or	v1,a0,v0
20004f1c:	10600007 	beqz	v1,20004f3c <__unpack_d+0xf4>
20004f20:	00021cc2 	srl	v1,v0,0x13
20004f24:	14600008 	bnez	v1,20004f48 <__unpack_d+0x100>
20004f28:	24030001 	li	v1,1
20004f2c:	aca30000 	sw	v1,0(a1)
20004f30:	aca20014 	sw	v0,20(a1)
20004f34:	03e00008 	jr	ra
20004f38:	aca40010 	sw	a0,16(a1)
20004f3c:	24020004 	li	v0,4
20004f40:	03e00008 	jr	ra
20004f44:	aca20000 	sw	v0,0(a1)
20004f48:	080013cc 	j	20004f30 <__unpack_d+0xe8>
20004f4c:	aca00000 	sw	zero,0(a1)

20004f50 <__fpcmp_parts_d>:
20004f50:	8c820000 	lw	v0,0(a0)
20004f54:	00000000 	nop
20004f58:	2c430002 	sltiu	v1,v0,2
20004f5c:	14600015 	bnez	v1,20004fb4 <__fpcmp_parts_d+0x64>
20004f60:	00000000 	nop
20004f64:	8ca30000 	lw	v1,0(a1)
20004f68:	00000000 	nop
20004f6c:	2c660002 	sltiu	a2,v1,2
20004f70:	14c00010 	bnez	a2,20004fb4 <__fpcmp_parts_d+0x64>
20004f74:	24060004 	li	a2,4
20004f78:	1046003f 	beq	v0,a2,20005078 <__fpcmp_parts_d+0x128>
20004f7c:	00000000 	nop
20004f80:	10660010 	beq	v1,a2,20004fc4 <__fpcmp_parts_d+0x74>
20004f84:	24060002 	li	a2,2
20004f88:	1046000c 	beq	v0,a2,20004fbc <__fpcmp_parts_d+0x6c>
20004f8c:	00000000 	nop
20004f90:	10660012 	beq	v1,a2,20004fdc <__fpcmp_parts_d+0x8c>
20004f94:	00000000 	nop
20004f98:	8c820004 	lw	v0,4(a0)
20004f9c:	8ca30004 	lw	v1,4(a1)
20004fa0:	00000000 	nop
20004fa4:	10430013 	beq	v0,v1,20004ff4 <__fpcmp_parts_d+0xa4>
20004fa8:	00000000 	nop
20004fac:	14400009 	bnez	v0,20004fd4 <__fpcmp_parts_d+0x84>
20004fb0:	00000000 	nop
20004fb4:	03e00008 	jr	ra
20004fb8:	24020001 	li	v0,1
20004fbc:	1062002c 	beq	v1,v0,20005070 <__fpcmp_parts_d+0x120>
20004fc0:	00000000 	nop
20004fc4:	8ca20004 	lw	v0,4(a1)
20004fc8:	00000000 	nop
20004fcc:	1440fff9 	bnez	v0,20004fb4 <__fpcmp_parts_d+0x64>
20004fd0:	00000000 	nop
20004fd4:	03e00008 	jr	ra
20004fd8:	2402ffff 	li	v0,-1
20004fdc:	8c820004 	lw	v0,4(a0)
20004fe0:	00000000 	nop
20004fe4:	1440fffb 	bnez	v0,20004fd4 <__fpcmp_parts_d+0x84>
20004fe8:	00000000 	nop
20004fec:	03e00008 	jr	ra
20004ff0:	24020001 	li	v0,1
20004ff4:	8c860008 	lw	a2,8(a0)
20004ff8:	8ca30008 	lw	v1,8(a1)
20004ffc:	00000000 	nop
20005000:	0066382a 	slt	a3,v1,a2
20005004:	14e0ffe9 	bnez	a3,20004fac <__fpcmp_parts_d+0x5c>
20005008:	00c3182a 	slt	v1,a2,v1
2000500c:	14600014 	bnez	v1,20005060 <__fpcmp_parts_d+0x110>
20005010:	00000000 	nop
20005014:	8ca60014 	lw	a2,20(a1)
20005018:	8c830014 	lw	v1,20(a0)
2000501c:	8c870010 	lw	a3,16(a0)
20005020:	00c3202b 	sltu	a0,a2,v1
20005024:	8ca50010 	lw	a1,16(a1)
20005028:	1480ffe0 	bnez	a0,20004fac <__fpcmp_parts_d+0x5c>
2000502c:	00000000 	nop
20005030:	14660005 	bne	v1,a2,20005048 <__fpcmp_parts_d+0xf8>
20005034:	0066202b 	sltu	a0,v1,a2
20005038:	00a7202b 	sltu	a0,a1,a3
2000503c:	1480ffdb 	bnez	a0,20004fac <__fpcmp_parts_d+0x5c>
20005040:	00000000 	nop
20005044:	0066202b 	sltu	a0,v1,a2
20005048:	14800005 	bnez	a0,20005060 <__fpcmp_parts_d+0x110>
2000504c:	00000000 	nop
20005050:	14c30007 	bne	a2,v1,20005070 <__fpcmp_parts_d+0x120>
20005054:	00e5282b 	sltu	a1,a3,a1
20005058:	10a00005 	beqz	a1,20005070 <__fpcmp_parts_d+0x120>
2000505c:	00000000 	nop
20005060:	1040ffdc 	beqz	v0,20004fd4 <__fpcmp_parts_d+0x84>
20005064:	00000000 	nop
20005068:	080013ed 	j	20004fb4 <__fpcmp_parts_d+0x64>
2000506c:	00000000 	nop
20005070:	03e00008 	jr	ra
20005074:	00001021 	move	v0,zero
20005078:	1462ffd8 	bne	v1,v0,20004fdc <__fpcmp_parts_d+0x8c>
2000507c:	00000000 	nop
20005080:	8ca30004 	lw	v1,4(a1)
20005084:	8c820004 	lw	v0,4(a0)
20005088:	03e00008 	jr	ra
2000508c:	00621023 	subu	v0,v1,v0

20005090 <__lshrdi3>:
20005090:	10c00009 	beqz	a2,200050b8 <__lshrdi3+0x28>
20005094:	00801021 	move	v0,a0
20005098:	24030020 	li	v1,32
2000509c:	00661823 	subu	v1,v1,a2
200050a0:	18600007 	blez	v1,200050c0 <__lshrdi3+0x30>
200050a4:	00000000 	nop
200050a8:	00651804 	sllv	v1,a1,v1
200050ac:	00c21006 	srlv	v0,v0,a2
200050b0:	00621025 	or	v0,v1,v0
200050b4:	00c52806 	srlv	a1,a1,a2
200050b8:	03e00008 	jr	ra
200050bc:	00a01821 	move	v1,a1
200050c0:	00031023 	negu	v0,v1
200050c4:	00451006 	srlv	v0,a1,v0
200050c8:	00002821 	move	a1,zero
200050cc:	03e00008 	jr	ra
200050d0:	00a01821 	move	v1,a1

200050d4 <__ashldi3>:
200050d4:	10c00008 	beqz	a2,200050f8 <__ashldi3+0x24>
200050d8:	00801021 	move	v0,a0
200050dc:	24030020 	li	v1,32
200050e0:	00661823 	subu	v1,v1,a2
200050e4:	18600006 	blez	v1,20005100 <__ashldi3+0x2c>
200050e8:	00c52804 	sllv	a1,a1,a2
200050ec:	00641806 	srlv	v1,a0,v1
200050f0:	00652825 	or	a1,v1,a1
200050f4:	00c41004 	sllv	v0,a0,a2
200050f8:	03e00008 	jr	ra
200050fc:	00a01821 	move	v1,a1
20005100:	00032823 	negu	a1,v1
20005104:	00a42804 	sllv	a1,a0,a1
20005108:	00001021 	move	v0,zero
2000510c:	03e00008 	jr	ra
20005110:	00a01821 	move	v1,a1
