
Telemetrons_CloudRobotics2013.elf:     file format elf32-littlemips


Disassembly of section .text:

20000000 <_text>:
   .extern _etext
   .extern _ebss
   .extern Handle_Interrupts

   .set noreorder
		nop
20000000:	00000000 	nop
        j _startup            # Reset vector
20000004:	08000005 	j	20000014 <_startup>
        nop
20000008:	00000000 	nop

        j Handler            # Interrupt vector
2000000c:	0800074e 	j	20001d38 <Handler>
        nop
20000010:	00000000 	nop

20000014 <_startup>:

   .func   _startup
_startup:                     # Start of code section
/* Set global pointer register */
        la $28, _gp
20000014:	3c1c4000 	lui	gp,0x4000
20000018:	279c01a0 	addiu	gp,gp,416

/* Set the stack pointer */
        la $t0, USR_Stk_Base_Val
2000001c:	3c084000 	lui	t0,0x4000
20000020:	35083e00 	ori	t0,t0,0x3e00
        move $sp, $t0
20000024:	0100e821 	move	sp,t0

        mtc0 $sp, $25         # Save CP0 Status Reg
20000028:	409dc800 	mtc0	sp,$25

/* Fill the stack */
        la $3, Top_Stack - 4
2000002c:	3c034000 	lui	v1,0x4000
20000030:	34633ffc 	ori	v1,v1,0x3ffc
        la $4, Top_Stack -IRQ_Stk -USR_Stk
20000034:	3c044000 	lui	a0,0x4000
20000038:	34843600 	ori	a0,a0,0x3600
        la $5, 0xDEC0ADDE
2000003c:	3c05dec0 	lui	a1,0xdec0
20000040:	34a5adde 	ori	a1,a1,0xadde

20000044 <Stk_fill>:
Stk_fill:
		sw $5, 0($4)
20000044:	ac850000 	sw	a1,0(a0)
		slt $2, $4, $3
20000048:	0083102a 	slt	v0,a0,v1
		bnez $2, Stk_fill
2000004c:	1440fffd 	bnez	v0,20000044 <Stk_fill>
		addiu $4, $4, 4
20000050:	24840004 	addiu	a0,a0,4
/* End of stack-filler */

		/* Special value at the bottom of the interrupt stack */
		la $4, Top_Stack -IRQ_Stk
20000054:	3c044000 	lui	a0,0x4000
20000058:	34843e00 	ori	a0,a0,0x3e00
		la $5, INT_Stk_Val
2000005c:	3c054000 	lui	a1,0x4000
20000060:	24a50134 	addiu	a1,a1,308
		lw $5, 0($5)
20000064:	8ca50000 	lw	a1,0(a1)
		nop
20000068:	00000000 	nop
		sw $5, 0($4)
2000006c:	ac850000 	sw	a1,0(a0)

		/* Special value at the bottom of the user stack */
		la $4, Top_Stack -IRQ_Stk -USR_Stk
20000070:	3c044000 	lui	a0,0x4000
20000074:	34843600 	ori	a0,a0,0x3600
		la $5, USR_Stk_Val
20000078:	3c054000 	lui	a1,0x4000
2000007c:	24a50130 	addiu	a1,a1,304
		lw $5, 0($5)
20000080:	8ca50000 	lw	a1,0(a1)
		nop
20000084:	00000000 	nop
		sw $5, 0($4)
20000088:	ac850000 	sw	a1,0(a0)

        la $4, _etext
2000008c:	3c042000 	lui	a0,0x2000
20000090:	24842f98 	addiu	a0,a0,12184
        la $5, _text
20000094:	3c052000 	lui	a1,0x2000
20000098:	24a50000 	addiu	a1,a1,0
        subu $4, $4, $5
2000009c:	00852023 	subu	a0,a0,a1
        la $5, _edata
200000a0:	3c054000 	lui	a1,0x4000
200000a4:	24a501a0 	addiu	a1,a1,416
        la $6, _data
200000a8:	3c064000 	lui	a2,0x4000
200000ac:	24c60000 	addiu	a2,a2,0

200000b0 <Data_copy>:
Data_copy:
        lw $2, 0($4)
200000b0:	8c820000 	lw	v0,0(a0)
        nop
200000b4:	00000000 	nop
        slt $3, $6, $5
200000b8:	00c5182a 	slt	v1,a2,a1
        sw $2, 0($6)
200000bc:	acc20000 	sw	v0,0(a2)
        addiu $6, $6, 4
200000c0:	24c60004 	addiu	a2,a2,4
        bnez  $3, Data_copy
200000c4:	1460fffa 	bnez	v1,200000b0 <Data_copy>
        addiu $4, $4, 4
200000c8:	24840004 	addiu	a0,a0,4

/* Clear .bss section (Zero init) */
        la $4, _bss   # Clear BSS Segment
200000cc:	3c044000 	lui	a0,0x4000
200000d0:	248401a0 	addiu	a0,a0,416
        la $5, _ebss  # Clear BSS Segment
200000d4:	3c054000 	lui	a1,0x4000
200000d8:	24a509d0 	addiu	a1,a1,2512

200000dc <BSS_clear>:
BSS_clear:
        sw  $0, 0($4)
200000dc:	ac800000 	sw	zero,0(a0)
        slt $3, $4, $5
200000e0:	0085182a 	slt	v1,a0,a1
        bnez  $3, BSS_clear
200000e4:	1460fffd 	bnez	v1,200000dc <BSS_clear>
        addiu $4, $4, 4
200000e8:	24840004 	addiu	a0,a0,4

        la $4, _stext
200000ec:	3c040000 	lui	a0,0x0
200000f0:	24840000 	addiu	a0,a0,0
        la $5, _etext
200000f4:	3c052000 	lui	a1,0x2000
200000f8:	24a52f98 	addiu	a1,a1,12184
        la $6, _text
200000fc:	3c062000 	lui	a2,0x2000
20000100:	24c60000 	addiu	a2,a2,0

20000104 <Code_copy>:
Code_copy:
        lw $2, 0($4)
20000104:	8c820000 	lw	v0,0(a0)
        nop
20000108:	00000000 	nop
        slt $3, $6, $5
2000010c:	00c5182a 	slt	v1,a2,a1
        sw $2, 0($6)
20000110:	acc20000 	sw	v0,0(a2)
        addiu $6, $6, 4
20000114:	24c60004 	addiu	a2,a2,4
        bnez  $3, Code_copy
20000118:	1460fffa 	bnez	v1,20000104 <Code_copy>
        addiu $4, $4, 4
2000011c:	24840004 	addiu	a0,a0,4


/* Enable system interrupts */
        mfc0 $4, $12         # Read CP0 Status Reg
20000120:	40046000 	mfc0	a0,c0_sr
        nop
20000124:	00000000 	nop
        ori $4, $4, 0x700    # Set IE and IRQ = 7
20000128:	34840700 	ori	a0,a0,0x700
        nop
2000012c:	00000000 	nop
        mtc0 $4, $12         # Save CP0 Status Reg
20000130:	40846000 	mtc0	a0,c0_sr
        nop
20000134:	00000000 	nop
        
        la $4, 0xFF00
20000138:	3404ff00 	li	a0,0xff00
        nop
2000013c:	00000000 	nop
        mtc0 $4, $13
20000140:	40846800 	mtc0	a0,c0_cause
        jalr $t0
		nop
#endif

/* Finally, start running the C code - branch to main() */
		la $t0, main
20000144:	3c082000 	lui	t0,0x2000
20000148:	25080160 	addiu	t0,t0,352
        jalr $t0        # Call main()
2000014c:	0100f809 	jalr	t0
        nop
20000150:	00000000 	nop

20000154 <_exit>:

	.global _exit
_exit:                  # Halt if main returns
        b   _exit
20000154:	1000ffff                                ....

20000158 <DEBUG_Assert_Failed>:
 *
 * \param[in]	file	The name of the file where the assertion failed.
 * \param[in]	line	The line number where the assertion failed.
 */
void DEBUG_Assert_Failed(TTE_UNUSED char* file, TTE_UNUSED int line)
{
20000158:	08000056 	j	20000158 <DEBUG_Assert_Failed>
2000015c:	00000000 	nop

20000160 <main>:
 *
 * This function should never exit, as embedded systems do not have an
 * operating system to return to.
 */
int main(void)
{
20000160:	27bdffe8 	addiu	sp,sp,-24
20000164:	afbf0014 	sw	ra,20(sp)
 * @param
 */
TTE_ALWAYS_INLINE
static inline void Target_Mapping_Init(void)
{
	Device_Add(NULL);
20000168:	0c000bc5 	jal	20002f14 <Device_Add>
2000016c:	00002021 	move	a0,zero
	return 0;
#endif

	Target_Mapping_Init();

	Scheduler_Init(Config_Tick_Period);
20000170:	0c000892 	jal	20002248 <Scheduler_Init>
20000174:	240403e8 	li	a0,1000
	Tasks_Init();
20000178:	0c000066 	jal	20000198 <Tasks_Init>
2000017c:	00000000 	nop

	Scheduler_Start();
20000180:	0c000888 	jal	20002220 <Scheduler_Start>
20000184:	00000000 	nop

	while (TRUE)
	{
		Scheduler_Dispatch();
20000188:	0c00082a 	jal	200020a8 <Scheduler_Dispatch>
2000018c:	00000000 	nop
20000190:	08000062 	j	20000188 <main+0x28>
20000194:	00000000 	nop

20000198 <Tasks_Init>:

/**
 * Initialise all hardware for all tasks.
 */
void Tasks_Init(void)
{
20000198:	27bdffe8 	addiu	sp,sp,-24
2000019c:	afbf0014 	sw	ra,20(sp)
	Flashing_LED_Init();
200001a0:	0c000689 	jal	20001a24 <Flashing_LED_Init>
200001a4:	00000000 	nop
	System_Control_Init();
200001a8:	0c000145 	jal	20000514 <System_Control_Init>
200001ac:	00000000 	nop
	Read_Enc_Init();
200001b0:	0c000216 	jal	20000858 <Read_Enc_Init>
200001b4:	00000000 	nop
	Motor_Right_Init();
200001b8:	0c000369 	jal	20000da4 <Motor_Right_Init>
200001bc:	00000000 	nop
	Motor_Left_Init();
200001c0:	0c000420 	jal	20001080 <Motor_Left_Init>
200001c4:	00000000 	nop
	Course_Corrector_Init();
200001c8:	0c0006c2 	jal	20001b08 <Course_Corrector_Init>
200001cc:	00000000 	nop
	CAN_relay_Init();
200001d0:	0c0006dc 	jal	20001b70 <CAN_relay_Init>
200001d4:	00000000 	nop
	Message_Sender_Init();
200001d8:	0c00065d 	jal	20001974 <Message_Sender_Init>
200001dc:	00000000 	nop
	object_detection_Init();
}
200001e0:	8fbf0014 	lw	ra,20(sp)
	Motor_Right_Init();
	Motor_Left_Init();
	Course_Corrector_Init();
	CAN_relay_Init();
	Message_Sender_Init();
	object_detection_Init();
200001e4:	0800007b 	j	200001ec <object_detection_Init>
200001e8:	27bd0018 	addiu	sp,sp,24

200001ec <object_detection_Init>:
 * Initialisation for the object_detection package.
 * This will be called from Tasks_Init by default.
 */
void object_detection_Init(void)
{
	objectFollower = Fd;
200001ec:	24020001 	li	v0,1
	nextMove = Fd;
200001f0:	af8200f4 	sw	v0,244(gp)
 * Initialisation for the object_detection package.
 * This will be called from Tasks_Init by default.
 */
void object_detection_Init(void)
{
	objectFollower = Fd;
200001f4:	af8200f8 	sw	v0,248(gp)
	nextMove = Fd;
	avoidance = STRAIGHT;
200001f8:	af8000fc 	sw	zero,252(gp)
	lastAvoidance = STRAIGHT;
}
200001fc:	03e00008 	jr	ra
20000200:	af800100 	sw	zero,256(gp)

20000204 <object_detection_Update>:
void object_detection_Update(void)
{
	static uint16_t stop = 0;
	Bool IRFlag = False;

	switch(avoidance)
20000204:	8f8200fc 	lw	v0,252(gp)
20000208:	24040002 	li	a0,2
2000020c:	10440080 	beq	v0,a0,20000410 <object_detection_Update+0x20c>
20000210:	2c430003 	sltiu	v1,v0,3
20000214:	10600008 	beqz	v1,20000238 <object_detection_Update+0x34>
20000218:	24030004 	li	v1,4
2000021c:	1040000f 	beqz	v0,2000025c <object_detection_Update+0x58>
20000220:	24050001 	li	a1,1
20000224:	24030001 	li	v1,1
20000228:	144300b8 	bne	v0,v1,2000050c <object_detection_Update+0x308>
2000022c:	3c034000 	lui	v1,0x4000
			}
		}

		break;
	case AVOID_L:
		movement_G = Rt;
20000230:	080000fb 	j	200003ec <object_detection_Update+0x1e8>
20000234:	24050004 	li	a1,4
void object_detection_Update(void)
{
	static uint16_t stop = 0;
	Bool IRFlag = False;

	switch(avoidance)
20000238:	10430095 	beq	v0,v1,20000490 <object_detection_Update+0x28c>
2000023c:	2c430004 	sltiu	v1,v0,4
20000240:	1460007e 	bnez	v1,2000043c <object_detection_Update+0x238>
20000244:	24040003 	li	a0,3
20000248:	24030005 	li	v1,5
2000024c:	144300af 	bne	v0,v1,2000050c <object_detection_Update+0x308>
20000250:	00000000 	nop
20000254:	0800013a 	j	200004e8 <object_detection_Update+0x2e4>
20000258:	00000000 	nop
	{
	case STRAIGHT:
		movement_G = Fd;

		if((sensorReadings.IRLeft-sensorReadings.IRRight > IR_NOISE)||(sensorReadings.IRRight-sensorReadings.IRLeft > IR_NOISE))
2000025c:	3c024000 	lui	v0,0x4000
20000260:	244603dc 	addiu	a2,v0,988
20000264:	8c4303dc 	lw	v1,988(v0)
20000268:	8cc20004 	lw	v0,4(a2)
2000026c:	00000000 	nop
20000270:	00623823 	subu	a3,v1,v0
20000274:	2ce70006 	sltiu	a3,a3,6
20000278:	10e00018 	beqz	a3,200002dc <object_detection_Update+0xd8>
2000027c:	af8500ec 	sw	a1,236(gp)
20000280:	00433823 	subu	a3,v0,v1
20000284:	2ce70006 	sltiu	a3,a3,6
20000288:	10e00014 	beqz	a3,200002dc <object_detection_Update+0xd8>
2000028c:	00000000 	nop
		{
			IRFlag = True;
		}
		else if((avoidance != AVOID_L) && (avoidance != AVOID_R) && ((sensorReadings.USFwd < US_MIN) && (sensorReadings.USFwd > US_NOISE))&&(nextMove == Fd))
20000290:	8cc60008 	lw	a2,8(a2)
20000294:	00000000 	nop
20000298:	24c6fff0 	addiu	a2,a2,-16
2000029c:	2cc6000c 	sltiu	a2,a2,12
200002a0:	10c00010 	beqz	a2,200002e4 <object_detection_Update+0xe0>
200002a4:	00000000 	nop
200002a8:	8f8600f4 	lw	a2,244(gp)
200002ac:	00000000 	nop
200002b0:	14c5000c 	bne	a2,a1,200002e4 <object_detection_Update+0xe0>
200002b4:	00000000 	nop
		{
			if(lastAvoidance == STRAIGHT)
200002b8:	8f850100 	lw	a1,256(gp)
200002bc:	00000000 	nop
200002c0:	14a00002 	bnez	a1,200002cc <object_detection_Update+0xc8>
200002c4:	00000000 	nop
			{
				lastAvoidance = AVOID_R;
200002c8:	af840100 	sw	a0,256(gp)
			}
			avoidance = lastAvoidance;
200002cc:	8f840100 	lw	a0,256(gp)

			stop = 0;
200002d0:	a7800000 	sh	zero,0(gp)
		{
			if(lastAvoidance == STRAIGHT)
			{
				lastAvoidance = AVOID_R;
			}
			avoidance = lastAvoidance;
200002d4:	080000b9 	j	200002e4 <object_detection_Update+0xe0>
200002d8:	af8400fc 	sw	a0,252(gp)

			stop = 0;
200002dc:	080000ba 	j	200002e8 <object_detection_Update+0xe4>
200002e0:	24040001 	li	a0,1
200002e4:	00002021 	move	a0,zero
		}

		if((avoidance == STRAIGHT) && (lastAvoidance == AVOID_L) && (sensorReadings.IRLeft >= IR_MAX))
200002e8:	8f8500fc 	lw	a1,252(gp)
200002ec:	00000000 	nop
200002f0:	14a00021 	bnez	a1,20000378 <object_detection_Update+0x174>
200002f4:	24060001 	li	a2,1
200002f8:	8f850100 	lw	a1,256(gp)
200002fc:	00000000 	nop
20000300:	14a6000e 	bne	a1,a2,2000033c <object_detection_Update+0x138>
20000304:	00000000 	nop
20000308:	2c650017 	sltiu	a1,v1,23
2000030c:	14a0001a 	bnez	a1,20000378 <object_detection_Update+0x174>
20000310:	00000000 	nop
		{
			if(++stop >= 13*HAMMER_TIME)
20000314:	97820000 	lhu	v0,0(gp)
20000318:	00000000 	nop
2000031c:	24420001 	addiu	v0,v0,1
20000320:	3042ffff 	andi	v0,v0,0xffff
20000324:	2c43028a 	sltiu	v1,v0,650
20000328:	a7820000 	sh	v0,0(gp)
2000032c:	1060006b 	beqz	v1,200004dc <object_detection_Update+0x2d8>
20000330:	24020003 	li	v0,3
20000334:	08000143 	j	2000050c <object_detection_Update+0x308>
20000338:	00000000 	nop
			{
				avoidance = FOLLOW_L;
				stop = 0;
			}
		}
		else if((avoidance == STRAIGHT) && (lastAvoidance == AVOID_R) && (sensorReadings.IRRight >= IR_MAX))
2000033c:	24060002 	li	a2,2
20000340:	14a6000d 	bne	a1,a2,20000378 <object_detection_Update+0x174>
20000344:	2c450017 	sltiu	a1,v0,23
20000348:	14a0000b 	bnez	a1,20000378 <object_detection_Update+0x174>
2000034c:	00000000 	nop
		{
			if(++stop >= 13*HAMMER_TIME)
20000350:	97820000 	lhu	v0,0(gp)
20000354:	00000000 	nop
20000358:	24420001 	addiu	v0,v0,1
2000035c:	3042ffff 	andi	v0,v0,0xffff
20000360:	2c43028a 	sltiu	v1,v0,650
20000364:	a7820000 	sh	v0,0(gp)
20000368:	1060005c 	beqz	v1,200004dc <object_detection_Update+0x2d8>
2000036c:	24020004 	li	v0,4
20000370:	08000143 	j	2000050c <object_detection_Update+0x308>
20000374:	00000000 	nop
			{
				avoidance = FOLLOW_R;
				stop = 0;
			}
		}
		else if(IRFlag == True)
20000378:	10800064 	beqz	a0,2000050c <object_detection_Update+0x308>
2000037c:	0062202b 	sltu	a0,v1,v0
		{
			stop = 0;

			if((sensorReadings.IRLeft < sensorReadings.IRRight) && ((sensorReadings.IRLeft < IR_MIN)||((sensorReadings.USFwd < US_MIN) && (sensorReadings.USFwd > US_NOISE))))
20000380:	1080000c 	beqz	a0,200003b4 <object_detection_Update+0x1b0>
20000384:	a7800000 	sh	zero,0(gp)
20000388:	2c640015 	sltiu	a0,v1,21
2000038c:	14800007 	bnez	a0,200003ac <object_detection_Update+0x1a8>
20000390:	3c044000 	lui	a0,0x4000
20000394:	8c8403e4 	lw	a0,996(a0)
20000398:	00000000 	nop
2000039c:	2484fff0 	addiu	a0,a0,-16
200003a0:	2c84000c 	sltiu	a0,a0,12
200003a4:	10800003 	beqz	a0,200003b4 <object_detection_Update+0x1b0>
200003a8:	00000000 	nop
			{
				avoidance = AVOID_L;
200003ac:	080000f9 	j	200003e4 <object_detection_Update+0x1e0>
200003b0:	24020001 	li	v0,1
			}
			else if((sensorReadings.IRLeft > sensorReadings.IRRight) && ((sensorReadings.IRRight < IR_MIN)||((sensorReadings.USFwd < US_MIN) && (sensorReadings.USFwd > US_NOISE))))
200003b4:	0043182b 	sltu	v1,v0,v1
200003b8:	10600054 	beqz	v1,2000050c <object_detection_Update+0x308>
200003bc:	2c420015 	sltiu	v0,v0,21
200003c0:	14400007 	bnez	v0,200003e0 <object_detection_Update+0x1dc>
200003c4:	3c024000 	lui	v0,0x4000
200003c8:	8c4203e4 	lw	v0,996(v0)
200003cc:	00000000 	nop
200003d0:	2442fff0 	addiu	v0,v0,-16
200003d4:	2c42000c 	sltiu	v0,v0,12
200003d8:	1040004c 	beqz	v0,2000050c <object_detection_Update+0x308>
200003dc:	00000000 	nop
			{
				avoidance = AVOID_R;
200003e0:	24020002 	li	v0,2
200003e4:	03e00008 	jr	ra
200003e8:	af8200fc 	sw	v0,252(gp)

		break;
	case AVOID_L:
		movement_G = Rt;
		lastAvoidance = AVOID_L;
		if((sensorReadings.IRLeft >= IR_MIN) && (sensorReadings.USFwd >= US_MIN))
200003ec:	8c6403dc 	lw	a0,988(v1)
200003f0:	00000000 	nop
200003f4:	2c840015 	sltiu	a0,a0,21
			}
		}

		break;
	case AVOID_L:
		movement_G = Rt;
200003f8:	af8500ec 	sw	a1,236(gp)
		lastAvoidance = AVOID_L;
200003fc:	af820100 	sw	v0,256(gp)
		if((sensorReadings.IRLeft >= IR_MIN) && (sensorReadings.USFwd >= US_MIN))
20000400:	1080000b 	beqz	a0,20000430 <object_detection_Update+0x22c>
20000404:	246303dc 	addiu	v1,v1,988
20000408:	08000143 	j	2000050c <object_detection_Update+0x308>
2000040c:	00000000 	nop
		}
		break;
	case AVOID_R:
		movement_G = Lf;
		lastAvoidance = AVOID_R;
		if((sensorReadings.IRRight >= IR_MIN) && (sensorReadings.USFwd >= US_MIN))
20000410:	3c034000 	lui	v1,0x4000
20000414:	246303dc 	addiu	v1,v1,988
20000418:	8c640004 	lw	a0,4(v1)
			stop = 0;
			avoidance = WAIT;
		}
		break;
	case AVOID_R:
		movement_G = Lf;
2000041c:	24050003 	li	a1,3
		lastAvoidance = AVOID_R;
		if((sensorReadings.IRRight >= IR_MIN) && (sensorReadings.USFwd >= US_MIN))
20000420:	2c840015 	sltiu	a0,a0,21
			stop = 0;
			avoidance = WAIT;
		}
		break;
	case AVOID_R:
		movement_G = Lf;
20000424:	af8500ec 	sw	a1,236(gp)
		lastAvoidance = AVOID_R;
		if((sensorReadings.IRRight >= IR_MIN) && (sensorReadings.USFwd >= US_MIN))
20000428:	14800038 	bnez	a0,2000050c <object_detection_Update+0x308>
2000042c:	af820100 	sw	v0,256(gp)
20000430:	8c620008 	lw	v0,8(v1)
20000434:	08000135 	j	200004d4 <object_detection_Update+0x2d0>
20000438:	2c42001c 	sltiu	v0,v0,28
		}
		break;
	case FOLLOW_L:
		movement_G = Lf;

		if(++stop >= 13*HAMMER_TIME)
2000043c:	97820000 	lhu	v0,0(gp)
20000440:	00000000 	nop
20000444:	24420001 	addiu	v0,v0,1
20000448:	3042ffff 	andi	v0,v0,0xffff
2000044c:	2c43028a 	sltiu	v1,v0,650
			stop = 0;
			avoidance = WAIT;
		}
		break;
	case FOLLOW_L:
		movement_G = Lf;
20000450:	af8400ec 	sw	a0,236(gp)

		if(++stop >= 13*HAMMER_TIME)
20000454:	14600002 	bnez	v1,20000460 <object_detection_Update+0x25c>
20000458:	a7820000 	sh	v0,0(gp)
		{
			lastAvoidance = STRAIGHT;
2000045c:	af800100 	sw	zero,256(gp)
		}
		if((sensorReadings.IRLeft <= IR_MAX) || (lastAvoidance == STRAIGHT))
20000460:	3c024000 	lui	v0,0x4000
20000464:	8c4203dc 	lw	v0,988(v0)
20000468:	00000000 	nop
2000046c:	2c420018 	sltiu	v0,v0,24
20000470:	14400005 	bnez	v0,20000488 <object_detection_Update+0x284>
20000474:	24020005 	li	v0,5
20000478:	8f820100 	lw	v0,256(gp)
2000047c:	00000000 	nop
20000480:	14400022 	bnez	v0,2000050c <object_detection_Update+0x308>
20000484:	24020005 	li	v0,5
		{
			stop = 0;
			avoidance = WAIT;
20000488:	af8200fc 	sw	v0,252(gp)
		{
			lastAvoidance = STRAIGHT;
		}
		if((sensorReadings.IRLeft <= IR_MAX) || (lastAvoidance == STRAIGHT))
		{
			stop = 0;
2000048c:	a7800000 	sh	zero,0(gp)
		else
		break;
	case FOLLOW_R:
		movement_G = Rt;

		if(++stop >= 13*HAMMER_TIME)
20000490:	97820000 	lhu	v0,0(gp)
			avoidance = WAIT;
		}
		else
		break;
	case FOLLOW_R:
		movement_G = Rt;
20000494:	24040004 	li	a0,4

		if(++stop >= 13*HAMMER_TIME)
20000498:	24420001 	addiu	v0,v0,1
2000049c:	3042ffff 	andi	v0,v0,0xffff
200004a0:	2c43028a 	sltiu	v1,v0,650
			avoidance = WAIT;
		}
		else
		break;
	case FOLLOW_R:
		movement_G = Rt;
200004a4:	af8400ec 	sw	a0,236(gp)

		if(++stop >= 13*HAMMER_TIME)
200004a8:	14600002 	bnez	v1,200004b4 <object_detection_Update+0x2b0>
200004ac:	a7820000 	sh	v0,0(gp)
		{
			lastAvoidance = STRAIGHT;
200004b0:	af800100 	sw	zero,256(gp)
		}
		if((sensorReadings.IRRight <= IR_MAX) || (lastAvoidance == STRAIGHT))
200004b4:	3c024000 	lui	v0,0x4000
200004b8:	8c4203e0 	lw	v0,992(v0)
200004bc:	00000000 	nop
200004c0:	2c420018 	sltiu	v0,v0,24
200004c4:	14400005 	bnez	v0,200004dc <object_detection_Update+0x2d8>
200004c8:	24020005 	li	v0,5
200004cc:	8f820100 	lw	v0,256(gp)
200004d0:	00000000 	nop
200004d4:	1440000d 	bnez	v0,2000050c <object_detection_Update+0x308>
200004d8:	24020005 	li	v0,5
		{
			stop = 0;
			avoidance = WAIT;
200004dc:	af8200fc 	sw	v0,252(gp)
		{
			lastAvoidance = STRAIGHT;
		}
		if((sensorReadings.IRRight <= IR_MAX) || (lastAvoidance == STRAIGHT))
		{
			stop = 0;
200004e0:	03e00008 	jr	ra
200004e4:	a7800000 	sh	zero,0(gp)
			avoidance = WAIT;
		}
		break;
	case WAIT:
		movement_G = Stp;
		if(++stop >= HAMMER_TIME)
200004e8:	97820000 	lhu	v0,0(gp)
			stop = 0;
			avoidance = WAIT;
		}
		break;
	case WAIT:
		movement_G = Stp;
200004ec:	af8000ec 	sw	zero,236(gp)
		if(++stop >= HAMMER_TIME)
200004f0:	24420001 	addiu	v0,v0,1
200004f4:	3042ffff 	andi	v0,v0,0xffff
200004f8:	2c430032 	sltiu	v1,v0,50
200004fc:	14600003 	bnez	v1,2000050c <object_detection_Update+0x308>
20000500:	a7820000 	sh	v0,0(gp)
		{
			avoidance = STRAIGHT;
20000504:	af8000fc 	sw	zero,252(gp)
			stop = 0;
20000508:	a7800000 	sh	zero,0(gp)
2000050c:	03e00008 	jr	ra
20000510:	00000000 	nop

20000514 <System_Control_Init>:
 * This will be called from Tasks_Init by default.
 */
void System_Control_Init(void)
{
	/* Port initialisation */
	GPIO_Set_Direction(Red_Cord_SW, GPIO_INPUT);
20000514:	3c028000 	lui	v0,0x8000
20000518:	34430500 	ori	v1,v0,0x500
2000051c:	8c650004 	lw	a1,4(v1)
20000520:	2404fffe 	li	a0,-2
20000524:	00a42024 	and	a0,a1,a0
20000528:	ac640004 	sw	a0,4(v1)
2000052c:	8c640004 	lw	a0,4(v1)
	GPIO_Set_Direction(Blue_Cord_SW, GPIO_INPUT);

	GPIO_Set_Direction(Error_Lamp, GPIO_OUTPUT);
20000530:	34420200 	ori	v0,v0,0x200
 * This will be called from Tasks_Init by default.
 */
void System_Control_Init(void)
{
	/* Port initialisation */
	GPIO_Set_Direction(Red_Cord_SW, GPIO_INPUT);
20000534:	ac640004 	sw	a0,4(v1)
	GPIO_Set_Direction(Blue_Cord_SW, GPIO_INPUT);
20000538:	8c650004 	lw	a1,4(v1)
2000053c:	2404fffd 	li	a0,-3
20000540:	00a42024 	and	a0,a1,a0
20000544:	ac640004 	sw	a0,4(v1)
20000548:	8c650004 	lw	a1,4(v1)

	GPIO_Set_Direction(Error_Lamp, GPIO_OUTPUT);
2000054c:	2404feff 	li	a0,-257
 */
void System_Control_Init(void)
{
	/* Port initialisation */
	GPIO_Set_Direction(Red_Cord_SW, GPIO_INPUT);
	GPIO_Set_Direction(Blue_Cord_SW, GPIO_INPUT);
20000550:	ac650004 	sw	a1,4(v1)

	GPIO_Set_Direction(Error_Lamp, GPIO_OUTPUT);
20000554:	8c450004 	lw	a1,4(v0)
	GPIO_Write(Error_Lamp, GPIO_LOW);

	GPIO_Set_Direction(Ready_Lamp_Rd, GPIO_OUTPUT);
20000558:	2406ffbf 	li	a2,-65
{
	/* Port initialisation */
	GPIO_Set_Direction(Red_Cord_SW, GPIO_INPUT);
	GPIO_Set_Direction(Blue_Cord_SW, GPIO_INPUT);

	GPIO_Set_Direction(Error_Lamp, GPIO_OUTPUT);
2000055c:	00a42824 	and	a1,a1,a0
20000560:	ac450004 	sw	a1,4(v0)
20000564:	8c470004 	lw	a3,4(v0)
	GPIO_Write(Error_Lamp, GPIO_LOW);

	GPIO_Set_Direction(Ready_Lamp_Rd, GPIO_OUTPUT);
	GPIO_Write(Ready_Lamp_Rd, GPIO_LOW);

	GPIO_Set_Direction(Ready_Lamp_Bl, GPIO_OUTPUT);
20000568:	2405ff7f 	li	a1,-129
{
	/* Port initialisation */
	GPIO_Set_Direction(Red_Cord_SW, GPIO_INPUT);
	GPIO_Set_Direction(Blue_Cord_SW, GPIO_INPUT);

	GPIO_Set_Direction(Error_Lamp, GPIO_OUTPUT);
2000056c:	34e70100 	ori	a3,a3,0x100
20000570:	ac470004 	sw	a3,4(v0)
	GPIO_Write(Error_Lamp, GPIO_LOW);
20000574:	8c470000 	lw	a3,0(v0)
20000578:	00000000 	nop
2000057c:	00e42024 	and	a0,a3,a0
20000580:	ac440000 	sw	a0,0(v0)
20000584:	8c440000 	lw	a0,0(v0)
20000588:	00000000 	nop
2000058c:	ac440000 	sw	a0,0(v0)

	GPIO_Set_Direction(Ready_Lamp_Rd, GPIO_OUTPUT);
20000590:	8c470004 	lw	a3,4(v0)
	GPIO_Write(Ready_Lamp_Rd, GPIO_LOW);

	GPIO_Set_Direction(Ready_Lamp_Bl, GPIO_OUTPUT);
	GPIO_Write(Ready_Lamp_Bl, GPIO_LOW);

	GPIO_Set_Direction(KILL_ALL, GPIO_OUTPUT);
20000594:	3c040080 	lui	a0,0x80
	GPIO_Set_Direction(Blue_Cord_SW, GPIO_INPUT);

	GPIO_Set_Direction(Error_Lamp, GPIO_OUTPUT);
	GPIO_Write(Error_Lamp, GPIO_LOW);

	GPIO_Set_Direction(Ready_Lamp_Rd, GPIO_OUTPUT);
20000598:	00e63824 	and	a3,a3,a2
2000059c:	ac470004 	sw	a3,4(v0)
200005a0:	8c470004 	lw	a3,4(v0)
200005a4:	00000000 	nop
200005a8:	34e70040 	ori	a3,a3,0x40
200005ac:	ac470004 	sw	a3,4(v0)
	GPIO_Write(Ready_Lamp_Rd, GPIO_LOW);
200005b0:	8c470000 	lw	a3,0(v0)
200005b4:	00000000 	nop
200005b8:	00e63024 	and	a2,a3,a2
200005bc:	ac460000 	sw	a2,0(v0)
200005c0:	8c460000 	lw	a2,0(v0)
200005c4:	00000000 	nop
200005c8:	ac460000 	sw	a2,0(v0)

	GPIO_Set_Direction(Ready_Lamp_Bl, GPIO_OUTPUT);
200005cc:	8c460004 	lw	a2,4(v0)
200005d0:	00000000 	nop
200005d4:	00c53024 	and	a2,a2,a1
200005d8:	ac460004 	sw	a2,4(v0)
200005dc:	8c460004 	lw	a2,4(v0)
200005e0:	00000000 	nop
200005e4:	34c60080 	ori	a2,a2,0x80
200005e8:	ac460004 	sw	a2,4(v0)
	GPIO_Write(Ready_Lamp_Bl, GPIO_LOW);
200005ec:	8c460000 	lw	a2,0(v0)
200005f0:	00000000 	nop
200005f4:	00c52824 	and	a1,a2,a1
200005f8:	ac450000 	sw	a1,0(v0)
200005fc:	8c450000 	lw	a1,0(v0)
20000600:	00000000 	nop
20000604:	ac450000 	sw	a1,0(v0)

	GPIO_Set_Direction(KILL_ALL, GPIO_OUTPUT);
20000608:	8c650004 	lw	a1,4(v1)
2000060c:	3c02ff7f 	lui	v0,0xff7f
20000610:	3442ffff 	ori	v0,v0,0xffff
20000614:	00a21024 	and	v0,a1,v0
20000618:	ac620004 	sw	v0,4(v1)
2000061c:	8c620004 	lw	v0,4(v1)
	GPIO_Write(KILL_ALL, GPIO_HIGH);

	/* State and orientation initialisation */
	System_Mode_G = Ready;
20000620:	af800104 	sw	zero,260(gp)
	GPIO_Write(Ready_Lamp_Rd, GPIO_LOW);

	GPIO_Set_Direction(Ready_Lamp_Bl, GPIO_OUTPUT);
	GPIO_Write(Ready_Lamp_Bl, GPIO_LOW);

	GPIO_Set_Direction(KILL_ALL, GPIO_OUTPUT);
20000624:	00441025 	or	v0,v0,a0
20000628:	ac620004 	sw	v0,4(v1)
	GPIO_Write(KILL_ALL, GPIO_HIGH);
2000062c:	8c620000 	lw	v0,0(v1)

	/* State and orientation initialisation */
	System_Mode_G = Ready;
	debounce = 0;
20000630:	a3800108 	sb	zero,264(gp)

	GPIO_Set_Direction(Ready_Lamp_Bl, GPIO_OUTPUT);
	GPIO_Write(Ready_Lamp_Bl, GPIO_LOW);

	GPIO_Set_Direction(KILL_ALL, GPIO_OUTPUT);
	GPIO_Write(KILL_ALL, GPIO_HIGH);
20000634:	ac620000 	sw	v0,0(v1)
20000638:	8c620000 	lw	v0,0(v1)
2000063c:	00000000 	nop
20000640:	00442025 	or	a0,v0,a0
20000644:	ac640000 	sw	a0,0(v1)

	/* State and orientation initialisation */
	System_Mode_G = Ready;
	debounce = 0;
}
20000648:	03e00008 	jr	ra
2000064c:	00000000 	nop

20000650 <System_Control_Update>:
/**
 * Main system mode control
 */
void System_Control_Update(void)
{
	switch(System_Mode_G)
20000650:	8f820104 	lw	v0,260(gp)
20000654:	24030002 	li	v1,2
20000658:	10430027 	beq	v0,v1,200006f8 <System_Control_Update+0xa8>
2000065c:	2c440003 	sltiu	a0,v0,3
20000660:	10800007 	beqz	a0,20000680 <System_Control_Update+0x30>
20000664:	00000000 	nop
20000668:	1040000d 	beqz	v0,200006a0 <System_Control_Update+0x50>
2000066c:	24040001 	li	a0,1
20000670:	1444005f 	bne	v0,a0,200007f0 <System_Control_Update+0x1a0>
20000674:	3c028000 	lui	v0,0x8000
		break;

	/* Wait for removal of pull cord to "Go" */
	case Set:
		if(
				(GPIO_Get(Red_Cord_SW) == GPIO_HIGH)
20000678:	080001ab 	j	200006ac <System_Control_Update+0x5c>
2000067c:	34420500 	ori	v0,v0,0x500
/**
 * Main system mode control
 */
void System_Control_Update(void)
{
	switch(System_Mode_G)
20000680:	24030003 	li	v1,3
20000684:	10430024 	beq	v0,v1,20000718 <System_Control_Update+0xc8>
20000688:	00000000 	nop
2000068c:	24030004 	li	v1,4
20000690:	14430057 	bne	v0,v1,200007f0 <System_Control_Update+0x1a0>
20000694:	3c028000 	lui	v0,0x8000
		GPIO_Write(Ready_Lamp_Bl, GPIO_HIGH);
		break;

	/* Signal Game Over */
	case Game_Over:
		GPIO_Write(KILL_ALL, GPIO_LOW);
20000698:	080001e4 	j	20000790 <System_Control_Update+0x140>
2000069c:	34430500 	ori	v1,v0,0x500
	switch(System_Mode_G)
	{
	/* Wait for pull cord to determine direction */
	case Ready:

		movement_G = Fd;
200006a0:	24020001 	li	v0,1
200006a4:	080001bc 	j	200006f0 <System_Control_Update+0xa0>
200006a8:	af8200ec 	sw	v0,236(gp)
		break;

	/* Wait for removal of pull cord to "Go" */
	case Set:
		if(
				(GPIO_Get(Red_Cord_SW) == GPIO_HIGH)
200006ac:	8c440000 	lw	a0,0(v0)
200006b0:	00000000 	nop
		System_Mode_G = Go;
		break;

	/* Wait for removal of pull cord to "Go" */
	case Set:
		if(
200006b4:	30840001 	andi	a0,a0,0x1
200006b8:	10800065 	beqz	a0,20000850 <System_Control_Update+0x200>
200006bc:	00000000 	nop
				(GPIO_Get(Red_Cord_SW) == GPIO_HIGH)
				&&
				(GPIO_Get(Blue_Cord_SW) == GPIO_HIGH)
200006c0:	8c420000 	lw	v0,0(v0)
200006c4:	00000000 	nop
		System_Mode_G = Go;
		break;

	/* Wait for removal of pull cord to "Go" */
	case Set:
		if(
200006c8:	30420002 	andi	v0,v0,0x2
200006cc:	10400060 	beqz	v0,20000850 <System_Control_Update+0x200>
200006d0:	00000000 	nop
				(GPIO_Get(Red_Cord_SW) == GPIO_HIGH)
				&&
				(GPIO_Get(Blue_Cord_SW) == GPIO_HIGH)
				&&
				(++debounce > 100)
200006d4:	93820108 	lbu	v0,264(gp)
200006d8:	00000000 	nop
200006dc:	24420001 	addiu	v0,v0,1
200006e0:	304200ff 	andi	v0,v0,0xff
		System_Mode_G = Go;
		break;

	/* Wait for removal of pull cord to "Go" */
	case Set:
		if(
200006e4:	2c440065 	sltiu	a0,v0,101
200006e8:	1480003f 	bnez	a0,200007e8 <System_Control_Update+0x198>
200006ec:	a3820108 	sb	v0,264(gp)
				(GPIO_Get(Blue_Cord_SW) == GPIO_HIGH)
				&&
				(++debounce > 100)
		)
		{
			System_Mode_G = Go;
200006f0:	03e00008 	jr	ra
200006f4:	af830104 	sw	v1,260(gp)
		}
		break;

	/* Do nothing */
	case Go:
		GPIO_Write(Ready_Lamp_Rd, GPIO_HIGH);
200006f8:	3c028000 	lui	v0,0x8000
200006fc:	34420200 	ori	v0,v0,0x200
20000700:	8c430000 	lw	v1,0(v0)
		debounce = 0;
20000704:	a3800108 	sb	zero,264(gp)
		}
		break;

	/* Do nothing */
	case Go:
		GPIO_Write(Ready_Lamp_Rd, GPIO_HIGH);
20000708:	ac430000 	sw	v1,0(v0)
2000070c:	8c430000 	lw	v1,0(v0)
20000710:	080001f9 	j	200007e4 <System_Control_Update+0x194>
20000714:	34630040 	ori	v1,v1,0x40
		debounce = 0;
		break;

	/* Signal E Stop */
	case E_Stop:
		GPIO_Write(KILL_ALL, GPIO_LOW);
20000718:	3c028000 	lui	v0,0x8000
2000071c:	34430500 	ori	v1,v0,0x500
20000720:	8c650000 	lw	a1,0(v1)
20000724:	3c04ff7f 	lui	a0,0xff7f
20000728:	3484ffff 	ori	a0,a0,0xffff
2000072c:	00a42024 	and	a0,a1,a0
20000730:	ac640000 	sw	a0,0(v1)
20000734:	8c640000 	lw	a0,0(v1)
		//GPIO_Set_Direction(KILL_ALL, GPIO_INPUT);
		GPIO_Write(Error_Lamp, GPIO_HIGH);
20000738:	34420200 	ori	v0,v0,0x200
		debounce = 0;
		break;

	/* Signal E Stop */
	case E_Stop:
		GPIO_Write(KILL_ALL, GPIO_LOW);
2000073c:	ac640000 	sw	a0,0(v1)
		//GPIO_Set_Direction(KILL_ALL, GPIO_INPUT);
		GPIO_Write(Error_Lamp, GPIO_HIGH);
20000740:	8c430000 	lw	v1,0(v0)
20000744:	00000000 	nop
20000748:	ac430000 	sw	v1,0(v0)
2000074c:	8c430000 	lw	v1,0(v0)
20000750:	00000000 	nop
20000754:	34630100 	ori	v1,v1,0x100
20000758:	ac430000 	sw	v1,0(v0)
		GPIO_Write(Ready_Lamp_Rd, GPIO_HIGH);
2000075c:	8c430000 	lw	v1,0(v0)
20000760:	00000000 	nop
20000764:	ac430000 	sw	v1,0(v0)
20000768:	8c430000 	lw	v1,0(v0)
2000076c:	00000000 	nop
20000770:	34630040 	ori	v1,v1,0x40
20000774:	ac430000 	sw	v1,0(v0)
		GPIO_Write(Ready_Lamp_Bl, GPIO_HIGH);
20000778:	8c430000 	lw	v1,0(v0)
2000077c:	00000000 	nop
20000780:	ac430000 	sw	v1,0(v0)
20000784:	8c430000 	lw	v1,0(v0)
20000788:	080001f9 	j	200007e4 <System_Control_Update+0x194>
2000078c:	34630080 	ori	v1,v1,0x80
		break;

	/* Signal Game Over */
	case Game_Over:
		GPIO_Write(KILL_ALL, GPIO_LOW);
20000790:	8c650000 	lw	a1,0(v1)
20000794:	3c04ff7f 	lui	a0,0xff7f
20000798:	3484ffff 	ori	a0,a0,0xffff
2000079c:	00a42024 	and	a0,a1,a0
200007a0:	ac640000 	sw	a0,0(v1)
200007a4:	8c640000 	lw	a0,0(v1)
		//GPIO_Set_Direction(KILL_ALL, GPIO_INPUT);
		GPIO_Write(Ready_Lamp_Rd, GPIO_LOW);
200007a8:	34420200 	ori	v0,v0,0x200
		GPIO_Write(Ready_Lamp_Bl, GPIO_HIGH);
		break;

	/* Signal Game Over */
	case Game_Over:
		GPIO_Write(KILL_ALL, GPIO_LOW);
200007ac:	ac640000 	sw	a0,0(v1)
		//GPIO_Set_Direction(KILL_ALL, GPIO_INPUT);
		GPIO_Write(Ready_Lamp_Rd, GPIO_LOW);
200007b0:	8c440000 	lw	a0,0(v0)
200007b4:	2403ffbf 	li	v1,-65
200007b8:	00831824 	and	v1,a0,v1
200007bc:	ac430000 	sw	v1,0(v0)
200007c0:	8c430000 	lw	v1,0(v0)
		GPIO_Write(Ready_Lamp_Bl, GPIO_LOW);
		System_Mode_G = Ready; // TODO: Remove!
200007c4:	af800104 	sw	zero,260(gp)

	/* Signal Game Over */
	case Game_Over:
		GPIO_Write(KILL_ALL, GPIO_LOW);
		//GPIO_Set_Direction(KILL_ALL, GPIO_INPUT);
		GPIO_Write(Ready_Lamp_Rd, GPIO_LOW);
200007c8:	ac430000 	sw	v1,0(v0)
		GPIO_Write(Ready_Lamp_Bl, GPIO_LOW);
200007cc:	8c440000 	lw	a0,0(v0)
200007d0:	2403ff7f 	li	v1,-129
200007d4:	00831824 	and	v1,a0,v1
200007d8:	ac430000 	sw	v1,0(v0)
200007dc:	8c430000 	lw	v1,0(v0)
200007e0:	00000000 	nop
200007e4:	ac430000 	sw	v1,0(v0)
		System_Mode_G = Ready; // TODO: Remove!
		break;
200007e8:	03e00008 	jr	ra
200007ec:	00000000 	nop

	default:
		GPIO_Write(KILL_ALL, GPIO_LOW);
200007f0:	3c028000 	lui	v0,0x8000
200007f4:	34430500 	ori	v1,v0,0x500
200007f8:	8c650000 	lw	a1,0(v1)
200007fc:	3c04ff7f 	lui	a0,0xff7f
20000800:	3484ffff 	ori	a0,a0,0xffff
20000804:	00a42024 	and	a0,a1,a0
20000808:	ac640000 	sw	a0,0(v1)
2000080c:	8c640000 	lw	a0,0(v1)
		//GPIO_Set_Direction(KILL_ALL, GPIO_INPUT);
		GPIO_Write(Ready_Lamp_Rd, GPIO_HIGH);
20000810:	34420200 	ori	v0,v0,0x200
		GPIO_Write(Ready_Lamp_Bl, GPIO_LOW);
		System_Mode_G = Ready; // TODO: Remove!
		break;

	default:
		GPIO_Write(KILL_ALL, GPIO_LOW);
20000814:	ac640000 	sw	a0,0(v1)
		//GPIO_Set_Direction(KILL_ALL, GPIO_INPUT);
		GPIO_Write(Ready_Lamp_Rd, GPIO_HIGH);
20000818:	8c430000 	lw	v1,0(v0)
2000081c:	00000000 	nop
20000820:	ac430000 	sw	v1,0(v0)
20000824:	8c430000 	lw	v1,0(v0)
20000828:	00000000 	nop
2000082c:	34630040 	ori	v1,v1,0x40
20000830:	ac430000 	sw	v1,0(v0)
		GPIO_Write(Ready_Lamp_Bl, GPIO_HIGH);
20000834:	8c430000 	lw	v1,0(v0)
20000838:	00000000 	nop
2000083c:	ac430000 	sw	v1,0(v0)
20000840:	8c430000 	lw	v1,0(v0)
20000844:	00000000 	nop
20000848:	34630080 	ori	v1,v1,0x80
2000084c:	ac430000 	sw	v1,0(v0)
20000850:	03e00008 	jr	ra
20000854:	00000000 	nop

20000858 <Read_Enc_Init>:
 * Initialisation for the Read_Enc package.
 * This will be called from Tasks_Init by default.
 */
void Read_Enc_Init(void)
{
	GPIO_Set_Direction(EncL_CH_A, GPIO_INPUT);
20000858:	3c028000 	lui	v0,0x8000
2000085c:	34420500 	ori	v0,v0,0x500
20000860:	8c440004 	lw	a0,4(v0)
20000864:	2403fbff 	li	v1,-1025
20000868:	00831824 	and	v1,a0,v1
2000086c:	ac430004 	sw	v1,4(v0)
20000870:	8c430004 	lw	v1,4(v0)
	GPIO_Set_Direction(EncR_CH_B, GPIO_INPUT);

	WheelCounts_Left_G = 0;
	WheelCounts_Right_G = 0;

	EncSignal_A[0] = 0;								/* Signal A from left encoder */
20000874:	af800114 	sw	zero,276(gp)
 * Initialisation for the Read_Enc package.
 * This will be called from Tasks_Init by default.
 */
void Read_Enc_Init(void)
{
	GPIO_Set_Direction(EncL_CH_A, GPIO_INPUT);
20000878:	ac430004 	sw	v1,4(v0)
	GPIO_Set_Direction(EncL_CH_B, GPIO_INPUT);
2000087c:	8c440004 	lw	a0,4(v0)
20000880:	2403f7ff 	li	v1,-2049
20000884:	00831824 	and	v1,a0,v1
20000888:	ac430004 	sw	v1,4(v0)
2000088c:	8c430004 	lw	v1,4(v0)

	WheelCounts_Left_G = 0;
	WheelCounts_Right_G = 0;

	EncSignal_A[0] = 0;								/* Signal A from left encoder */
	EncSignal_B[0] = 0;								/* Signal B from left encoder */
20000890:	af800124 	sw	zero,292(gp)
 * This will be called from Tasks_Init by default.
 */
void Read_Enc_Init(void)
{
	GPIO_Set_Direction(EncL_CH_A, GPIO_INPUT);
	GPIO_Set_Direction(EncL_CH_B, GPIO_INPUT);
20000894:	ac430004 	sw	v1,4(v0)
	GPIO_Set_Direction(EncR_CH_A, GPIO_INPUT);
20000898:	8c440004 	lw	a0,4(v0)
2000089c:	3c03fff7 	lui	v1,0xfff7
200008a0:	3463ffff 	ori	v1,v1,0xffff
200008a4:	00831824 	and	v1,a0,v1
200008a8:	ac430004 	sw	v1,4(v0)
200008ac:	8c430004 	lw	v1,4(v0)
	WheelCounts_Right_G = 0;

	EncSignal_A[0] = 0;								/* Signal A from left encoder */
	EncSignal_B[0] = 0;								/* Signal B from left encoder */

	EncSignal_A[1] = 0;								/* Signal A from right encoder */
200008b0:	af800118 	sw	zero,280(gp)
 */
void Read_Enc_Init(void)
{
	GPIO_Set_Direction(EncL_CH_A, GPIO_INPUT);
	GPIO_Set_Direction(EncL_CH_B, GPIO_INPUT);
	GPIO_Set_Direction(EncR_CH_A, GPIO_INPUT);
200008b4:	ac430004 	sw	v1,4(v0)
	GPIO_Set_Direction(EncR_CH_B, GPIO_INPUT);
200008b8:	8c440004 	lw	a0,4(v0)
200008bc:	3c03fffb 	lui	v1,0xfffb
200008c0:	3463ffff 	ori	v1,v1,0xffff
200008c4:	00831824 	and	v1,a0,v1

	WheelCounts_Left_G = 0;
200008c8:	af800088 	sw	zero,136(gp)
void Read_Enc_Init(void)
{
	GPIO_Set_Direction(EncL_CH_A, GPIO_INPUT);
	GPIO_Set_Direction(EncL_CH_B, GPIO_INPUT);
	GPIO_Set_Direction(EncR_CH_A, GPIO_INPUT);
	GPIO_Set_Direction(EncR_CH_B, GPIO_INPUT);
200008cc:	ac430004 	sw	v1,4(v0)
200008d0:	8c430004 	lw	v1,4(v0)

	EncSignal_A[0] = 0;								/* Signal A from left encoder */
	EncSignal_B[0] = 0;								/* Signal B from left encoder */

	EncSignal_A[1] = 0;								/* Signal A from right encoder */
	EncSignal_B[1] = 0;								/* Signal B from right encoder */
200008d4:	af800128 	sw	zero,296(gp)
	GPIO_Set_Direction(EncL_CH_B, GPIO_INPUT);
	GPIO_Set_Direction(EncR_CH_A, GPIO_INPUT);
	GPIO_Set_Direction(EncR_CH_B, GPIO_INPUT);

	WheelCounts_Left_G = 0;
	WheelCounts_Right_G = 0;
200008d8:	af8000c8 	sw	zero,200(gp)
void Read_Enc_Init(void)
{
	GPIO_Set_Direction(EncL_CH_A, GPIO_INPUT);
	GPIO_Set_Direction(EncL_CH_B, GPIO_INPUT);
	GPIO_Set_Direction(EncR_CH_A, GPIO_INPUT);
	GPIO_Set_Direction(EncR_CH_B, GPIO_INPUT);
200008dc:	ac430004 	sw	v1,4(v0)

	EncSignal_A[1] = 0;								/* Signal A from right encoder */
	EncSignal_B[1] = 0;								/* Signal B from right encoder */

	/* Left */
	RevCount[0] = 0;
200008e0:	af80011c 	sw	zero,284(gp)
	EncoderCount[0] = 0;
200008e4:	af80012c 	sw	zero,300(gp)
	WheelCount[0] = 0;
200008e8:	af80010c 	sw	zero,268(gp)

	/* Right */
	RevCount[1] = 0;
200008ec:	af800120 	sw	zero,288(gp)
	EncoderCount[1] = 0;
200008f0:	af800130 	sw	zero,304(gp)
	WheelCount[1] = 0;
200008f4:	af800110 	sw	zero,272(gp)

	bufferTime = 0;
}
200008f8:	03e00008 	jr	ra
200008fc:	a3800134 	sb	zero,308(gp)

20000900 <Read_Enc_Update>:
/**
 * Reads the value of the Encoders
 */
void Read_Enc_Update(void)
{
	if(System_Mode_G == Go)
20000900:	8f830104 	lw	v1,260(gp)
20000904:	24020002 	li	v0,2
20000908:	1462005d 	bne	v1,v0,20000a80 <Read_Enc_Update+0x180>
2000090c:	3c028000 	lui	v0,0x8000
	{
		/* Read signals from encoders */
		EncSignal_A[0] = GPIO_Get(EncL_CH_A);	/* Left_A;	Signal A from left encoder */
20000910:	34420500 	ori	v0,v0,0x500
20000914:	8c450000 	lw	a1,0(v0)
		EncSignal_B[0] = GPIO_Get(EncL_CH_B);	/* Left_B;	Signal B from left encoder */
20000918:	8c440000 	lw	a0,0(v0)

		EncSignal_A[1] = GPIO_Get(EncR_CH_A);	/* Right_A;	Signal A from right encoder */
2000091c:	8c430000 	lw	v1,0(v0)
		EncSignal_B[1] = GPIO_Get(EncR_CH_B);	/* Right_B;	Signal B from right encoder */
20000920:	8c420000 	lw	v0,0(v0)
void Read_Enc_Update(void)
{
	if(System_Mode_G == Go)
	{
		/* Read signals from encoders */
		EncSignal_A[0] = GPIO_Get(EncL_CH_A);	/* Left_A;	Signal A from left encoder */
20000924:	00052a82 	srl	a1,a1,0xa
		EncSignal_B[0] = GPIO_Get(EncL_CH_B);	/* Left_B;	Signal B from left encoder */
20000928:	000422c2 	srl	a0,a0,0xb

		EncSignal_A[1] = GPIO_Get(EncR_CH_A);	/* Right_A;	Signal A from right encoder */
2000092c:	00031cc2 	srl	v1,v1,0x13
		EncSignal_B[1] = GPIO_Get(EncR_CH_B);	/* Right_B;	Signal B from right encoder */
20000930:	00021482 	srl	v0,v0,0x12
void Read_Enc_Update(void)
{
	if(System_Mode_G == Go)
	{
		/* Read signals from encoders */
		EncSignal_A[0] = GPIO_Get(EncL_CH_A);	/* Left_A;	Signal A from left encoder */
20000934:	30a50001 	andi	a1,a1,0x1
		EncSignal_B[0] = GPIO_Get(EncL_CH_B);	/* Left_B;	Signal B from left encoder */
20000938:	30840001 	andi	a0,a0,0x1

		EncSignal_A[1] = GPIO_Get(EncR_CH_A);	/* Right_A;	Signal A from right encoder */
2000093c:	30630001 	andi	v1,v1,0x1
		EncSignal_B[1] = GPIO_Get(EncR_CH_B);	/* Right_B;	Signal B from right encoder */
20000940:	30420001 	andi	v0,v0,0x1
void Read_Enc_Update(void)
{
	if(System_Mode_G == Go)
	{
		/* Read signals from encoders */
		EncSignal_A[0] = GPIO_Get(EncL_CH_A);	/* Left_A;	Signal A from left encoder */
20000944:	af850114 	sw	a1,276(gp)
		EncSignal_B[0] = GPIO_Get(EncL_CH_B);	/* Left_B;	Signal B from left encoder */
20000948:	af840124 	sw	a0,292(gp)

		EncSignal_A[1] = GPIO_Get(EncR_CH_A);	/* Right_A;	Signal A from right encoder */
2000094c:	af830118 	sw	v1,280(gp)
		EncSignal_B[1] = GPIO_Get(EncR_CH_B);	/* Right_B;	Signal B from right encoder */
20000950:	af820128 	sw	v0,296(gp)
20000954:	27840140 	addiu	a0,gp,320
20000958:	2783012c 	addiu	v1,gp,300
2000095c:	27860138 	addiu	a2,gp,312
20000960:	27890114 	addiu	t1,gp,276
20000964:	27880124 	addiu	t0,gp,292
20000968:	00002821 	move	a1,zero

		/* Loop through both sides */
		for(uint8_t i = 0; i <= 1; i ++)
		{
			if(Pulse_Flag[i] == High)
2000096c:	24020001 	li	v0,1
				}

				/* Full cycle detection when both signals dropped off */
				else if((EncSignal_A[i] == Low) && (EncSignal_B[i] == Low))
				{
					switch(WheelDirection[i])
20000970:	240a0002 	li	t2,2
				WheelDirection[i] = WheelDirection[i];
				Pulse_Flag[i] = Pulse_Flag[i];
			}

			/* Calculate total counts for wheel */
			WheelCount[i] = ((RevCount[i] * ROBOT_ENC_COUNTS_PER_REV) + EncoderCount[i]);
20000974:	278e010c 	addiu	t6,gp,268
20000978:	278d011c 	addiu	t5,gp,284

		EncSignal_A[1] = GPIO_Get(EncR_CH_A);	/* Right_A;	Signal A from right encoder */
		EncSignal_B[1] = GPIO_Get(EncR_CH_B);	/* Right_B;	Signal B from right encoder */

		/* Loop through both sides */
		for(uint8_t i = 0; i <= 1; i ++)
2000097c:	240c0008 	li	t4,8
		{
			if(Pulse_Flag[i] == High)
20000980:	8c8b0000 	lw	t3,0(a0)
20000984:	8d270000 	lw	a3,0(t1)
20000988:	15620020 	bne	t3,v0,20000a0c <Read_Enc_Update+0x10c>
2000098c:	00000000 	nop
			{
				/* Direction detection on single signal drop-off */
				if(EncSignal_A[i] != EncSignal_B[i])
20000990:	8d0b0000 	lw	t3,0(t0)
20000994:	00000000 	nop
20000998:	10eb0009 	beq	a3,t3,200009c0 <Read_Enc_Update+0xc0>
2000099c:	00000000 	nop
				{
					switch(EncSignal_A[i])
200009a0:	10e00005 	beqz	a3,200009b8 <Read_Enc_Update+0xb8>
200009a4:	00000000 	nop
200009a8:	14e20022 	bne	a3,v0,20000a34 <Read_Enc_Update+0x134>
200009ac:	00ad3821 	addu	a3,a1,t5
					{
						case High:
							WheelDirection[i] = Reverse;
							break;
200009b0:	0800028d 	j	20000a34 <Read_Enc_Update+0x134>
200009b4:	acca0000 	sw	t2,0(a2)
						case Low:
							WheelDirection[i] = Forwards;
200009b8:	0800028c 	j	20000a30 <Read_Enc_Update+0x130>
200009bc:	acc20000 	sw	v0,0(a2)
							break;
					}
				}

				/* Full cycle detection when both signals dropped off */
				else if((EncSignal_A[i] == Low) && (EncSignal_B[i] == Low))
200009c0:	14e0001c 	bnez	a3,20000a34 <Read_Enc_Update+0x134>
200009c4:	00ad3821 	addu	a3,a1,t5
				{
					switch(WheelDirection[i])
200009c8:	8cc70000 	lw	a3,0(a2)
200009cc:	00000000 	nop
200009d0:	10e20005 	beq	a3,v0,200009e8 <Read_Enc_Update+0xe8>
200009d4:	00000000 	nop
200009d8:	14ea000a 	bne	a3,t2,20000a04 <Read_Enc_Update+0x104>
200009dc:	00000000 	nop
200009e0:	0800027d 	j	200009f4 <Read_Enc_Update+0xf4>
200009e4:	00000000 	nop
					{
						case Forwards:
							EncoderCount[i] ++;
200009e8:	8c670000 	lw	a3,0(v1)
200009ec:	08000280 	j	20000a00 <Read_Enc_Update+0x100>
200009f0:	24e70001 	addiu	a3,a3,1
							break;
						case Reverse:
							EncoderCount[i] --;
200009f4:	8c670000 	lw	a3,0(v1)
200009f8:	00000000 	nop
200009fc:	24e7ffff 	addiu	a3,a3,-1
20000a00:	ac670000 	sw	a3,0(v1)
						case Off:
							break;
						default:
							break;
					}
					Pulse_Flag[i] = Low;
20000a04:	0800028c 	j	20000a30 <Read_Enc_Update+0x130>
20000a08:	ac800000 	sw	zero,0(a0)
				}
			}
			/* Wait for both A and B to be high to raise Pulse_Flag */
			else if((EncSignal_A[i] == High) && (EncSignal_B[i] == High))
20000a0c:	14e20007 	bne	a3,v0,20000a2c <Read_Enc_Update+0x12c>
20000a10:	00000000 	nop
20000a14:	8d070000 	lw	a3,0(t0)
20000a18:	00000000 	nop
20000a1c:	14e20003 	bne	a3,v0,20000a2c <Read_Enc_Update+0x12c>
20000a20:	00000000 	nop
20000a24:	0800028c 	j	20000a30 <Read_Enc_Update+0x130>
20000a28:	ac820000 	sw	v0,0(a0)
			/* ET Padding to reduce jitter */
			else
			{
				EncoderCount[i] = EncoderCount[i];
				WheelDirection[i] = WheelDirection[i];
				Pulse_Flag[i] = Pulse_Flag[i];
20000a2c:	ac8b0000 	sw	t3,0(a0)
			}

			/* Calculate total counts for wheel */
			WheelCount[i] = ((RevCount[i] * ROBOT_ENC_COUNTS_PER_REV) + EncoderCount[i]);
20000a30:	00ad3821 	addu	a3,a1,t5
20000a34:	8ceb0000 	lw	t3,0(a3)
20000a38:	8c670000 	lw	a3,0(v1)
20000a3c:	000b59c0 	sll	t3,t3,0x7
20000a40:	01675821 	addu	t3,t3,a3
20000a44:	00ae3821 	addu	a3,a1,t6
20000a48:	24a50004 	addiu	a1,a1,4
20000a4c:	aceb0000 	sw	t3,0(a3)
20000a50:	24840004 	addiu	a0,a0,4
20000a54:	24630004 	addiu	v1,v1,4
20000a58:	24c60004 	addiu	a2,a2,4
20000a5c:	25290004 	addiu	t1,t1,4

		EncSignal_A[1] = GPIO_Get(EncR_CH_A);	/* Right_A;	Signal A from right encoder */
		EncSignal_B[1] = GPIO_Get(EncR_CH_B);	/* Right_B;	Signal B from right encoder */

		/* Loop through both sides */
		for(uint8_t i = 0; i <= 1; i ++)
20000a60:	14acffc7 	bne	a1,t4,20000980 <Read_Enc_Update+0x80>
20000a64:	25080004 	addiu	t0,t0,4
			/* Calculate total counts for wheel */
			WheelCount[i] = ((RevCount[i] * ROBOT_ENC_COUNTS_PER_REV) + EncoderCount[i]);
		}

		/* Output distance wheels have travelled to global variable */
		WheelCounts_Left_G = WheelCount[0];
20000a68:	8f82010c 	lw	v0,268(gp)
20000a6c:	00000000 	nop
20000a70:	af820088 	sw	v0,136(gp)
		WheelCounts_Right_G = WheelCount[1];
20000a74:	8f820110 	lw	v0,272(gp)
20000a78:	03e00008 	jr	ra
20000a7c:	af8200c8 	sw	v0,200(gp)
	}
	else
	{
		WheelCount[0] = 0;
20000a80:	af80010c 	sw	zero,268(gp)
		WheelCount[1] = 0;
20000a84:	03e00008 	jr	ra
20000a88:	af800110 	sw	zero,272(gp)

20000a8c <speedControlRight>:

uint16_t speedControlRight(Bool correctionL, Bool correctionR)
{
	static uint16_t speed;

	if(Right_motor_speed_G == 0)
20000a8c:	978200b2 	lhu	v0,178(gp)
20000a90:	00000000 	nop
20000a94:	14400002 	bnez	v0,20000aa0 <speedControlRight+0x14>
20000a98:	2402000f 	li	v0,15
	{
		Right_motor_speed_G = CRAWL_SPEED;
20000a9c:	a78200b2 	sh	v0,178(gp)
	}

	if((correctionL == False) && (correctionR == True))
20000aa0:	14800006 	bnez	a0,20000abc <speedControlRight+0x30>
20000aa4:	24020001 	li	v0,1
20000aa8:	14a2000c 	bne	a1,v0,20000adc <speedControlRight+0x50>
20000aac:	00000000 	nop
	{
		Right_motor_speed_G++;
20000ab0:	978200b2 	lhu	v0,178(gp)
20000ab4:	080002b6 	j	20000ad8 <speedControlRight+0x4c>
20000ab8:	24420001 	addiu	v0,v0,1
	}
	else if((correctionL == True) && (correctionR == False))
20000abc:	14820007 	bne	a0,v0,20000adc <speedControlRight+0x50>
20000ac0:	00000000 	nop
20000ac4:	14a00005 	bnez	a1,20000adc <speedControlRight+0x50>
20000ac8:	00000000 	nop
	{
		Right_motor_speed_G--;
20000acc:	978200b2 	lhu	v0,178(gp)
20000ad0:	00000000 	nop
20000ad4:	2442ffff 	addiu	v0,v0,-1
20000ad8:	a78200b2 	sh	v0,178(gp)
	}

	if(Right_motor_speed_G < (CRAWL_SPEED - CORRECTION_VALUE_LOWER))
20000adc:	978200b2 	lhu	v0,178(gp)
20000ae0:	00000000 	nop
20000ae4:	2c42000f 	sltiu	v0,v0,15
20000ae8:	10400002 	beqz	v0,20000af4 <speedControlRight+0x68>
20000aec:	2402000f 	li	v0,15
	{
		Right_motor_speed_G = (CRAWL_SPEED - CORRECTION_VALUE_LOWER);
20000af0:	a78200b2 	sh	v0,178(gp)
	}

	if(Right_motor_speed_G > (CRAWL_SPEED + CORRECTION_VALUE_UPPER))
20000af4:	978200b2 	lhu	v0,178(gp)
20000af8:	00000000 	nop
20000afc:	2c420012 	sltiu	v0,v0,18
20000b00:	14400003 	bnez	v0,20000b10 <speedControlRight+0x84>
20000b04:	00000000 	nop
	{
		Right_motor_speed_G = CRAWL_SPEED + CORRECTION_VALUE_UPPER;
20000b08:	24020011 	li	v0,17
20000b0c:	a78200b2 	sh	v0,178(gp)
	}

	return speed;
}
20000b10:	03e00008 	jr	ra
20000b14:	00001021 	move	v0,zero

20000b18 <visualsRt>:
	return result;
}

void visualsRt(void)
{
	if(System_Mode_G == Go || System_Mode_G == Game_Over)
20000b18:	8f820104 	lw	v0,260(gp)
	result = (uint16_t)(speed);
	return result;
}

void visualsRt(void)
{
20000b1c:	27bdffe0 	addiu	sp,sp,-32
	if(System_Mode_G == Go || System_Mode_G == Game_Over)
20000b20:	24030002 	li	v1,2
	result = (uint16_t)(speed);
	return result;
}

void visualsRt(void)
{
20000b24:	afbf001c 	sw	ra,28(sp)
20000b28:	afb10018 	sw	s1,24(sp)
	if(System_Mode_G == Go || System_Mode_G == Game_Over)
20000b2c:	10430004 	beq	v0,v1,20000b40 <visualsRt+0x28>
20000b30:	afb00014 	sw	s0,20(sp)
20000b34:	24030004 	li	v1,4
20000b38:	14430009 	bne	v0,v1,20000b60 <visualsRt+0x48>
20000b3c:	00000000 	nop
	{
		Segment_Set_Decimal(displayA);
20000b40:	8f84ffdc 	lw	a0,-36(gp)
20000b44:	0c000b4e 	jal	20002d38 <Segment_Set_Decimal>
20000b48:	00000000 	nop
		Segment_Set_Decimal(displayB);
20000b4c:	8f84ffe0 	lw	a0,-32(gp)
20000b50:	0c000b4e 	jal	20002d38 <Segment_Set_Decimal>
20000b54:	00000000 	nop
	return result;
}

void visualsRt(void)
{
	if(System_Mode_G == Go || System_Mode_G == Game_Over)
20000b58:	080002de 	j	20000b78 <visualsRt+0x60>
20000b5c:	00000000 	nop
		Segment_Set_Decimal(displayA);
		Segment_Set_Decimal(displayB);
	}
	else
	{
		Segment_Clear_Decimal(displayA);
20000b60:	8f84ffdc 	lw	a0,-36(gp)
20000b64:	0c000b28 	jal	20002ca0 <Segment_Clear_Decimal>
20000b68:	00000000 	nop
		Segment_Clear_Decimal(displayB);
20000b6c:	8f84ffe0 	lw	a0,-32(gp)
20000b70:	0c000b28 	jal	20002ca0 <Segment_Clear_Decimal>
20000b74:	00000000 	nop
	}

	if(
		Right_motor_direction_G == Forwards
		&& Right_motor_speed_G != 0
20000b78:	8f830084 	lw	v1,132(gp)
	{
		Segment_Clear_Decimal(displayA);
		Segment_Clear_Decimal(displayB);
	}

	if(
20000b7c:	24020001 	li	v0,1
20000b80:	1462000f 	bne	v1,v0,20000bc0 <visualsRt+0xa8>
20000b84:	3c028000 	lui	v0,0x8000
20000b88:	978200b2 	lhu	v0,178(gp)
20000b8c:	00000000 	nop
20000b90:	1040000b 	beqz	v0,20000bc0 <visualsRt+0xa8>
20000b94:	3c028000 	lui	v0,0x8000
		Right_motor_direction_G == Forwards
		&& Right_motor_speed_G != 0
		)
	{
		GPIO_Write(LED_Pin_RtFd, GPIO_HIGH);
20000b98:	34420200 	ori	v0,v0,0x200
20000b9c:	8c430000 	lw	v1,0(v0)
20000ba0:	00000000 	nop
20000ba4:	ac430000 	sw	v1,0(v0)
20000ba8:	8c430000 	lw	v1,0(v0)
20000bac:	00000000 	nop
20000bb0:	34630002 	ori	v1,v1,0x2
20000bb4:	ac430000 	sw	v1,0(v0)
20000bb8:	080002ff 	j	20000bfc <visualsRt+0xe4>
20000bbc:	00000000 	nop
	}
	else
	{
		GPIO_Write(LED_Pin_RtFd, GPIO_LOW);
20000bc0:	34420200 	ori	v0,v0,0x200
20000bc4:	8c450000 	lw	a1,0(v0)
20000bc8:	2404fffd 	li	a0,-3
20000bcc:	00a42024 	and	a0,a1,a0
20000bd0:	ac440000 	sw	a0,0(v0)
20000bd4:	8c440000 	lw	a0,0(v0)
20000bd8:	00000000 	nop
20000bdc:	ac440000 	sw	a0,0(v0)
	}

	if(( Right_motor_direction_G == Reverse && Right_motor_speed_G != 0) || (Course_correction_Rt == True))
20000be0:	24020002 	li	v0,2
20000be4:	14620005 	bne	v1,v0,20000bfc <visualsRt+0xe4>
20000be8:	00000000 	nop
20000bec:	978200b2 	lhu	v0,178(gp)
20000bf0:	00000000 	nop
20000bf4:	14400005 	bnez	v0,20000c0c <visualsRt+0xf4>
20000bf8:	3c028000 	lui	v0,0x8000
20000bfc:	8f830064 	lw	v1,100(gp)
20000c00:	24020001 	li	v0,1
20000c04:	14620008 	bne	v1,v0,20000c28 <visualsRt+0x110>
20000c08:	3c028000 	lui	v0,0x8000
	{
		GPIO_Write(LED_Pin_RtBd, GPIO_HIGH);
20000c0c:	34420200 	ori	v0,v0,0x200
20000c10:	8c430000 	lw	v1,0(v0)
20000c14:	00000000 	nop
20000c18:	ac430000 	sw	v1,0(v0)
20000c1c:	8c430000 	lw	v1,0(v0)
20000c20:	08000310 	j	20000c40 <visualsRt+0x128>
20000c24:	34630001 	ori	v1,v1,0x1
	}
	else
	{
		GPIO_Write(LED_Pin_RtBd, GPIO_LOW);
20000c28:	34420200 	ori	v0,v0,0x200
20000c2c:	8c440000 	lw	a0,0(v0)
20000c30:	2403fffe 	li	v1,-2
20000c34:	00831824 	and	v1,a0,v1
20000c38:	ac430000 	sw	v1,0(v0)
20000c3c:	8c430000 	lw	v1,0(v0)

//	Segment_Write(displayA, (sensorReadings.USFwd & 0x000F) >> 0);
//	Segment_Write(displayB, (sensorReadings.USFwd & 0x00F0) >> 4);
//	Segment_Write(displayC, (bufferRX0.ID & 0x000F) >> 0);

	Segment_Write(displayA, (sensorReadings.IRRight & 0x000F) >> 0);
20000c40:	3c104000 	lui	s0,0x4000
	{
		GPIO_Write(LED_Pin_RtBd, GPIO_HIGH);
	}
	else
	{
		GPIO_Write(LED_Pin_RtBd, GPIO_LOW);
20000c44:	ac430000 	sw	v1,0(v0)

//	Segment_Write(displayA, (sensorReadings.USFwd & 0x000F) >> 0);
//	Segment_Write(displayB, (sensorReadings.USFwd & 0x00F0) >> 4);
//	Segment_Write(displayC, (bufferRX0.ID & 0x000F) >> 0);

	Segment_Write(displayA, (sensorReadings.IRRight & 0x000F) >> 0);
20000c48:	261103dc 	addiu	s1,s0,988
20000c4c:	92250004 	lbu	a1,4(s1)
20000c50:	8f84ffdc 	lw	a0,-36(gp)
20000c54:	0c000b73 	jal	20002dcc <Segment_Write>
20000c58:	30a5000f 	andi	a1,a1,0xf
	Segment_Write(displayB, (sensorReadings.IRRight & 0x00F0) >> 4);
20000c5c:	8e250004 	lw	a1,4(s1)
20000c60:	8f84ffe0 	lw	a0,-32(gp)
20000c64:	30a500f0 	andi	a1,a1,0xf0
20000c68:	0c000b73 	jal	20002dcc <Segment_Write>
20000c6c:	00052902 	srl	a1,a1,0x4
	Segment_Write(displayC, (sensorReadings.IRLeft & 0x000F) >> 0);
20000c70:	920503dc 	lbu	a1,988(s0)
20000c74:	8f84ffe4 	lw	a0,-28(gp)
20000c78:	0c000b73 	jal	20002dcc <Segment_Write>
20000c7c:	30a5000f 	andi	a1,a1,0xf
	Segment_Write(displayD, (sensorReadings.IRLeft & 0x00F0) >> 4);
20000c80:	8e0503dc 	lw	a1,988(s0)
20000c84:	8f84ffe8 	lw	a0,-24(gp)
20000c88:	30a500f0 	andi	a1,a1,0xf0

}
20000c8c:	8fbf001c 	lw	ra,28(sp)
20000c90:	8fb10018 	lw	s1,24(sp)
20000c94:	8fb00014 	lw	s0,20(sp)
//	Segment_Write(displayC, (bufferRX0.ID & 0x000F) >> 0);

	Segment_Write(displayA, (sensorReadings.IRRight & 0x000F) >> 0);
	Segment_Write(displayB, (sensorReadings.IRRight & 0x00F0) >> 4);
	Segment_Write(displayC, (sensorReadings.IRLeft & 0x000F) >> 0);
	Segment_Write(displayD, (sensorReadings.IRLeft & 0x00F0) >> 4);
20000c98:	00052902 	srl	a1,a1,0x4
20000c9c:	08000b73 	j	20002dcc <Segment_Write>
20000ca0:	27bd0020 	addiu	sp,sp,32

20000ca4 <Motor_Right_Update>:
/**
 * Motor_Right controller operation
 */
void Motor_Right_Update(void)
{
	if(System_Mode_G == Go)
20000ca4:	8f850104 	lw	a1,260(gp)

/**
 * Motor_Right controller operation
 */
void Motor_Right_Update(void)
{
20000ca8:	27bdffe8 	addiu	sp,sp,-24
	if(System_Mode_G == Go)
20000cac:	24020002 	li	v0,2
20000cb0:	14a20034 	bne	a1,v0,20000d84 <Motor_Right_Update+0xe0>
20000cb4:	afbf0014 	sw	ra,20(sp)
	{
		/* Calculate the absolute value of encoder counts since previous update */
		Enc_Rt_Diff = (WheelCounts_Right_G - Enc_Rt_Old);
20000cb8:	8f8400c8 	lw	a0,200(gp)
20000cbc:	8f830150 	lw	v1,336(gp)

		/* Encoder counting */
		if(movement_G == Fd || movement_G == Lf)
20000cc0:	8f8200ec 	lw	v0,236(gp)
void Motor_Right_Update(void)
{
	if(System_Mode_G == Go)
	{
		/* Calculate the absolute value of encoder counts since previous update */
		Enc_Rt_Diff = (WheelCounts_Right_G - Enc_Rt_Old);
20000cc4:	00831823 	subu	v1,a0,v1

		/* Encoder counting */
		if(movement_G == Fd || movement_G == Lf)
20000cc8:	24060001 	li	a2,1
20000ccc:	10460004 	beq	v0,a2,20000ce0 <Motor_Right_Update+0x3c>
20000cd0:	af830154 	sw	v1,340(gp)
20000cd4:	24060003 	li	a2,3
20000cd8:	14460004 	bne	v0,a2,20000cec <Motor_Right_Update+0x48>
20000cdc:	00000000 	nop
		{
			Motor_Rt_Enc_Track += Enc_Rt_Diff;
20000ce0:	8f8500d8 	lw	a1,216(gp)
20000ce4:	08000342 	j	20000d08 <Motor_Right_Update+0x64>
20000ce8:	00a31821 	addu	v1,a1,v1
		}
		else if(movement_G == Bd || movement_G == Rt)
20000cec:	10450003 	beq	v0,a1,20000cfc <Motor_Right_Update+0x58>
20000cf0:	24050004 	li	a1,4
20000cf4:	14450005 	bne	v0,a1,20000d0c <Motor_Right_Update+0x68>
20000cf8:	00000000 	nop
		{
			Motor_Rt_Enc_Track -= Enc_Rt_Diff;
20000cfc:	8f8500d8 	lw	a1,216(gp)
20000d00:	00000000 	nop
20000d04:	00a31823 	subu	v1,a1,v1
20000d08:	af8300d8 	sw	v1,216(gp)
		}

		Enc_Rt_Old = WheelCounts_Right_G;

		/* Script reader */
		switch(movement_G)
20000d0c:	24030002 	li	v1,2
20000d10:	10430017 	beq	v0,v1,20000d70 <Motor_Right_Update+0xcc>
20000d14:	af840150 	sw	a0,336(gp)
20000d18:	2c430003 	sltiu	v1,v0,3
20000d1c:	10600006 	beqz	v1,20000d38 <Motor_Right_Update+0x94>
20000d20:	24030003 	li	v1,3
20000d24:	24030001 	li	v1,1
20000d28:	14430017 	bne	v0,v1,20000d88 <Motor_Right_Update+0xe4>
20000d2c:	00000000 	nop
20000d30:	08000354 	j	20000d50 <Motor_Right_Update+0xac>
20000d34:	00000000 	nop
20000d38:	1043000b 	beq	v0,v1,20000d68 <Motor_Right_Update+0xc4>
20000d3c:	24030004 	li	v1,4
20000d40:	14430011 	bne	v0,v1,20000d88 <Motor_Right_Update+0xe4>
20000d44:	24020002 	li	v0,2
			Right_motor_direction_G = Forwards;
			Right_motor_speed_G = CRAWL_SPEED-4;
			break;
		case Bd:
		case Rt:
			Right_motor_direction_G = Reverse;
20000d48:	0800035e 	j	20000d78 <Motor_Right_Update+0xd4>
20000d4c:	af820084 	sw	v0,132(gp)
		/* Script reader */
		switch(movement_G)
		{
		case Fd:
			Right_motor_direction_G = Forwards;
			speedControlRight(Course_correction_Lf, Course_correction_Rt);
20000d50:	8f840074 	lw	a0,116(gp)
20000d54:	8f850064 	lw	a1,100(gp)
20000d58:	0c0002a3 	jal	20000a8c <speedControlRight>
20000d5c:	af820084 	sw	v0,132(gp)
			break;
20000d60:	08000366 	j	20000d98 <Motor_Right_Update+0xf4>
20000d64:	00000000 	nop
		case Lf:
			Right_motor_direction_G = Forwards;
20000d68:	0800035d 	j	20000d74 <Motor_Right_Update+0xd0>
20000d6c:	24020001 	li	v0,1
			Right_motor_speed_G = CRAWL_SPEED-4;
			break;
		case Bd:
		case Rt:
			Right_motor_direction_G = Reverse;
20000d70:	24020002 	li	v0,2
20000d74:	af820084 	sw	v0,132(gp)
			Right_motor_speed_G = CRAWL_SPEED-4;
20000d78:	2402000b 	li	v0,11
			break;
20000d7c:	08000366 	j	20000d98 <Motor_Right_Update+0xf4>
20000d80:	a78200b2 	sh	v0,178(gp)
			break;
		}
	}
	else
	{
		Right_motor_direction_G = Off;
20000d84:	af800084 	sw	zero,132(gp)
		Right_motor_speed_G = 0;
20000d88:	a78000b2 	sh	zero,178(gp)
		Motor_Rt_Enc_Track = 0;
20000d8c:	af8000d8 	sw	zero,216(gp)
		Enc_Rt_Diff = 0;
20000d90:	af800154 	sw	zero,340(gp)
		Enc_Rt_Old = 0;
20000d94:	af800150 	sw	zero,336(gp)
	}

	visualsRt();
}
20000d98:	8fbf0014 	lw	ra,20(sp)
		Motor_Rt_Enc_Track = 0;
		Enc_Rt_Diff = 0;
		Enc_Rt_Old = 0;
	}

	visualsRt();
20000d9c:	080002c6 	j	20000b18 <visualsRt>
20000da0:	27bd0018 	addiu	sp,sp,24

20000da4 <Motor_Right_Init>:
	/* Task initialisation */
	Right_motor_direction_G = Off;
	Right_motor_speed_G = 0;
	Motor_Rt_Enc_Track = 0;

	GPIO_Set_Direction(LED_Pin_RtFd, GPIO_OUTPUT);
20000da4:	3c038000 	lui	v1,0x8000
20000da8:	34620200 	ori	v0,v1,0x200
20000dac:	8c450004 	lw	a1,4(v0)
20000db0:	2404fffd 	li	a0,-3
20000db4:	00a42824 	and	a1,a1,a0
20000db8:	ac450004 	sw	a1,4(v0)
20000dbc:	8c460004 	lw	a2,4(v0)
	GPIO_Write(LED_Pin_RtFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_RtBd, GPIO_OUTPUT);
20000dc0:	2405fffe 	li	a1,-2
	/* Task initialisation */
	Right_motor_direction_G = Off;
	Right_motor_speed_G = 0;
	Motor_Rt_Enc_Track = 0;

	GPIO_Set_Direction(LED_Pin_RtFd, GPIO_OUTPUT);
20000dc4:	34c60002 	ori	a2,a2,0x2
20000dc8:	ac460004 	sw	a2,4(v0)
	GPIO_Write(LED_Pin_RtFd, GPIO_LOW);
20000dcc:	8c460000 	lw	a2,0(v0)
	GPIO_Set_Direction(LED_Pin_RtBd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_RtBd, GPIO_LOW);
	GPIO_Set_Direction(Right_SW, GPIO_INPUT);
20000dd0:	34630500 	ori	v1,v1,0x500
	Right_motor_direction_G = Off;
	Right_motor_speed_G = 0;
	Motor_Rt_Enc_Track = 0;

	GPIO_Set_Direction(LED_Pin_RtFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_RtFd, GPIO_LOW);
20000dd4:	00c42024 	and	a0,a2,a0
20000dd8:	ac440000 	sw	a0,0(v0)
20000ddc:	8c440000 	lw	a0,0(v0)
/**
 * Initialisation for the Motor_Right package.
 * This will be called from Tasks_Init by default.
 */
void Motor_Right_Init(void)
{
20000de0:	27bdffe8 	addiu	sp,sp,-24
	Right_motor_direction_G = Off;
	Right_motor_speed_G = 0;
	Motor_Rt_Enc_Track = 0;

	GPIO_Set_Direction(LED_Pin_RtFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_RtFd, GPIO_LOW);
20000de4:	ac440000 	sw	a0,0(v0)
	GPIO_Set_Direction(LED_Pin_RtBd, GPIO_OUTPUT);
20000de8:	8c460004 	lw	a2,4(v0)
	GPIO_Write(LED_Pin_RtBd, GPIO_LOW);
	GPIO_Set_Direction(Right_SW, GPIO_INPUT);

	Segment_Enable(displayA);
20000dec:	8f84ffdc 	lw	a0,-36(gp)
	Right_motor_speed_G = 0;
	Motor_Rt_Enc_Track = 0;

	GPIO_Set_Direction(LED_Pin_RtFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_RtFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_RtBd, GPIO_OUTPUT);
20000df0:	00c53024 	and	a2,a2,a1
20000df4:	ac460004 	sw	a2,4(v0)
20000df8:	8c460004 	lw	a2,4(v0)
/**
 * Initialisation for the Motor_Right package.
 * This will be called from Tasks_Init by default.
 */
void Motor_Right_Init(void)
{
20000dfc:	afbf0014 	sw	ra,20(sp)
	Right_motor_speed_G = 0;
	Motor_Rt_Enc_Track = 0;

	GPIO_Set_Direction(LED_Pin_RtFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_RtFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_RtBd, GPIO_OUTPUT);
20000e00:	34c60001 	ori	a2,a2,0x1
20000e04:	ac460004 	sw	a2,4(v0)
	GPIO_Write(LED_Pin_RtBd, GPIO_LOW);
20000e08:	8c460000 	lw	a2,0(v0)
 * This will be called from Tasks_Init by default.
 */
void Motor_Right_Init(void)
{
	/* Task initialisation */
	Right_motor_direction_G = Off;
20000e0c:	af800084 	sw	zero,132(gp)
	Motor_Rt_Enc_Track = 0;

	GPIO_Set_Direction(LED_Pin_RtFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_RtFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_RtBd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_RtBd, GPIO_LOW);
20000e10:	00c52824 	and	a1,a2,a1
20000e14:	ac450000 	sw	a1,0(v0)
20000e18:	8c450000 	lw	a1,0(v0)
void Motor_Right_Init(void)
{
	/* Task initialisation */
	Right_motor_direction_G = Off;
	Right_motor_speed_G = 0;
	Motor_Rt_Enc_Track = 0;
20000e1c:	af8000d8 	sw	zero,216(gp)

	GPIO_Set_Direction(LED_Pin_RtFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_RtFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_RtBd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_RtBd, GPIO_LOW);
20000e20:	ac450000 	sw	a1,0(v0)
	GPIO_Set_Direction(Right_SW, GPIO_INPUT);
20000e24:	8c650004 	lw	a1,4(v1)
20000e28:	2402ffdf 	li	v0,-33
20000e2c:	00a21024 	and	v0,a1,v0
20000e30:	ac620004 	sw	v0,4(v1)
20000e34:	8c620004 	lw	v0,4(v1)
 */
void Motor_Right_Init(void)
{
	/* Task initialisation */
	Right_motor_direction_G = Off;
	Right_motor_speed_G = 0;
20000e38:	a78000b2 	sh	zero,178(gp)

	GPIO_Set_Direction(LED_Pin_RtFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_RtFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_RtBd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_RtBd, GPIO_LOW);
	GPIO_Set_Direction(Right_SW, GPIO_INPUT);
20000e3c:	ac620004 	sw	v0,4(v1)

	Segment_Enable(displayA);
20000e40:	0c000ba0 	jal	20002e80 <Segment_Enable>
20000e44:	00000000 	nop
	Segment_Write(displayA, 0x0);
20000e48:	8f84ffdc 	lw	a0,-36(gp)
20000e4c:	0c000b73 	jal	20002dcc <Segment_Write>
20000e50:	00002821 	move	a1,zero
	Segment_Clear_Decimal(displayA);
20000e54:	8f84ffdc 	lw	a0,-36(gp)
20000e58:	0c000b28 	jal	20002ca0 <Segment_Clear_Decimal>
20000e5c:	00000000 	nop
	Segment_Enable(displayB);
20000e60:	8f84ffe0 	lw	a0,-32(gp)
20000e64:	0c000ba0 	jal	20002e80 <Segment_Enable>
20000e68:	00000000 	nop
	Segment_Write(displayB, 0x0);
20000e6c:	8f84ffe0 	lw	a0,-32(gp)
20000e70:	0c000b73 	jal	20002dcc <Segment_Write>
20000e74:	00002821 	move	a1,zero
	Segment_Clear_Decimal(displayB);
20000e78:	8f84ffe0 	lw	a0,-32(gp)
}
20000e7c:	8fbf0014 	lw	ra,20(sp)
	Segment_Enable(displayA);
	Segment_Write(displayA, 0x0);
	Segment_Clear_Decimal(displayA);
	Segment_Enable(displayB);
	Segment_Write(displayB, 0x0);
	Segment_Clear_Decimal(displayB);
20000e80:	08000b28 	j	20002ca0 <Segment_Clear_Decimal>
20000e84:	27bd0018 	addiu	sp,sp,24

20000e88 <visualsLf>:
	return result;
}

void visualsLf(void)
{
	if(System_Mode_G == Game_Over)
20000e88:	8f830104 	lw	v1,260(gp)
	result = (uint16_t)(speed);
	return result;
}

void visualsLf(void)
{
20000e8c:	27bdffe8 	addiu	sp,sp,-24
	if(System_Mode_G == Game_Over)
20000e90:	24020004 	li	v0,4
20000e94:	14620009 	bne	v1,v0,20000ebc <visualsLf+0x34>
20000e98:	afbf0014 	sw	ra,20(sp)
	{
		Segment_Set_Decimal(displayC);
20000e9c:	8f84ffec 	lw	a0,-20(gp)
20000ea0:	0c000b4e 	jal	20002d38 <Segment_Set_Decimal>
20000ea4:	00000000 	nop
		Segment_Set_Decimal(displayD);
20000ea8:	8f84fff0 	lw	a0,-16(gp)
20000eac:	0c000b4e 	jal	20002d38 <Segment_Set_Decimal>
20000eb0:	00000000 	nop
20000eb4:	080003b5 	j	20000ed4 <visualsLf+0x4c>
20000eb8:	00000000 	nop
	}
	else
	{
		Segment_Clear_Decimal(displayC);
20000ebc:	8f84ffec 	lw	a0,-20(gp)
20000ec0:	0c000b28 	jal	20002ca0 <Segment_Clear_Decimal>
20000ec4:	00000000 	nop
		Segment_Clear_Decimal(displayD);
20000ec8:	8f84fff0 	lw	a0,-16(gp)
20000ecc:	0c000b28 	jal	20002ca0 <Segment_Clear_Decimal>
20000ed0:	00000000 	nop
	}

	if(
		Left_motor_direction_G == Forwards
		&& Left_motor_speed_G != 0
20000ed4:	8f830094 	lw	v1,148(gp)
	{
		Segment_Clear_Decimal(displayC);
		Segment_Clear_Decimal(displayD);
	}

	if(
20000ed8:	24020001 	li	v0,1
20000edc:	1462000f 	bne	v1,v0,20000f1c <visualsLf+0x94>
20000ee0:	3c028000 	lui	v0,0x8000
20000ee4:	978200b0 	lhu	v0,176(gp)
20000ee8:	00000000 	nop
20000eec:	1040000b 	beqz	v0,20000f1c <visualsLf+0x94>
20000ef0:	3c028000 	lui	v0,0x8000
		Left_motor_direction_G == Forwards
		&& Left_motor_speed_G != 0
		)
	{
		GPIO_Write(LED_Pin_LfFd, GPIO_HIGH);
20000ef4:	34420200 	ori	v0,v0,0x200
20000ef8:	8c430000 	lw	v1,0(v0)
20000efc:	00000000 	nop
20000f00:	ac430000 	sw	v1,0(v0)
20000f04:	8c430000 	lw	v1,0(v0)
20000f08:	00000000 	nop
20000f0c:	34630008 	ori	v1,v1,0x8
20000f10:	ac430000 	sw	v1,0(v0)
20000f14:	080003d6 	j	20000f58 <visualsLf+0xd0>
20000f18:	00000000 	nop
	}
	else
	{
		GPIO_Write(LED_Pin_LfFd, GPIO_LOW);
20000f1c:	34420200 	ori	v0,v0,0x200
20000f20:	8c450000 	lw	a1,0(v0)
20000f24:	2404fff7 	li	a0,-9
20000f28:	00a42024 	and	a0,a1,a0
20000f2c:	ac440000 	sw	a0,0(v0)
20000f30:	8c440000 	lw	a0,0(v0)
20000f34:	00000000 	nop
20000f38:	ac440000 	sw	a0,0(v0)
	}

	if((Left_motor_direction_G == Reverse && Left_motor_speed_G != 0	) || (Course_correction_Lf == True))
20000f3c:	24020002 	li	v0,2
20000f40:	14620005 	bne	v1,v0,20000f58 <visualsLf+0xd0>
20000f44:	00000000 	nop
20000f48:	978200b0 	lhu	v0,176(gp)
20000f4c:	00000000 	nop
20000f50:	14400005 	bnez	v0,20000f68 <visualsLf+0xe0>
20000f54:	3c028000 	lui	v0,0x8000
20000f58:	8f830074 	lw	v1,116(gp)
20000f5c:	24020001 	li	v0,1
20000f60:	14620008 	bne	v1,v0,20000f84 <visualsLf+0xfc>
20000f64:	3c028000 	lui	v0,0x8000
	{
		GPIO_Write(LED_Pin_LfBd, GPIO_HIGH);
20000f68:	34420200 	ori	v0,v0,0x200
20000f6c:	8c430000 	lw	v1,0(v0)
20000f70:	00000000 	nop
20000f74:	ac430000 	sw	v1,0(v0)
20000f78:	8c430000 	lw	v1,0(v0)
20000f7c:	080003e7 	j	20000f9c <visualsLf+0x114>
20000f80:	34630004 	ori	v1,v1,0x4
	}
	else
	{
		GPIO_Write(LED_Pin_LfBd, GPIO_LOW);
20000f84:	34420200 	ori	v0,v0,0x200
20000f88:	8c440000 	lw	a0,0(v0)
20000f8c:	2403fffb 	li	v1,-5
20000f90:	00831824 	and	v1,a0,v1
20000f94:	ac430000 	sw	v1,0(v0)
20000f98:	8c430000 	lw	v1,0(v0)
	}

//	Segment_Write(displayC, (Motor_Lf_Enc_Track & 0x000F) >> 0);
//	Segment_Write(displayD, (Motor_Lf_Enc_Track & 0x00F0) >> 4);

}
20000f9c:	8fbf0014 	lw	ra,20(sp)
	{
		GPIO_Write(LED_Pin_LfBd, GPIO_HIGH);
	}
	else
	{
		GPIO_Write(LED_Pin_LfBd, GPIO_LOW);
20000fa0:	ac430000 	sw	v1,0(v0)
	}

//	Segment_Write(displayC, (Motor_Lf_Enc_Track & 0x000F) >> 0);
//	Segment_Write(displayD, (Motor_Lf_Enc_Track & 0x00F0) >> 4);

}
20000fa4:	03e00008 	jr	ra
20000fa8:	27bd0018 	addiu	sp,sp,24

20000fac <Motor_Left_Update>:
 * Motor_Left controller operation.
 */
void Motor_Left_Update(void)
{

	if(System_Mode_G == Go)
20000fac:	8f830104 	lw	v1,260(gp)
20000fb0:	24020002 	li	v0,2
20000fb4:	1462002b 	bne	v1,v0,20001064 <Motor_Left_Update+0xb8>
20000fb8:	24050001 	li	a1,1
	{
		/* Calculate the absolute value of encoder counts since previous update */
		Enc_Lf_Diff = (WheelCounts_Left_G - Enc_Lf_Old);
20000fbc:	8f840088 	lw	a0,136(gp)
20000fc0:	8f83015c 	lw	v1,348(gp)

		/* Encoder counting */
		if(movement_G == Fd || movement_G == Rt)
20000fc4:	8f8200ec 	lw	v0,236(gp)
{

	if(System_Mode_G == Go)
	{
		/* Calculate the absolute value of encoder counts since previous update */
		Enc_Lf_Diff = (WheelCounts_Left_G - Enc_Lf_Old);
20000fc8:	00831823 	subu	v1,a0,v1

		/* Encoder counting */
		if(movement_G == Fd || movement_G == Rt)
20000fcc:	10450004 	beq	v0,a1,20000fe0 <Motor_Left_Update+0x34>
20000fd0:	af830158 	sw	v1,344(gp)
20000fd4:	24050004 	li	a1,4
20000fd8:	14450004 	bne	v0,a1,20000fec <Motor_Left_Update+0x40>
20000fdc:	2445fffe 	addiu	a1,v0,-2
		{
			Motor_Lf_Enc_Track += Enc_Lf_Diff;
20000fe0:	8f850040 	lw	a1,64(gp)
20000fe4:	08000401 	j	20001004 <Motor_Left_Update+0x58>
20000fe8:	00a31821 	addu	v1,a1,v1
		}
		else if(movement_G == Bd || movement_G == Lf)
20000fec:	2ca50002 	sltiu	a1,a1,2
20000ff0:	10a00005 	beqz	a1,20001008 <Motor_Left_Update+0x5c>
20000ff4:	00000000 	nop
		{
			Motor_Lf_Enc_Track -= Enc_Lf_Diff;
20000ff8:	8f850040 	lw	a1,64(gp)
20000ffc:	00000000 	nop
20001000:	00a31823 	subu	v1,a1,v1
20001004:	af830040 	sw	v1,64(gp)
		}

		Enc_Lf_Old = WheelCounts_Left_G;

		/* Script reader */
		switch(movement_G)
20001008:	2c430004 	sltiu	v1,v0,4
2000100c:	10600008 	beqz	v1,20001030 <Motor_Left_Update+0x84>
20001010:	af84015c 	sw	a0,348(gp)
20001014:	2c430002 	sltiu	v1,v0,2
20001018:	10600010 	beqz	v1,2000105c <Motor_Left_Update+0xb0>
2000101c:	24030001 	li	v1,1
20001020:	14430011 	bne	v0,v1,20001068 <Motor_Left_Update+0xbc>
20001024:	00000000 	nop
		{
		case Fd:
			/* Check the encoder tracker has reached the target count */
			Left_motor_direction_G = Forwards;
20001028:	08000411 	j	20001044 <Motor_Left_Update+0x98>
2000102c:	af820094 	sw	v0,148(gp)
		}

		Enc_Lf_Old = WheelCounts_Left_G;

		/* Script reader */
		switch(movement_G)
20001030:	24030004 	li	v1,4
20001034:	1443000c 	bne	v0,v1,20001068 <Motor_Left_Update+0xbc>
20001038:	24020001 	li	v0,1
			Left_motor_direction_G = Forwards;
			Left_motor_speed_G = CRAWL_SPEED;
			break;
		case Rt:
			/* Check the encoder tracker has reached the target count */
			Left_motor_direction_G = Forwards;
2000103c:	08000414 	j	20001050 <Motor_Left_Update+0xa4>
20001040:	af820094 	sw	v0,148(gp)
		switch(movement_G)
		{
		case Fd:
			/* Check the encoder tracker has reached the target count */
			Left_motor_direction_G = Forwards;
			Left_motor_speed_G = CRAWL_SPEED;
20001044:	08000415 	j	20001054 <Motor_Left_Update+0xa8>
20001048:	2402000f 	li	v0,15
			break;
		case Rt:
			/* Check the encoder tracker has reached the target count */
			Left_motor_direction_G = Forwards;
2000104c:	af820094 	sw	v0,148(gp)
			Left_motor_speed_G = CRAWL_SPEED-4;
20001050:	2402000b 	li	v0,11

			break;
20001054:	0800041e 	j	20001078 <Motor_Left_Update+0xcc>
20001058:	a78200b0 	sh	v0,176(gp)
		case Bd:
		case Lf:
			Left_motor_direction_G = Reverse;
2000105c:	08000413 	j	2000104c <Motor_Left_Update+0xa0>
20001060:	24020002 	li	v0,2
			break;
		}
	}
	else
	{
		Left_motor_direction_G = Off;
20001064:	af800094 	sw	zero,148(gp)
		Left_motor_speed_G = 0;
20001068:	a78000b0 	sh	zero,176(gp)
		Motor_Lf_Enc_Track = 0;
2000106c:	af800040 	sw	zero,64(gp)
		Enc_Lf_Diff = 0;
20001070:	af800158 	sw	zero,344(gp)
		Enc_Lf_Old = 0;
20001074:	af80015c 	sw	zero,348(gp)
	}

	visualsLf();
20001078:	080003a2 	j	20000e88 <visualsLf>
2000107c:	00000000 	nop

20001080 <Motor_Left_Init>:
	/* Task initialisation */
	Left_motor_direction_G = Off;
	Left_motor_speed_G = 0;
	Motor_Lf_Enc_Track = 0;

	GPIO_Set_Direction(LED_Pin_LfFd, GPIO_OUTPUT);
20001080:	3c038000 	lui	v1,0x8000
20001084:	34620200 	ori	v0,v1,0x200
20001088:	8c440004 	lw	a0,4(v0)
2000108c:	2405fff7 	li	a1,-9
20001090:	00852024 	and	a0,a0,a1
20001094:	ac440004 	sw	a0,4(v0)
20001098:	8c440004 	lw	a0,4(v0)
	GPIO_Write(LED_Pin_LfFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_LfBd, GPIO_OUTPUT);
2000109c:	2406fffb 	li	a2,-5
	/* Task initialisation */
	Left_motor_direction_G = Off;
	Left_motor_speed_G = 0;
	Motor_Lf_Enc_Track = 0;

	GPIO_Set_Direction(LED_Pin_LfFd, GPIO_OUTPUT);
200010a0:	34840008 	ori	a0,a0,0x8
200010a4:	ac440004 	sw	a0,4(v0)
	GPIO_Write(LED_Pin_LfFd, GPIO_LOW);
200010a8:	8c440000 	lw	a0,0(v0)
	GPIO_Set_Direction(LED_Pin_LfBd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_LfBd, GPIO_LOW);
	GPIO_Set_Direction(Left_SW, GPIO_INPUT);
200010ac:	34630500 	ori	v1,v1,0x500
	Left_motor_direction_G = Off;
	Left_motor_speed_G = 0;
	Motor_Lf_Enc_Track = 0;

	GPIO_Set_Direction(LED_Pin_LfFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_LfFd, GPIO_LOW);
200010b0:	00852024 	and	a0,a0,a1
200010b4:	ac440000 	sw	a0,0(v0)
200010b8:	8c470000 	lw	a3,0(v0)
	GPIO_Set_Direction(LED_Pin_LfBd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_LfBd, GPIO_LOW);
	GPIO_Set_Direction(Left_SW, GPIO_INPUT);

	Segment_Enable(displayC);
200010bc:	8f84ffec 	lw	a0,-20(gp)
	Left_motor_direction_G = Off;
	Left_motor_speed_G = 0;
	Motor_Lf_Enc_Track = 0;

	GPIO_Set_Direction(LED_Pin_LfFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_LfFd, GPIO_LOW);
200010c0:	ac470000 	sw	a3,0(v0)
	GPIO_Set_Direction(LED_Pin_LfBd, GPIO_OUTPUT);
200010c4:	8c470004 	lw	a3,4(v0)
/**
 * Initialisation for the Motor_Left package.
 * This will be called from Tasks_Init by default.
 */
void Motor_Left_Init(void)
{
200010c8:	27bdffe8 	addiu	sp,sp,-24
	Left_motor_speed_G = 0;
	Motor_Lf_Enc_Track = 0;

	GPIO_Set_Direction(LED_Pin_LfFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_LfFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_LfBd, GPIO_OUTPUT);
200010cc:	00e63824 	and	a3,a3,a2
200010d0:	ac470004 	sw	a3,4(v0)
200010d4:	8c470004 	lw	a3,4(v0)
/**
 * Initialisation for the Motor_Left package.
 * This will be called from Tasks_Init by default.
 */
void Motor_Left_Init(void)
{
200010d8:	afbf0014 	sw	ra,20(sp)
	Left_motor_speed_G = 0;
	Motor_Lf_Enc_Track = 0;

	GPIO_Set_Direction(LED_Pin_LfFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_LfFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_LfBd, GPIO_OUTPUT);
200010dc:	34e70004 	ori	a3,a3,0x4
200010e0:	ac470004 	sw	a3,4(v0)
	GPIO_Write(LED_Pin_LfBd, GPIO_LOW);
200010e4:	8c470000 	lw	a3,0(v0)
void Motor_Left_Init(void)
{
	/* Task initialisation */
	Left_motor_direction_G = Off;
	Left_motor_speed_G = 0;
	Motor_Lf_Enc_Track = 0;
200010e8:	af800040 	sw	zero,64(gp)

	GPIO_Set_Direction(LED_Pin_LfFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_LfFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_LfBd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_LfBd, GPIO_LOW);
200010ec:	00e63024 	and	a2,a3,a2
200010f0:	ac460000 	sw	a2,0(v0)
200010f4:	8c460000 	lw	a2,0(v0)
 * This will be called from Tasks_Init by default.
 */
void Motor_Left_Init(void)
{
	/* Task initialisation */
	Left_motor_direction_G = Off;
200010f8:	af800094 	sw	zero,148(gp)
	Motor_Lf_Enc_Track = 0;

	GPIO_Set_Direction(LED_Pin_LfFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_LfFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_LfBd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_LfBd, GPIO_LOW);
200010fc:	ac460000 	sw	a2,0(v0)
	GPIO_Set_Direction(Left_SW, GPIO_INPUT);
20001100:	8c620004 	lw	v0,4(v1)
 */
void Motor_Left_Init(void)
{
	/* Task initialisation */
	Left_motor_direction_G = Off;
	Left_motor_speed_G = 0;
20001104:	a78000b0 	sh	zero,176(gp)

	GPIO_Set_Direction(LED_Pin_LfFd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_LfFd, GPIO_LOW);
	GPIO_Set_Direction(LED_Pin_LfBd, GPIO_OUTPUT);
	GPIO_Write(LED_Pin_LfBd, GPIO_LOW);
	GPIO_Set_Direction(Left_SW, GPIO_INPUT);
20001108:	00452824 	and	a1,v0,a1
2000110c:	ac650004 	sw	a1,4(v1)
20001110:	8c620004 	lw	v0,4(v1)
20001114:	00000000 	nop
20001118:	ac620004 	sw	v0,4(v1)

	Segment_Enable(displayC);
2000111c:	0c000ba0 	jal	20002e80 <Segment_Enable>
20001120:	00000000 	nop
	Segment_Write(displayC, 0x0);
20001124:	8f84ffec 	lw	a0,-20(gp)
20001128:	0c000b73 	jal	20002dcc <Segment_Write>
2000112c:	00002821 	move	a1,zero
	Segment_Clear_Decimal(displayC);
20001130:	8f84ffec 	lw	a0,-20(gp)
20001134:	0c000b28 	jal	20002ca0 <Segment_Clear_Decimal>
20001138:	00000000 	nop
	Segment_Enable(displayD);
2000113c:	8f84fff0 	lw	a0,-16(gp)
20001140:	0c000ba0 	jal	20002e80 <Segment_Enable>
20001144:	00000000 	nop
	Segment_Write(displayD, 0x0);
20001148:	8f84fff0 	lw	a0,-16(gp)
2000114c:	0c000b73 	jal	20002dcc <Segment_Write>
20001150:	00002821 	move	a1,zero
	Segment_Clear_Decimal(displayD);
20001154:	8f84fff0 	lw	a0,-16(gp)
}
20001158:	8fbf0014 	lw	ra,20(sp)
	Segment_Enable(displayC);
	Segment_Write(displayC, 0x0);
	Segment_Clear_Decimal(displayC);
	Segment_Enable(displayD);
	Segment_Write(displayD, 0x0);
	Segment_Clear_Decimal(displayD);
2000115c:	08000b28 	j	20002ca0 <Segment_Clear_Decimal>
20001160:	27bd0018 	addiu	sp,sp,24

20001164 <spi_receive_CAN>:
	uint32_t Byte_counter, length;// displayID;

	PAD_ID = 0x0;

	/* Pull CS pin low - indicates start of transmission */
	GPIO_Write(CS_PIN, GPIO_LOW);
20001164:	3c028000 	lui	v0,0x8000
20001168:	34420600 	ori	v0,v0,0x600
2000116c:	8c460000 	lw	a2,0(v0)
20001170:	2403ffbf 	li	v1,-65
20001174:	00c31824 	and	v1,a2,v1
20001178:	ac430000 	sw	v1,0(v0)
2000117c:	8c430000 	lw	v1,0(v0)
/**
 * Processes received CAN messages
 * @param buffer_ins The SPI buffer receive instruction.
 */
void spi_receive_CAN(uint32_t buffer_ins, Receive_Buffers * buffer)
{
20001180:	27bdffe0 	addiu	sp,sp,-32

	PAD_ID = 0x0;

	/* Pull CS pin low - indicates start of transmission */
	GPIO_Write(CS_PIN, GPIO_LOW);
	SPI_Swap(SPI0, buffer_ins);
20001184:	308400ff 	andi	a0,a0,0xff
	uint32_t Byte_counter, length;// displayID;

	PAD_ID = 0x0;

	/* Pull CS pin low - indicates start of transmission */
	GPIO_Write(CS_PIN, GPIO_LOW);
20001188:	ac430000 	sw	v1,0(v0)
/**
 * Processes received CAN messages
 * @param buffer_ins The SPI buffer receive instruction.
 */
void spi_receive_CAN(uint32_t buffer_ins, Receive_Buffers * buffer)
{
2000118c:	afb10014 	sw	s1,20(sp)
20001190:	00a08821 	move	s1,a1

	PAD_ID = 0x0;

	/* Pull CS pin low - indicates start of transmission */
	GPIO_Write(CS_PIN, GPIO_LOW);
	SPI_Swap(SPI0, buffer_ins);
20001194:	00802821 	move	a1,a0
20001198:	00002021 	move	a0,zero
/**
 * Processes received CAN messages
 * @param buffer_ins The SPI buffer receive instruction.
 */
void spi_receive_CAN(uint32_t buffer_ins, Receive_Buffers * buffer)
{
2000119c:	afbf001c 	sw	ra,28(sp)
200011a0:	afb20018 	sw	s2,24(sp)
200011a4:	afb00010 	sw	s0,16(sp)

	PAD_ID = 0x0;

	/* Pull CS pin low - indicates start of transmission */
	GPIO_Write(CS_PIN, GPIO_LOW);
	SPI_Swap(SPI0, buffer_ins);
200011a8:	0c000b14 	jal	20002c50 <SPI_Swap>
200011ac:	af800184 	sw	zero,388(gp)

	/* Burn 5 Bytes: EXT_ID and Length */
	SPI_Swap(SPI0, 0xFF);
200011b0:	00002021 	move	a0,zero
200011b4:	0c000b14 	jal	20002c50 <SPI_Swap>
200011b8:	240500ff 	li	a1,255
	SPI_Swap(SPI0, 0xFF);
200011bc:	00002021 	move	a0,zero
200011c0:	0c000b14 	jal	20002c50 <SPI_Swap>
200011c4:	240500ff 	li	a1,255
	SPI_Swap(SPI0, 0xFF);
200011c8:	00002021 	move	a0,zero
200011cc:	0c000b14 	jal	20002c50 <SPI_Swap>
200011d0:	240500ff 	li	a1,255
	buffer->ID = SPI_Swap(SPI0, 0xFF);
200011d4:	00002021 	move	a0,zero
200011d8:	0c000b14 	jal	20002c50 <SPI_Swap>
200011dc:	240500ff 	li	a1,255
200011e0:	ae220004 	sw	v0,4(s1)
	SPI_Swap(SPI0, 0xFF);
200011e4:	00002021 	move	a0,zero
200011e8:	0c000b14 	jal	20002c50 <SPI_Swap>
200011ec:	240500ff 	li	a1,255
200011f0:	00008021 	move	s0,zero

	/* Known length */
	length = 8;

	/* Extract the CAN data and insert into the Receive Buffer */
	for (Byte_counter = 0; Byte_counter < length; Byte_counter++)
200011f4:	24120008 	li	s2,8
	{
		buffer->CAN_Data[Byte_counter] = SPI_Swap(SPI0, 0xFF);
200011f8:	00002021 	move	a0,zero
200011fc:	0c000b14 	jal	20002c50 <SPI_Swap>
20001200:	240500ff 	li	a1,255
20001204:	02301821 	addu	v1,s1,s0

	/* Known length */
	length = 8;

	/* Extract the CAN data and insert into the Receive Buffer */
	for (Byte_counter = 0; Byte_counter < length; Byte_counter++)
20001208:	26100001 	addiu	s0,s0,1
2000120c:	1612fffa 	bne	s0,s2,200011f8 <spi_receive_CAN+0x94>
20001210:	a0620008 	sb	v0,8(v1)
	{
		buffer->CAN_Data[Byte_counter] = SPI_Swap(SPI0, 0xFF);
	}

	GPIO_Write(CS_PIN, GPIO_HIGH);
20001214:	3c028000 	lui	v0,0x8000
20001218:	34420600 	ori	v0,v0,0x600
2000121c:	8c430000 	lw	v1,0(v0)
}
20001220:	8fbf001c 	lw	ra,28(sp)
	for (Byte_counter = 0; Byte_counter < length; Byte_counter++)
	{
		buffer->CAN_Data[Byte_counter] = SPI_Swap(SPI0, 0xFF);
	}

	GPIO_Write(CS_PIN, GPIO_HIGH);
20001224:	ac430000 	sw	v1,0(v0)
20001228:	8c430000 	lw	v1,0(v0)
}
2000122c:	8fb20018 	lw	s2,24(sp)
	for (Byte_counter = 0; Byte_counter < length; Byte_counter++)
	{
		buffer->CAN_Data[Byte_counter] = SPI_Swap(SPI0, 0xFF);
	}

	GPIO_Write(CS_PIN, GPIO_HIGH);
20001230:	34630040 	ori	v1,v1,0x40
}
20001234:	8fb10014 	lw	s1,20(sp)
20001238:	8fb00010 	lw	s0,16(sp)
	for (Byte_counter = 0; Byte_counter < length; Byte_counter++)
	{
		buffer->CAN_Data[Byte_counter] = SPI_Swap(SPI0, 0xFF);
	}

	GPIO_Write(CS_PIN, GPIO_HIGH);
2000123c:	ac430000 	sw	v1,0(v0)
}
20001240:	03e00008 	jr	ra
20001244:	27bd0020 	addiu	sp,sp,32

20001248 <spi_buffer_CAN>:

	/* Separate Extended ID portion */
	EID = MaskedID & 0x3FFFF;

	/* Combine Standard ID, 3 padding bits and Extended ID */
	PAD_ID = ((SID | 0x80000) | EID);
20001248:	3c020003 	lui	v0,0x3

	/* Mask 4 bytes of CAN ID */
	MaskedID = CAN_ID & 0xFFFFFFFF;

	/* Separate Standard ID portion and shift for extra 3 bits */
	SID = MaskedID & 0x1FFC0000;
2000124c:	3c031ffc 	lui	v1,0x1ffc

	/* Separate Extended ID portion */
	EID = MaskedID & 0x3FFFF;

	/* Combine Standard ID, 3 padding bits and Extended ID */
	PAD_ID = ((SID | 0x80000) | EID);
20001250:	3442ffff 	ori	v0,v0,0xffff
20001254:	00821024 	and	v0,a0,v0

	/* Mask 4 bytes of CAN ID */
	MaskedID = CAN_ID & 0xFFFFFFFF;

	/* Separate Standard ID portion and shift for extra 3 bits */
	SID = MaskedID & 0x1FFC0000;
20001258:	00832024 	and	a0,a0,v1

	/* Separate Extended ID portion */
	EID = MaskedID & 0x3FFFF;

	/* Combine Standard ID, 3 padding bits and Extended ID */
	PAD_ID = ((SID | 0x80000) | EID);
2000125c:	3c030008 	lui	v1,0x8
 * @param EXT_ID Transmission ID for the CAN message.
 * @param length The size of the CAN data message.
 * @param Data_array The CAN data.
 */
void spi_buffer_CAN(uint32_t EXT_ID, uint8_t length, uint8_t Data_array[])
{
20001260:	27bdffd8 	addiu	sp,sp,-40

	/* Separate Extended ID portion */
	EID = MaskedID & 0x3FFFF;

	/* Combine Standard ID, 3 padding bits and Extended ID */
	PAD_ID = ((SID | 0x80000) | EID);
20001264:	00431025 	or	v0,v0,v1
20001268:	000420c0 	sll	a0,a0,0x3
2000126c:	00442025 	or	a0,v0,a0
 * @param EXT_ID Transmission ID for the CAN message.
 * @param length The size of the CAN data message.
 * @param Data_array The CAN data.
 */
void spi_buffer_CAN(uint32_t EXT_ID, uint8_t length, uint8_t Data_array[])
{
20001270:	afb10018 	sw	s1,24(sp)
20001274:	30b100ff 	andi	s1,a1,0xff
20001278:	afb00014 	sw	s0,20(sp)
	PAD_ID = ((SID | 0x80000) | EID);

	/* Write to byte array */
	for(Byte = 3; Byte >= 0; Byte--)
	{
		ID_Array[Byte] = (PAD_ID & 0xFF);
2000127c:	00041e02 	srl	v1,a0,0x18
		PAD_ID >>= 8;
20001280:	00043a02 	srl	a3,a0,0x8
20001284:	00042c02 	srl	a1,a0,0x10
	}

	/* add data length to byte array */
	ID_Array[4] = (DL & 0x0F);
20001288:	3222000f 	andi	v0,s1,0xf
2000128c:	27900168 	addiu	s0,gp,360
 * @param EXT_ID Transmission ID for the CAN message.
 * @param length The size of the CAN data message.
 * @param Data_array The CAN data.
 */
void spi_buffer_CAN(uint32_t EXT_ID, uint8_t length, uint8_t Data_array[])
{
20001290:	afb30020 	sw	s3,32(sp)
20001294:	afb2001c 	sw	s2,28(sp)
20001298:	afbf0024 	sw	ra,36(sp)
	PAD_ID = ((SID | 0x80000) | EID);

	/* Write to byte array */
	for(Byte = 3; Byte >= 0; Byte--)
	{
		ID_Array[Byte] = (PAD_ID & 0xFF);
2000129c:	a387016a 	sb	a3,362(gp)
200012a0:	a3850169 	sb	a1,361(gp)
200012a4:	a3830168 	sb	v1,360(gp)
		PAD_ID >>= 8;
	}

	/* add data length to byte array */
	ID_Array[4] = (DL & 0x0F);
200012a8:	a382016c 	sb	v0,364(gp)
 * @param EXT_ID Transmission ID for the CAN message.
 * @param length The size of the CAN data message.
 * @param Data_array The CAN data.
 */
void spi_buffer_CAN(uint32_t EXT_ID, uint8_t length, uint8_t Data_array[])
{
200012ac:	00c09021 	move	s2,a2
	PAD_ID = ((SID | 0x80000) | EID);

	/* Write to byte array */
	for(Byte = 3; Byte >= 0; Byte--)
	{
		ID_Array[Byte] = (PAD_ID & 0xFF);
200012b0:	a384016b 	sb	a0,363(gp)
 * Send CAN message into SPI buffer
 * @param EXT_ID Transmission ID for the CAN message.
 * @param length The size of the CAN data message.
 * @param Data_array The CAN data.
 */
void spi_buffer_CAN(uint32_t EXT_ID, uint8_t length, uint8_t Data_array[])
200012b4:	26130005 	addiu	s3,s0,5
	build_EXT_ID_bytes(EXT_ID, EXT_ID_Bytes, length);

	/* Send padded CAN ID */
	for (Byte_counter = 0; Byte_counter < 5; Byte_counter++)
	{
		SPI_Swap(SPI0, EXT_ID_Bytes[Byte_counter]);
200012b8:	92050000 	lbu	a1,0(s0)
200012bc:	00002021 	move	a0,zero
200012c0:	0c000b14 	jal	20002c50 <SPI_Swap>
200012c4:	26100001 	addiu	s0,s0,1

	/* Pad ID with LOAD_TX0_INS info (see MCP2515 datasheet) */
	build_EXT_ID_bytes(EXT_ID, EXT_ID_Bytes, length);

	/* Send padded CAN ID */
	for (Byte_counter = 0; Byte_counter < 5; Byte_counter++)
200012c8:	1613fffb 	bne	s0,s3,200012b8 <spi_buffer_CAN+0x70>
200012cc:	00000000 	nop
200012d0:	080004b9 	j	200012e4 <spi_buffer_CAN+0x9c>
200012d4:	00008021 	move	s0,zero
	}

	/* Send CAN Data */
	for (Byte_counter = 0; Byte_counter < length; Byte_counter++)
	{
		SPI_Swap(SPI0, Data_array[Byte_counter]);
200012d8:	90650000 	lbu	a1,0(v1)
200012dc:	0c000b14 	jal	20002c50 <SPI_Swap>
200012e0:	26100001 	addiu	s0,s0,1
	{
		SPI_Swap(SPI0, EXT_ID_Bytes[Byte_counter]);
	}

	/* Send CAN Data */
	for (Byte_counter = 0; Byte_counter < length; Byte_counter++)
200012e4:	0211102b 	sltu	v0,s0,s1
	{
		SPI_Swap(SPI0, Data_array[Byte_counter]);
200012e8:	02501821 	addu	v1,s2,s0
	{
		SPI_Swap(SPI0, EXT_ID_Bytes[Byte_counter]);
	}

	/* Send CAN Data */
	for (Byte_counter = 0; Byte_counter < length; Byte_counter++)
200012ec:	1440fffa 	bnez	v0,200012d8 <spi_buffer_CAN+0x90>
200012f0:	00002021 	move	a0,zero
	{
		SPI_Swap(SPI0, Data_array[Byte_counter]);
	}
}
200012f4:	8fbf0024 	lw	ra,36(sp)
200012f8:	8fb30020 	lw	s3,32(sp)
200012fc:	8fb2001c 	lw	s2,28(sp)
20001300:	8fb10018 	lw	s1,24(sp)
20001304:	8fb00014 	lw	s0,20(sp)
20001308:	03e00008 	jr	ra
2000130c:	27bd0028 	addiu	sp,sp,40

20001310 <Message_Sender_Update>:
 */
void Message_Sender_Update(void)
{

	/* First Update ensures the CONFIG values are correct */
	if(init == False)
20001310:	8f820170 	lw	v0,368(gp)

/**
 * Specifies messages to send by SPI
 */
void Message_Sender_Update(void)
{
20001314:	27bdffe0 	addiu	sp,sp,-32
20001318:	afbf001c 	sw	ra,28(sp)
2000131c:	afb10018 	sw	s1,24(sp)

	/* First Update ensures the CONFIG values are correct */
	if(init == False)
20001320:	1440011e 	bnez	v0,2000179c <Message_Sender_Update+0x48c>
20001324:	afb00014 	sw	s0,20(sp)
	{
		/* Soft Reset */
		GPIO_Write(CS_PIN, GPIO_LOW);
20001328:	3c108000 	lui	s0,0x8000
2000132c:	36100600 	ori	s0,s0,0x600
20001330:	8e020000 	lw	v0,0(s0)
20001334:	2411ffbf 	li	s1,-65
20001338:	00511024 	and	v0,v0,s1
2000133c:	ae020000 	sw	v0,0(s0)
20001340:	8e020000 	lw	v0,0(s0)
		SPI_Swap(SPI0, 0xC0);
20001344:	00002021 	move	a0,zero
20001348:	240500c0 	li	a1,192

	/* First Update ensures the CONFIG values are correct */
	if(init == False)
	{
		/* Soft Reset */
		GPIO_Write(CS_PIN, GPIO_LOW);
2000134c:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, 0xC0);
20001350:	0c000b14 	jal	20002c50 <SPI_Swap>
20001354:	00000000 	nop
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001358:	8e020000 	lw	v0,0(s0)

		/* Set into CONFIG mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
2000135c:	00002021 	move	a0,zero
	if(init == False)
	{
		/* Soft Reset */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0xC0);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001360:	ae020000 	sw	v0,0(s0)
20001364:	8e020000 	lw	v0,0(s0)

		/* Set into CONFIG mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
20001368:	24050002 	li	a1,2
	if(init == False)
	{
		/* Soft Reset */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0xC0);
		GPIO_Write(CS_PIN, GPIO_HIGH);
2000136c:	34420040 	ori	v0,v0,0x40
20001370:	ae020000 	sw	v0,0(s0)

		/* Set into CONFIG mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
20001374:	8e020000 	lw	v0,0(s0)
20001378:	00000000 	nop
2000137c:	00511024 	and	v0,v0,s1
20001380:	ae020000 	sw	v0,0(s0)
20001384:	8e020000 	lw	v0,0(s0)
20001388:	00000000 	nop
2000138c:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, 0x02);
20001390:	0c000b14 	jal	20002c50 <SPI_Swap>
20001394:	00000000 	nop
		SPI_Swap(SPI0, 0x0F);
20001398:	00002021 	move	a0,zero
2000139c:	0c000b14 	jal	20002c50 <SPI_Swap>
200013a0:	2405000f 	li	a1,15
		SPI_Swap(SPI0, 0x80);
200013a4:	00002021 	move	a0,zero
200013a8:	0c000b14 	jal	20002c50 <SPI_Swap>
200013ac:	24050080 	li	a1,128
		GPIO_Write(CS_PIN, GPIO_HIGH);
200013b0:	8e020000 	lw	v0,0(s0)

		/* Verify CONFIG mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x03);
200013b4:	00002021 	move	a0,zero
		/* Set into CONFIG mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x0F);
		SPI_Swap(SPI0, 0x80);
		GPIO_Write(CS_PIN, GPIO_HIGH);
200013b8:	ae020000 	sw	v0,0(s0)
200013bc:	8e020000 	lw	v0,0(s0)

		/* Verify CONFIG mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x03);
200013c0:	24050003 	li	a1,3
		/* Set into CONFIG mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x0F);
		SPI_Swap(SPI0, 0x80);
		GPIO_Write(CS_PIN, GPIO_HIGH);
200013c4:	34420040 	ori	v0,v0,0x40
200013c8:	ae020000 	sw	v0,0(s0)

		/* Verify CONFIG mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
200013cc:	8e020000 	lw	v0,0(s0)
200013d0:	00000000 	nop
200013d4:	00511024 	and	v0,v0,s1
200013d8:	ae020000 	sw	v0,0(s0)
200013dc:	8e020000 	lw	v0,0(s0)
200013e0:	00000000 	nop
200013e4:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, 0x03);
200013e8:	0c000b14 	jal	20002c50 <SPI_Swap>
200013ec:	00000000 	nop
		SPI_Swap(SPI0, 0x0E);
200013f0:	00002021 	move	a0,zero
200013f4:	0c000b14 	jal	20002c50 <SPI_Swap>
200013f8:	2405000e 	li	a1,14
		GPIO_Write(CS_PIN, GPIO_HIGH);
200013fc:	8e020000 	lw	v0,0(s0)

		/* Set values in the CONFIG registers for 250 kbps CAN */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
20001400:	00002021 	move	a0,zero

		/* Verify CONFIG mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x03);
		SPI_Swap(SPI0, 0x0E);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001404:	ae020000 	sw	v0,0(s0)
20001408:	8e020000 	lw	v0,0(s0)

		/* Set values in the CONFIG registers for 250 kbps CAN */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
2000140c:	24050002 	li	a1,2

		/* Verify CONFIG mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x03);
		SPI_Swap(SPI0, 0x0E);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001410:	34420040 	ori	v0,v0,0x40
20001414:	ae020000 	sw	v0,0(s0)

		/* Set values in the CONFIG registers for 250 kbps CAN */
		GPIO_Write(CS_PIN, GPIO_LOW);
20001418:	8e020000 	lw	v0,0(s0)
2000141c:	00000000 	nop
20001420:	00511024 	and	v0,v0,s1
20001424:	ae020000 	sw	v0,0(s0)
20001428:	8e020000 	lw	v0,0(s0)
2000142c:	00000000 	nop
20001430:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, 0x02);
20001434:	0c000b14 	jal	20002c50 <SPI_Swap>
20001438:	00000000 	nop
		SPI_Swap(SPI0, 0x28);
2000143c:	00002021 	move	a0,zero
20001440:	0c000b14 	jal	20002c50 <SPI_Swap>
20001444:	24050028 	li	a1,40
		SPI_Swap(SPI0, 0x02);
20001448:	00002021 	move	a0,zero
2000144c:	0c000b14 	jal	20002c50 <SPI_Swap>
20001450:	24050002 	li	a1,2
		SPI_Swap(SPI0, 0x90);
20001454:	00002021 	move	a0,zero
20001458:	0c000b14 	jal	20002c50 <SPI_Swap>
2000145c:	24050090 	li	a1,144
		SPI_Swap(SPI0, 0x03);
20001460:	00002021 	move	a0,zero
20001464:	0c000b14 	jal	20002c50 <SPI_Swap>
20001468:	24050003 	li	a1,3
		SPI_Swap(SPI0, 0x00);
2000146c:	00002021 	move	a0,zero
20001470:	0c000b14 	jal	20002c50 <SPI_Swap>
20001474:	00002821 	move	a1,zero
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001478:	8e020000 	lw	v0,0(s0)

		/* Verify set values */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x03);
2000147c:	00002021 	move	a0,zero
		SPI_Swap(SPI0, 0x28);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x90);
		SPI_Swap(SPI0, 0x03);
		SPI_Swap(SPI0, 0x00);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001480:	ae020000 	sw	v0,0(s0)
20001484:	8e020000 	lw	v0,0(s0)

		/* Verify set values */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x03);
20001488:	24050003 	li	a1,3
		SPI_Swap(SPI0, 0x28);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x90);
		SPI_Swap(SPI0, 0x03);
		SPI_Swap(SPI0, 0x00);
		GPIO_Write(CS_PIN, GPIO_HIGH);
2000148c:	34420040 	ori	v0,v0,0x40
20001490:	ae020000 	sw	v0,0(s0)

		/* Verify set values */
		GPIO_Write(CS_PIN, GPIO_LOW);
20001494:	8e020000 	lw	v0,0(s0)
20001498:	00000000 	nop
2000149c:	00511024 	and	v0,v0,s1
200014a0:	ae020000 	sw	v0,0(s0)
200014a4:	8e020000 	lw	v0,0(s0)
200014a8:	00000000 	nop
200014ac:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, 0x03);
200014b0:	0c000b14 	jal	20002c50 <SPI_Swap>
200014b4:	00000000 	nop
		SPI_Swap(SPI0, 0x2A);
200014b8:	00002021 	move	a0,zero
200014bc:	0c000b14 	jal	20002c50 <SPI_Swap>
200014c0:	2405002a 	li	a1,42
		speedPin = SPI_Swap(SPI0, 0xFF);
200014c4:	00002021 	move	a0,zero
200014c8:	0c000b14 	jal	20002c50 <SPI_Swap>
200014cc:	240500ff 	li	a1,255
		GPIO_Write(CS_PIN, GPIO_HIGH);
200014d0:	8e030000 	lw	v1,0(s0)

		/* BFPCTRL register cleared */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
200014d4:	00002021 	move	a0,zero
		/* Verify set values */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x03);
		SPI_Swap(SPI0, 0x2A);
		speedPin = SPI_Swap(SPI0, 0xFF);
		GPIO_Write(CS_PIN, GPIO_HIGH);
200014d8:	ae030000 	sw	v1,0(s0)
200014dc:	8e030000 	lw	v1,0(s0)

		/* BFPCTRL register cleared */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
200014e0:	24050002 	li	a1,2
		/* Verify set values */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x03);
		SPI_Swap(SPI0, 0x2A);
		speedPin = SPI_Swap(SPI0, 0xFF);
		GPIO_Write(CS_PIN, GPIO_HIGH);
200014e4:	34630040 	ori	v1,v1,0x40
200014e8:	ae030000 	sw	v1,0(s0)

		/* BFPCTRL register cleared */
		GPIO_Write(CS_PIN, GPIO_LOW);
200014ec:	8e030000 	lw	v1,0(s0)

		/* Verify set values */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x03);
		SPI_Swap(SPI0, 0x2A);
		speedPin = SPI_Swap(SPI0, 0xFF);
200014f0:	a382016d 	sb	v0,365(gp)
		GPIO_Write(CS_PIN, GPIO_HIGH);

		/* BFPCTRL register cleared */
		GPIO_Write(CS_PIN, GPIO_LOW);
200014f4:	00711824 	and	v1,v1,s1
200014f8:	ae030000 	sw	v1,0(s0)
200014fc:	8e020000 	lw	v0,0(s0)
20001500:	00000000 	nop
20001504:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, 0x02);
20001508:	0c000b14 	jal	20002c50 <SPI_Swap>
2000150c:	00000000 	nop
		SPI_Swap(SPI0, 0x0C);
20001510:	00002021 	move	a0,zero
20001514:	0c000b14 	jal	20002c50 <SPI_Swap>
20001518:	2405000c 	li	a1,12
		SPI_Swap(SPI0, 0x00);
2000151c:	00002021 	move	a0,zero
20001520:	0c000b14 	jal	20002c50 <SPI_Swap>
20001524:	00002821 	move	a1,zero
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001528:	8e020000 	lw	v0,0(s0)

		/* TXRTSCTRL register cleared */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
2000152c:	00002021 	move	a0,zero
		/* BFPCTRL register cleared */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x0C);
		SPI_Swap(SPI0, 0x00);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001530:	ae020000 	sw	v0,0(s0)
20001534:	8e020000 	lw	v0,0(s0)

		/* TXRTSCTRL register cleared */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
20001538:	24050002 	li	a1,2
		/* BFPCTRL register cleared */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x0C);
		SPI_Swap(SPI0, 0x00);
		GPIO_Write(CS_PIN, GPIO_HIGH);
2000153c:	34420040 	ori	v0,v0,0x40
20001540:	ae020000 	sw	v0,0(s0)

		/* TXRTSCTRL register cleared */
		GPIO_Write(CS_PIN, GPIO_LOW);
20001544:	8e020000 	lw	v0,0(s0)
20001548:	00000000 	nop
2000154c:	00511024 	and	v0,v0,s1
20001550:	ae020000 	sw	v0,0(s0)
20001554:	8e020000 	lw	v0,0(s0)
20001558:	00000000 	nop
2000155c:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, 0x02);
20001560:	0c000b14 	jal	20002c50 <SPI_Swap>
20001564:	00000000 	nop
		SPI_Swap(SPI0, 0x0D);
20001568:	00002021 	move	a0,zero
2000156c:	0c000b14 	jal	20002c50 <SPI_Swap>
20001570:	2405000d 	li	a1,13
		SPI_Swap(SPI0, 0x00);
20001574:	00002021 	move	a0,zero
20001578:	0c000b14 	jal	20002c50 <SPI_Swap>
2000157c:	00002821 	move	a1,zero
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001580:	8e020000 	lw	v0,0(s0)

		/* RXB0CTRL */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
20001584:	00002021 	move	a0,zero
		/* TXRTSCTRL register cleared */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x0D);
		SPI_Swap(SPI0, 0x00);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001588:	ae020000 	sw	v0,0(s0)
2000158c:	8e020000 	lw	v0,0(s0)

		/* RXB0CTRL */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
20001590:	24050002 	li	a1,2
		/* TXRTSCTRL register cleared */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x0D);
		SPI_Swap(SPI0, 0x00);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001594:	34420040 	ori	v0,v0,0x40
20001598:	ae020000 	sw	v0,0(s0)

		/* RXB0CTRL */
		GPIO_Write(CS_PIN, GPIO_LOW);
2000159c:	8e020000 	lw	v0,0(s0)
200015a0:	00000000 	nop
200015a4:	00511024 	and	v0,v0,s1
200015a8:	ae020000 	sw	v0,0(s0)
200015ac:	8e020000 	lw	v0,0(s0)
200015b0:	00000000 	nop
200015b4:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, 0x02);
200015b8:	0c000b14 	jal	20002c50 <SPI_Swap>
200015bc:	00000000 	nop
		SPI_Swap(SPI0, 0x60);
200015c0:	00002021 	move	a0,zero
200015c4:	0c000b14 	jal	20002c50 <SPI_Swap>
200015c8:	24050060 	li	a1,96
		SPI_Swap(SPI0, 0x60);
200015cc:	00002021 	move	a0,zero
200015d0:	0c000b14 	jal	20002c50 <SPI_Swap>
200015d4:	24050060 	li	a1,96
		GPIO_Write(CS_PIN, GPIO_HIGH);
200015d8:	8e020000 	lw	v0,0(s0)

		/* RXB1CTRL */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
200015dc:	00002021 	move	a0,zero
		/* RXB0CTRL */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x60);
		SPI_Swap(SPI0, 0x60);
		GPIO_Write(CS_PIN, GPIO_HIGH);
200015e0:	ae020000 	sw	v0,0(s0)
200015e4:	8e020000 	lw	v0,0(s0)

		/* RXB1CTRL */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
200015e8:	24050002 	li	a1,2
		/* RXB0CTRL */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x60);
		SPI_Swap(SPI0, 0x60);
		GPIO_Write(CS_PIN, GPIO_HIGH);
200015ec:	34420040 	ori	v0,v0,0x40
200015f0:	ae020000 	sw	v0,0(s0)

		/* RXB1CTRL */
		GPIO_Write(CS_PIN, GPIO_LOW);
200015f4:	8e020000 	lw	v0,0(s0)
200015f8:	00000000 	nop
200015fc:	00511024 	and	v0,v0,s1
20001600:	ae020000 	sw	v0,0(s0)
20001604:	8e020000 	lw	v0,0(s0)
20001608:	00000000 	nop
2000160c:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, 0x02);
20001610:	0c000b14 	jal	20002c50 <SPI_Swap>
20001614:	00000000 	nop
		SPI_Swap(SPI0, 0x70);
20001618:	00002021 	move	a0,zero
2000161c:	0c000b14 	jal	20002c50 <SPI_Swap>
20001620:	24050070 	li	a1,112
		SPI_Swap(SPI0, 0x60);
20001624:	00002021 	move	a0,zero
20001628:	0c000b14 	jal	20002c50 <SPI_Swap>
2000162c:	24050060 	li	a1,96
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001630:	8e020000 	lw	v0,0(s0)

		/* Filter for impossible CAN ID */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
20001634:	00002021 	move	a0,zero
		/* RXB1CTRL */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x70);
		SPI_Swap(SPI0, 0x60);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001638:	ae020000 	sw	v0,0(s0)
2000163c:	8e020000 	lw	v0,0(s0)

		/* Filter for impossible CAN ID */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
20001640:	24050002 	li	a1,2
		/* RXB1CTRL */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x70);
		SPI_Swap(SPI0, 0x60);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001644:	34420040 	ori	v0,v0,0x40
20001648:	ae020000 	sw	v0,0(s0)

		/* Filter for impossible CAN ID */
		GPIO_Write(CS_PIN, GPIO_LOW);
2000164c:	8e020000 	lw	v0,0(s0)
20001650:	00000000 	nop
20001654:	00511024 	and	v0,v0,s1
20001658:	ae020000 	sw	v0,0(s0)
2000165c:	8e020000 	lw	v0,0(s0)
20001660:	00000000 	nop
20001664:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, 0x02);
20001668:	0c000b14 	jal	20002c50 <SPI_Swap>
2000166c:	00000000 	nop
		SPI_Swap(SPI0, 0x08);
20001670:	00002021 	move	a0,zero
20001674:	0c000b14 	jal	20002c50 <SPI_Swap>
20001678:	24050008 	li	a1,8
		SPI_Swap(SPI0, 0x3F);
2000167c:	00002021 	move	a0,zero
20001680:	0c000b14 	jal	20002c50 <SPI_Swap>
20001684:	2405003f 	li	a1,63
		SPI_Swap(SPI0, 0x0F);
20001688:	00002021 	move	a0,zero
2000168c:	0c000b14 	jal	20002c50 <SPI_Swap>
20001690:	2405000f 	li	a1,15
		SPI_Swap(SPI0, 0xFF);
20001694:	00002021 	move	a0,zero
20001698:	0c000b14 	jal	20002c50 <SPI_Swap>
2000169c:	240500ff 	li	a1,255
		SPI_Swap(SPI0, 0xFF);
200016a0:	00002021 	move	a0,zero
200016a4:	0c000b14 	jal	20002c50 <SPI_Swap>
200016a8:	240500ff 	li	a1,255
		GPIO_Write(CS_PIN, GPIO_HIGH);
200016ac:	8e020000 	lw	v0,0(s0)

		/* Mask for impossible CAN ID */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
200016b0:	00002021 	move	a0,zero
		SPI_Swap(SPI0, 0x08);
		SPI_Swap(SPI0, 0x3F);
		SPI_Swap(SPI0, 0x0F);
		SPI_Swap(SPI0, 0xFF);
		SPI_Swap(SPI0, 0xFF);
		GPIO_Write(CS_PIN, GPIO_HIGH);
200016b4:	ae020000 	sw	v0,0(s0)
200016b8:	8e020000 	lw	v0,0(s0)

		/* Mask for impossible CAN ID */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
200016bc:	24050002 	li	a1,2
		SPI_Swap(SPI0, 0x08);
		SPI_Swap(SPI0, 0x3F);
		SPI_Swap(SPI0, 0x0F);
		SPI_Swap(SPI0, 0xFF);
		SPI_Swap(SPI0, 0xFF);
		GPIO_Write(CS_PIN, GPIO_HIGH);
200016c0:	34420040 	ori	v0,v0,0x40
200016c4:	ae020000 	sw	v0,0(s0)

		/* Mask for impossible CAN ID */
		GPIO_Write(CS_PIN, GPIO_LOW);
200016c8:	8e020000 	lw	v0,0(s0)
200016cc:	00000000 	nop
200016d0:	00511024 	and	v0,v0,s1
200016d4:	ae020000 	sw	v0,0(s0)
200016d8:	8e020000 	lw	v0,0(s0)
200016dc:	00000000 	nop
200016e0:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, 0x02);
200016e4:	0c000b14 	jal	20002c50 <SPI_Swap>
200016e8:	00000000 	nop
		SPI_Swap(SPI0, 0x24);
200016ec:	00002021 	move	a0,zero
200016f0:	0c000b14 	jal	20002c50 <SPI_Swap>
200016f4:	24050024 	li	a1,36
		SPI_Swap(SPI0, 0xFF);
200016f8:	00002021 	move	a0,zero
200016fc:	0c000b14 	jal	20002c50 <SPI_Swap>
20001700:	240500ff 	li	a1,255
		SPI_Swap(SPI0, 0xFF);
20001704:	00002021 	move	a0,zero
20001708:	0c000b14 	jal	20002c50 <SPI_Swap>
2000170c:	240500ff 	li	a1,255
		SPI_Swap(SPI0, 0xFF);
20001710:	00002021 	move	a0,zero
20001714:	0c000b14 	jal	20002c50 <SPI_Swap>
20001718:	240500ff 	li	a1,255
		SPI_Swap(SPI0, 0xFF);
2000171c:	00002021 	move	a0,zero
20001720:	0c000b14 	jal	20002c50 <SPI_Swap>
20001724:	240500ff 	li	a1,255
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001728:	8e020000 	lw	v0,0(s0)

		/* CANCTRL - Set to Normal Mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
2000172c:	00002021 	move	a0,zero
		SPI_Swap(SPI0, 0x24);
		SPI_Swap(SPI0, 0xFF);
		SPI_Swap(SPI0, 0xFF);
		SPI_Swap(SPI0, 0xFF);
		SPI_Swap(SPI0, 0xFF);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001730:	ae020000 	sw	v0,0(s0)
20001734:	8e020000 	lw	v0,0(s0)

		/* CANCTRL - Set to Normal Mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
20001738:	24050002 	li	a1,2
		SPI_Swap(SPI0, 0x24);
		SPI_Swap(SPI0, 0xFF);
		SPI_Swap(SPI0, 0xFF);
		SPI_Swap(SPI0, 0xFF);
		SPI_Swap(SPI0, 0xFF);
		GPIO_Write(CS_PIN, GPIO_HIGH);
2000173c:	34420040 	ori	v0,v0,0x40
20001740:	ae020000 	sw	v0,0(s0)

		/* CANCTRL - Set to Normal Mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
20001744:	8e020000 	lw	v0,0(s0)
20001748:	00000000 	nop
2000174c:	00518824 	and	s1,v0,s1
20001750:	ae110000 	sw	s1,0(s0)
20001754:	8e020000 	lw	v0,0(s0)
20001758:	00000000 	nop
2000175c:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, 0x02);
20001760:	0c000b14 	jal	20002c50 <SPI_Swap>
20001764:	00000000 	nop
		SPI_Swap(SPI0, 0x0F);
20001768:	00002021 	move	a0,zero
2000176c:	0c000b14 	jal	20002c50 <SPI_Swap>
20001770:	2405000f 	li	a1,15
		SPI_Swap(SPI0, 0x00);
20001774:	00002021 	move	a0,zero
20001778:	0c000b14 	jal	20002c50 <SPI_Swap>
2000177c:	00002821 	move	a1,zero
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001780:	8e020000 	lw	v0,0(s0)

		init = True;
20001784:	24030001 	li	v1,1
		/* CANCTRL - Set to Normal Mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x0F);
		SPI_Swap(SPI0, 0x00);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001788:	ae020000 	sw	v0,0(s0)
2000178c:	8e020000 	lw	v0,0(s0)

		init = True;
20001790:	af830170 	sw	v1,368(gp)
		/* CANCTRL - Set to Normal Mode */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, 0x02);
		SPI_Swap(SPI0, 0x0F);
		SPI_Swap(SPI0, 0x00);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001794:	34420040 	ori	v0,v0,0x40
20001798:	ae020000 	sw	v0,0(s0)
	/* Transmit "proper" CAN messages only when the Mode is GO */
	//if(System_Mode_G == Go || System_Mode_G == Game_Over)
	{
		/* Pull CS pin low - indicates start of transmission */
		/* Load CAN message into TX0: Left Motor */
		GPIO_Write(CS_PIN, GPIO_LOW);
2000179c:	3c108000 	lui	s0,0x8000
200017a0:	36100600 	ori	s0,s0,0x600
200017a4:	8e020000 	lw	v0,0(s0)
200017a8:	2411ffbf 	li	s1,-65
200017ac:	00511024 	and	v0,v0,s1
200017b0:	ae020000 	sw	v0,0(s0)
200017b4:	8e020000 	lw	v0,0(s0)
		SPI_Swap(SPI0, LOAD_TX0_INS);
200017b8:	00002021 	move	a0,zero
200017bc:	24050040 	li	a1,64
	/* Transmit "proper" CAN messages only when the Mode is GO */
	//if(System_Mode_G == Go || System_Mode_G == Game_Over)
	{
		/* Pull CS pin low - indicates start of transmission */
		/* Load CAN message into TX0: Left Motor */
		GPIO_Write(CS_PIN, GPIO_LOW);
200017c0:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, LOAD_TX0_INS);
200017c4:	0c000b14 	jal	20002c50 <SPI_Swap>
200017c8:	00000000 	nop
		spi_buffer_CAN(canIDLf, 8, candataLf);
200017cc:	8f8400e8 	lw	a0,232(gp)
200017d0:	2786006c 	addiu	a2,gp,108
200017d4:	0c000492 	jal	20001248 <spi_buffer_CAN>
200017d8:	24050008 	li	a1,8
		GPIO_Write(CS_PIN, GPIO_HIGH);
200017dc:	8e020000 	lw	v0,0(s0)

		/* Load CAN message into TX1: Right Motor */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, LOAD_TX1_INS);
200017e0:	00002021 	move	a0,zero
		/* Pull CS pin low - indicates start of transmission */
		/* Load CAN message into TX0: Left Motor */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, LOAD_TX0_INS);
		spi_buffer_CAN(canIDLf, 8, candataLf);
		GPIO_Write(CS_PIN, GPIO_HIGH);
200017e4:	ae020000 	sw	v0,0(s0)
200017e8:	8e020000 	lw	v0,0(s0)

		/* Load CAN message into TX1: Right Motor */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, LOAD_TX1_INS);
200017ec:	24050042 	li	a1,66
		/* Pull CS pin low - indicates start of transmission */
		/* Load CAN message into TX0: Left Motor */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, LOAD_TX0_INS);
		spi_buffer_CAN(canIDLf, 8, candataLf);
		GPIO_Write(CS_PIN, GPIO_HIGH);
200017f0:	34420040 	ori	v0,v0,0x40
200017f4:	ae020000 	sw	v0,0(s0)

		/* Load CAN message into TX1: Right Motor */
		GPIO_Write(CS_PIN, GPIO_LOW);
200017f8:	8e020000 	lw	v0,0(s0)
200017fc:	00000000 	nop
20001800:	00511024 	and	v0,v0,s1
20001804:	ae020000 	sw	v0,0(s0)
20001808:	8e020000 	lw	v0,0(s0)
2000180c:	00000000 	nop
20001810:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, LOAD_TX1_INS);
20001814:	0c000b14 	jal	20002c50 <SPI_Swap>
20001818:	00000000 	nop
		spi_buffer_CAN(canIDRt, 8, candataRt);
2000181c:	8f840068 	lw	a0,104(gp)
20001820:	27860098 	addiu	a2,gp,152
20001824:	0c000492 	jal	20001248 <spi_buffer_CAN>
20001828:	24050008 	li	a1,8
		GPIO_Write(CS_PIN, GPIO_HIGH);
2000182c:	8e020000 	lw	v0,0(s0)

		/* Load CAN message into TX2: Servo controls */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, LOAD_TX2_INS);
20001830:	00002021 	move	a0,zero

		/* Load CAN message into TX1: Right Motor */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, LOAD_TX1_INS);
		spi_buffer_CAN(canIDRt, 8, candataRt);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001834:	ae020000 	sw	v0,0(s0)
20001838:	8e020000 	lw	v0,0(s0)

		/* Load CAN message into TX2: Servo controls */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, LOAD_TX2_INS);
2000183c:	24050044 	li	a1,68

		/* Load CAN message into TX1: Right Motor */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, LOAD_TX1_INS);
		spi_buffer_CAN(canIDRt, 8, candataRt);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001840:	34420040 	ori	v0,v0,0x40
20001844:	ae020000 	sw	v0,0(s0)

		/* Load CAN message into TX2: Servo controls */
		GPIO_Write(CS_PIN, GPIO_LOW);
20001848:	8e020000 	lw	v0,0(s0)
2000184c:	00000000 	nop
20001850:	00511024 	and	v0,v0,s1
20001854:	ae020000 	sw	v0,0(s0)
20001858:	8e020000 	lw	v0,0(s0)
2000185c:	00000000 	nop
20001860:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, LOAD_TX2_INS);
20001864:	0c000b14 	jal	20002c50 <SPI_Swap>
20001868:	00000000 	nop
		spi_buffer_CAN(0x05A5EEEE, 8, candataEnc);
2000186c:	3c0405a5 	lui	a0,0x5a5
20001870:	278600a8 	addiu	a2,gp,168
20001874:	3484eeee 	ori	a0,a0,0xeeee
20001878:	0c000492 	jal	20001248 <spi_buffer_CAN>
2000187c:	24050008 	li	a1,8
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001880:	8e020000 	lw	v0,0(s0)

		/* Tx0 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, RTS_TX0_INS);
20001884:	00002021 	move	a0,zero

		/* Load CAN message into TX2: Servo controls */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, LOAD_TX2_INS);
		spi_buffer_CAN(0x05A5EEEE, 8, candataEnc);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001888:	ae020000 	sw	v0,0(s0)
2000188c:	8e020000 	lw	v0,0(s0)

		/* Tx0 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, RTS_TX0_INS);
20001890:	24050081 	li	a1,129

		/* Load CAN message into TX2: Servo controls */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, LOAD_TX2_INS);
		spi_buffer_CAN(0x05A5EEEE, 8, candataEnc);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001894:	34420040 	ori	v0,v0,0x40
20001898:	ae020000 	sw	v0,0(s0)

		/* Tx0 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
2000189c:	8e020000 	lw	v0,0(s0)
200018a0:	00000000 	nop
200018a4:	00511024 	and	v0,v0,s1
200018a8:	ae020000 	sw	v0,0(s0)
200018ac:	8e020000 	lw	v0,0(s0)
200018b0:	00000000 	nop
200018b4:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, RTS_TX0_INS);
200018b8:	0c000b14 	jal	20002c50 <SPI_Swap>
200018bc:	00000000 	nop
		GPIO_Write(CS_PIN, GPIO_HIGH);
200018c0:	8e020000 	lw	v0,0(s0)

		/* Tx1 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, RTS_TX1_INS);
200018c4:	00002021 	move	a0,zero
		GPIO_Write(CS_PIN, GPIO_HIGH);

		/* Tx0 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, RTS_TX0_INS);
		GPIO_Write(CS_PIN, GPIO_HIGH);
200018c8:	ae020000 	sw	v0,0(s0)
200018cc:	8e020000 	lw	v0,0(s0)

		/* Tx1 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, RTS_TX1_INS);
200018d0:	24050082 	li	a1,130
		GPIO_Write(CS_PIN, GPIO_HIGH);

		/* Tx0 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, RTS_TX0_INS);
		GPIO_Write(CS_PIN, GPIO_HIGH);
200018d4:	34420040 	ori	v0,v0,0x40
200018d8:	ae020000 	sw	v0,0(s0)

		/* Tx1 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
200018dc:	8e020000 	lw	v0,0(s0)
200018e0:	00000000 	nop
200018e4:	00511024 	and	v0,v0,s1
200018e8:	ae020000 	sw	v0,0(s0)
200018ec:	8e020000 	lw	v0,0(s0)
200018f0:	00000000 	nop
200018f4:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, RTS_TX1_INS);
200018f8:	0c000b14 	jal	20002c50 <SPI_Swap>
200018fc:	00000000 	nop
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001900:	8e020000 	lw	v0,0(s0)

		/* Tx2 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, RTS_TX2_INS);
20001904:	00002021 	move	a0,zero
		GPIO_Write(CS_PIN, GPIO_HIGH);

		/* Tx1 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, RTS_TX1_INS);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001908:	ae020000 	sw	v0,0(s0)
2000190c:	8e020000 	lw	v0,0(s0)

		/* Tx2 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, RTS_TX2_INS);
20001910:	24050084 	li	a1,132
		GPIO_Write(CS_PIN, GPIO_HIGH);

		/* Tx1 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, RTS_TX1_INS);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001914:	34420040 	ori	v0,v0,0x40
20001918:	ae020000 	sw	v0,0(s0)

		/* Tx2 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
2000191c:	8e020000 	lw	v0,0(s0)
20001920:	00000000 	nop
20001924:	00518824 	and	s1,v0,s1
20001928:	ae110000 	sw	s1,0(s0)
2000192c:	8e020000 	lw	v0,0(s0)
20001930:	00000000 	nop
20001934:	ae020000 	sw	v0,0(s0)
		SPI_Swap(SPI0, RTS_TX2_INS);
20001938:	0c000b14 	jal	20002c50 <SPI_Swap>
2000193c:	00000000 	nop
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001940:	8e020000 	lw	v0,0(s0)

		/* Check Rx buffers for incoming message */
		spi_receive_CAN(READ_RX0_INS, &bufferRX0);
20001944:	3c054000 	lui	a1,0x4000
		GPIO_Write(CS_PIN, GPIO_HIGH);

		/* Tx2 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, RTS_TX2_INS);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001948:	ae020000 	sw	v0,0(s0)
2000194c:	8e020000 	lw	v0,0(s0)

		/* Check Rx buffers for incoming message */
		spi_receive_CAN(READ_RX0_INS, &bufferRX0);
	}

}
20001950:	8fbf001c 	lw	ra,28(sp)
		GPIO_Write(CS_PIN, GPIO_HIGH);

		/* Tx2 buffer full so request to send */
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, RTS_TX2_INS);
		GPIO_Write(CS_PIN, GPIO_HIGH);
20001954:	34420040 	ori	v0,v0,0x40
20001958:	ae020000 	sw	v0,0(s0)

		/* Check Rx buffers for incoming message */
		spi_receive_CAN(READ_RX0_INS, &bufferRX0);
	}

}
2000195c:	8fb10018 	lw	s1,24(sp)
20001960:	8fb00014 	lw	s0,20(sp)
		GPIO_Write(CS_PIN, GPIO_LOW);
		SPI_Swap(SPI0, RTS_TX2_INS);
		GPIO_Write(CS_PIN, GPIO_HIGH);

		/* Check Rx buffers for incoming message */
		spi_receive_CAN(READ_RX0_INS, &bufferRX0);
20001964:	24a503bc 	addiu	a1,a1,956
20001968:	24040090 	li	a0,144
2000196c:	08000459 	j	20001164 <spi_receive_CAN>
20001970:	27bd0020 	addiu	sp,sp,32

20001974 <Message_Sender_Init>:
/**
 * Initialisation for the SPI package.
 * This will be called from Tasks_Init by default.
 */
void Message_Sender_Init(void)
{
20001974:	27bdffe8 	addiu	sp,sp,-24
	/* Task initialisation */
	// SPI  0
	// Mode 0
	// SCLK 1KHz = (50MHz / 1000)
	const uint32_t clock_divider = Config_Oscillator_Frequency / 10000000;
	SPI_Init(SPI0, 0, clock_divider);
20001978:	00002021 	move	a0,zero
2000197c:	00002821 	move	a1,zero
/**
 * Initialisation for the SPI package.
 * This will be called from Tasks_Init by default.
 */
void Message_Sender_Init(void)
{
20001980:	afbf0014 	sw	ra,20(sp)
	/* Task initialisation */
	// SPI  0
	// Mode 0
	// SCLK 1KHz = (50MHz / 1000)
	const uint32_t clock_divider = Config_Oscillator_Frequency / 10000000;
	SPI_Init(SPI0, 0, clock_divider);
20001984:	0c000b07 	jal	20002c1c <SPI_Init>
20001988:	24060005 	li	a2,5
	speedPin = 0x33;

	bufferRX0.status = Used;
	bufferRX1.status = Used;

	GPIO_Set_Direction(CS_PIN, GPIO_OUTPUT);
2000198c:	3c028000 	lui	v0,0x8000
20001990:	34420600 	ori	v0,v0,0x600
20001994:	8c440004 	lw	a0,4(v0)
20001998:	2403ffbf 	li	v1,-65
2000199c:	00831824 	and	v1,a0,v1
200019a0:	ac430004 	sw	v1,4(v0)
200019a4:	8c430004 	lw	v1,4(v0)
	GPIO_Write(RST_PIN, GPIO_HIGH);

	init = False;

	ticked = 0;
}
200019a8:	8fbf0014 	lw	ra,20(sp)
	speedPin = 0x33;

	bufferRX0.status = Used;
	bufferRX1.status = Used;

	GPIO_Set_Direction(CS_PIN, GPIO_OUTPUT);
200019ac:	34630040 	ori	v1,v1,0x40
200019b0:	ac430004 	sw	v1,4(v0)
	GPIO_Write(CS_PIN, GPIO_HIGH);
200019b4:	8c440000 	lw	a0,0(v0)
	const uint32_t clock_divider = Config_Oscillator_Frequency / 10000000;
	SPI_Init(SPI0, 0, clock_divider);

	speedPin = 0x33;

	bufferRX0.status = Used;
200019b8:	24030001 	li	v1,1
	bufferRX1.status = Used;

	GPIO_Set_Direction(CS_PIN, GPIO_OUTPUT);
	GPIO_Write(CS_PIN, GPIO_HIGH);
200019bc:	ac440000 	sw	a0,0(v0)
200019c0:	8c440000 	lw	a0,0(v0)

	GPIO_Set_Direction(RST_PIN, GPIO_OUTPUT);
	GPIO_Write(RST_PIN, GPIO_HIGH);

	init = False;
200019c4:	af800170 	sw	zero,368(gp)

	bufferRX0.status = Used;
	bufferRX1.status = Used;

	GPIO_Set_Direction(CS_PIN, GPIO_OUTPUT);
	GPIO_Write(CS_PIN, GPIO_HIGH);
200019c8:	34840040 	ori	a0,a0,0x40
200019cc:	ac440000 	sw	a0,0(v0)

	GPIO_Set_Direction(RST_PIN, GPIO_OUTPUT);
200019d0:	8c450004 	lw	a1,4(v0)
200019d4:	2404fffb 	li	a0,-5
200019d8:	00a42024 	and	a0,a1,a0
200019dc:	ac440004 	sw	a0,4(v0)
200019e0:	8c440004 	lw	a0,4(v0)
	SPI_Init(SPI0, 0, clock_divider);

	speedPin = 0x33;

	bufferRX0.status = Used;
	bufferRX1.status = Used;
200019e4:	3c054000 	lui	a1,0x4000

	GPIO_Set_Direction(CS_PIN, GPIO_OUTPUT);
	GPIO_Write(CS_PIN, GPIO_HIGH);

	GPIO_Set_Direction(RST_PIN, GPIO_OUTPUT);
200019e8:	34840004 	ori	a0,a0,0x4
200019ec:	ac440004 	sw	a0,4(v0)
	GPIO_Write(RST_PIN, GPIO_HIGH);
200019f0:	8c440000 	lw	a0,0(v0)
	SPI_Init(SPI0, 0, clock_divider);

	speedPin = 0x33;

	bufferRX0.status = Used;
	bufferRX1.status = Used;
200019f4:	aca303cc 	sw	v1,972(a1)

	GPIO_Set_Direction(CS_PIN, GPIO_OUTPUT);
	GPIO_Write(CS_PIN, GPIO_HIGH);

	GPIO_Set_Direction(RST_PIN, GPIO_OUTPUT);
	GPIO_Write(RST_PIN, GPIO_HIGH);
200019f8:	ac440000 	sw	a0,0(v0)
200019fc:	8c440000 	lw	a0,0(v0)
	// Mode 0
	// SCLK 1KHz = (50MHz / 1000)
	const uint32_t clock_divider = Config_Oscillator_Frequency / 10000000;
	SPI_Init(SPI0, 0, clock_divider);

	speedPin = 0x33;
20001a00:	24050033 	li	a1,51

	GPIO_Set_Direction(CS_PIN, GPIO_OUTPUT);
	GPIO_Write(CS_PIN, GPIO_HIGH);

	GPIO_Set_Direction(RST_PIN, GPIO_OUTPUT);
	GPIO_Write(RST_PIN, GPIO_HIGH);
20001a04:	34840004 	ori	a0,a0,0x4
	// Mode 0
	// SCLK 1KHz = (50MHz / 1000)
	const uint32_t clock_divider = Config_Oscillator_Frequency / 10000000;
	SPI_Init(SPI0, 0, clock_divider);

	speedPin = 0x33;
20001a08:	a385016d 	sb	a1,365(gp)

	GPIO_Set_Direction(CS_PIN, GPIO_OUTPUT);
	GPIO_Write(CS_PIN, GPIO_HIGH);

	GPIO_Set_Direction(RST_PIN, GPIO_OUTPUT);
	GPIO_Write(RST_PIN, GPIO_HIGH);
20001a0c:	ac440000 	sw	a0,0(v0)
	const uint32_t clock_divider = Config_Oscillator_Frequency / 10000000;
	SPI_Init(SPI0, 0, clock_divider);

	speedPin = 0x33;

	bufferRX0.status = Used;
20001a10:	3c024000 	lui	v0,0x4000
20001a14:	ac4303bc 	sw	v1,956(v0)
	GPIO_Set_Direction(RST_PIN, GPIO_OUTPUT);
	GPIO_Write(RST_PIN, GPIO_HIGH);

	init = False;

	ticked = 0;
20001a18:	a7800190 	sh	zero,400(gp)
}
20001a1c:	03e00008 	jr	ra
20001a20:	27bd0018 	addiu	sp,sp,24

20001a24 <Flashing_LED_Init>:
/**
 * Initialises the GPIO pin and outputs the initial value to the LED.
 */
void Flashing_LED_Init(void)
{
	GPIO_Set_Direction(LED_Pin, GPIO_OUTPUT);
20001a24:	3c028000 	lui	v0,0x8000
20001a28:	34420200 	ori	v0,v0,0x200
20001a2c:	8c440004 	lw	a0,4(v0)
20001a30:	2403fdff 	li	v1,-513
20001a34:	00831824 	and	v1,a0,v1
20001a38:	ac430004 	sw	v1,4(v0)
20001a3c:	8c440004 	lw	a0,4(v0)
	GPIO_Write(LED_Pin, led_state);
20001a40:	8f830004 	lw	v1,4(gp)
/**
 * Initialises the GPIO pin and outputs the initial value to the LED.
 */
void Flashing_LED_Init(void)
{
	GPIO_Set_Direction(LED_Pin, GPIO_OUTPUT);
20001a44:	34840200 	ori	a0,a0,0x200
20001a48:	ac440004 	sw	a0,4(v0)
	GPIO_Write(LED_Pin, led_state);
20001a4c:	2c640001 	sltiu	a0,v1,1
20001a50:	8c450000 	lw	a1,0(v0)
20001a54:	00042240 	sll	a0,a0,0x9
20001a58:	00042027 	nor	a0,zero,a0
20001a5c:	00852024 	and	a0,a0,a1
20001a60:	ac440000 	sw	a0,0(v0)
20001a64:	8c440000 	lw	a0,0(v0)
20001a68:	00031a40 	sll	v1,v1,0x9
20001a6c:	00641825 	or	v1,v1,a0
20001a70:	ac430000 	sw	v1,0(v0)
}
20001a74:	03e00008 	jr	ra
20001a78:	00000000 	nop

20001a7c <Flashing_LED_Toggle>:
/**
 * Toggles the state of the GPIO pin and its LED.
 */
void Flashing_LED_Toggle(void)
{
	GPIO_Write(LED_Pin, led_state);
20001a7c:	8f830004 	lw	v1,4(gp)
20001a80:	3c028000 	lui	v0,0x8000
20001a84:	34420200 	ori	v0,v0,0x200
20001a88:	2c640001 	sltiu	a0,v1,1
20001a8c:	8c460000 	lw	a2,0(v0)
20001a90:	00042a40 	sll	a1,a0,0x9
20001a94:	00052827 	nor	a1,zero,a1
20001a98:	00a62824 	and	a1,a1,a2
20001a9c:	ac450000 	sw	a1,0(v0)
20001aa0:	8c450000 	lw	a1,0(v0)
20001aa4:	00033240 	sll	a2,v1,0x9
20001aa8:	00c52825 	or	a1,a2,a1
	if(System_Mode_G == Set)
20001aac:	8f860104 	lw	a2,260(gp)
/**
 * Toggles the state of the GPIO pin and its LED.
 */
void Flashing_LED_Toggle(void)
{
	GPIO_Write(LED_Pin, led_state);
20001ab0:	ac450000 	sw	a1,0(v0)
	if(System_Mode_G == Set)
20001ab4:	24050001 	li	a1,1
20001ab8:	14c5000a 	bne	a2,a1,20001ae4 <Flashing_LED_Toggle+0x68>
20001abc:	00000000 	nop
	{
		GPIO_Write(Error_Lamp, led_state);
20001ac0:	8c450000 	lw	a1,0(v0)
20001ac4:	00042200 	sll	a0,a0,0x8
20001ac8:	00042027 	nor	a0,zero,a0
20001acc:	00852024 	and	a0,a0,a1
20001ad0:	ac440000 	sw	a0,0(v0)
20001ad4:	8c440000 	lw	a0,0(v0)
20001ad8:	00032a00 	sll	a1,v1,0x8
20001adc:	080006be 	j	20001af8 <Flashing_LED_Toggle+0x7c>
20001ae0:	00a42025 	or	a0,a1,a0
	}
	else
	{
		GPIO_Write(Error_Lamp, GPIO_LOW);
20001ae4:	8c450000 	lw	a1,0(v0)
20001ae8:	2404feff 	li	a0,-257
20001aec:	00a42024 	and	a0,a1,a0
20001af0:	ac440000 	sw	a0,0(v0)
20001af4:	8c440000 	lw	a0,0(v0)
	}
	led_state = !led_state;
20001af8:	2c630001 	sltiu	v1,v1,1
	{
		GPIO_Write(Error_Lamp, led_state);
	}
	else
	{
		GPIO_Write(Error_Lamp, GPIO_LOW);
20001afc:	ac440000 	sw	a0,0(v0)
	}
	led_state = !led_state;
}
20001b00:	03e00008 	jr	ra
20001b04:	af830004 	sw	v1,4(gp)

20001b08 <Course_Corrector_Init>:
 * This will be called from Tasks_Init by default.
 */
void Course_Corrector_Init(void)
{
	/* Initialisation of course correction values */
	Course_correction_Lf = False;
20001b08:	af800074 	sw	zero,116(gp)
	Course_correction_Rt = False;
}
20001b0c:	03e00008 	jr	ra
20001b10:	af800064 	sw	zero,100(gp)

20001b14 <Course_Corrector_Update>:
 * Basic implementation: To reduce the speed of the faster side.
 * Advanced requirement: To recalculate the Script to compensate for deviation.
 */
void Course_Corrector_Update(void)
{
	if(System_Mode_G == Go)
20001b14:	8f830104 	lw	v1,260(gp)
20001b18:	24020002 	li	v0,2
20001b1c:	14620011 	bne	v1,v0,20001b64 <Course_Corrector_Update+0x50>
20001b20:	00000000 	nop
	{
		/* Encoder monitor task */
		/* If the Left side is faster than the Right, activate the Left CC flag */
		if((Motor_Lf_Enc_Track - Motor_Rt_Enc_Track) > COURSE_CORRECTION_BUFFER)
20001b24:	8f820040 	lw	v0,64(gp)
20001b28:	8f8300d8 	lw	v1,216(gp)
20001b2c:	00000000 	nop
20001b30:	00432023 	subu	a0,v0,v1
20001b34:	28840002 	slti	a0,a0,2
20001b38:	14800005 	bnez	a0,20001b50 <Course_Corrector_Update+0x3c>
20001b3c:	00621023 	subu	v0,v1,v0
		{
			Course_correction_Lf = False;
			Course_correction_Rt = True;
20001b40:	24020001 	li	v0,1
20001b44:	af820064 	sw	v0,100(gp)
	{
		/* Encoder monitor task */
		/* If the Left side is faster than the Right, activate the Left CC flag */
		if((Motor_Lf_Enc_Track - Motor_Rt_Enc_Track) > COURSE_CORRECTION_BUFFER)
		{
			Course_correction_Lf = False;
20001b48:	03e00008 	jr	ra
20001b4c:	af800074 	sw	zero,116(gp)
			Course_correction_Rt = True;
		}
		/* If the Right side is faster than the Left, activate the Right CC flag */
		else if((Motor_Rt_Enc_Track - Motor_Lf_Enc_Track) > COURSE_CORRECTION_BUFFER)
20001b50:	28420002 	slti	v0,v0,2
20001b54:	14400003 	bnez	v0,20001b64 <Course_Corrector_Update+0x50>
20001b58:	24020001 	li	v0,1
		{
			Course_correction_Lf = True;
20001b5c:	080006da 	j	20001b68 <Course_Corrector_Update+0x54>
20001b60:	af820074 	sw	v0,116(gp)

	}
	/* Ensure default is False */
	else
	{
		Course_correction_Lf = False;
20001b64:	af800074 	sw	zero,116(gp)
		Course_correction_Rt = False;
20001b68:	03e00008 	jr	ra
20001b6c:	af800064 	sw	zero,100(gp)

20001b70 <CAN_relay_Init>:
 * This will be called from Tasks_Init by default.
 */
void CAN_relay_Init(void)
{
	/* Initialisation of variables */
	motor_speed_Lf = 0x0;
20001b70:	a7800196 	sh	zero,406(gp)
	motor_speed_Rt = 0x0;
20001b74:	a7800194 	sh	zero,404(gp)
	motor_direction_Lf = 0x0;
20001b78:	a3800198 	sb	zero,408(gp)
	motor_direction_Rt = 0x0;
20001b7c:	a3800192 	sb	zero,402(gp)
	canIDLf = 0;
20001b80:	af8000e8 	sw	zero,232(gp)
	canIDRt = 0;
20001b84:	af800068 	sw	zero,104(gp)
20001b88:	00001021 	move	v0,zero
	for(uint8_t i = 0; i < 8; i++)
	{
		candataLf[i] = 0;
20001b8c:	2785006c 	addiu	a1,gp,108
		candataRt[i] = 0;
20001b90:	27840098 	addiu	a0,gp,152
	motor_speed_Rt = 0x0;
	motor_direction_Lf = 0x0;
	motor_direction_Rt = 0x0;
	canIDLf = 0;
	canIDRt = 0;
	for(uint8_t i = 0; i < 8; i++)
20001b94:	24030008 	li	v1,8
	{
		candataLf[i] = 0;
20001b98:	00453821 	addu	a3,v0,a1
		candataRt[i] = 0;
20001b9c:	00443021 	addu	a2,v0,a0
20001ba0:	24420001 	addiu	v0,v0,1
	motor_direction_Rt = 0x0;
	canIDLf = 0;
	canIDRt = 0;
	for(uint8_t i = 0; i < 8; i++)
	{
		candataLf[i] = 0;
20001ba4:	a0e00000 	sb	zero,0(a3)
	motor_speed_Rt = 0x0;
	motor_direction_Lf = 0x0;
	motor_direction_Rt = 0x0;
	canIDLf = 0;
	canIDRt = 0;
	for(uint8_t i = 0; i < 8; i++)
20001ba8:	1443fffb 	bne	v0,v1,20001b98 <CAN_relay_Init+0x28>
20001bac:	a0c00000 	sb	zero,0(a2)
		candataLf[i] = 0;
		candataRt[i] = 0;
	}

	/* Initialisation of Sensor Readings */
	sensorReadings.IRLeft = 0xFF;
20001bb0:	3c044000 	lui	a0,0x4000
20001bb4:	240200ff 	li	v0,255
	sensorReadings.IRRight = 0xFF;
20001bb8:	248303dc 	addiu	v1,a0,988
	sensorReadings.USFwd = 0xFF;
20001bbc:	ac620008 	sw	v0,8(v1)
		candataLf[i] = 0;
		candataRt[i] = 0;
	}

	/* Initialisation of Sensor Readings */
	sensorReadings.IRLeft = 0xFF;
20001bc0:	ac8203dc 	sw	v0,988(a0)
	sensorReadings.IRRight = 0xFF;
	sensorReadings.USFwd = 0xFF;
}
20001bc4:	03e00008 	jr	ra
20001bc8:	ac620004 	sw	v0,4(v1)

20001bcc <readCAN>:
	}
}

void readCAN(void)
{
	if((bufferRX0.ID & 0xFF) == 0xC4)
20001bcc:	3c024000 	lui	v0,0x4000
20001bd0:	244203bc 	addiu	v0,v0,956
20001bd4:	90440004 	lbu	a0,4(v0)
20001bd8:	240300c4 	li	v1,196
20001bdc:	14830010 	bne	a0,v1,20001c20 <readCAN+0x54>
20001be0:	00000000 	nop
	{
		/* Check to see data received from Proximity sensor */
		sensorReadings.IRLeft = bufferRX0.CAN_Data[3] & 0x3F;
		sensorReadings.IRRight = bufferRX0.CAN_Data[5] & 0x3F;

		sensorReadings.USFwd = ((((bufferRX0.CAN_Data[6] & 0x3F) << 6) | (bufferRX0.CAN_Data[7] & 0x3F)) & 0x0FFF);
20001be4:	9046000e 	lbu	a2,14(v0)
20001be8:	9043000f 	lbu	v1,15(v0)
void readCAN(void)
{
	if((bufferRX0.ID & 0xFF) == 0xC4)
	{
		/* Check to see data received from Proximity sensor */
		sensorReadings.IRLeft = bufferRX0.CAN_Data[3] & 0x3F;
20001bec:	9045000b 	lbu	a1,11(v0)
		sensorReadings.IRRight = bufferRX0.CAN_Data[5] & 0x3F;
20001bf0:	9044000d 	lbu	a0,13(v0)

		sensorReadings.USFwd = ((((bufferRX0.CAN_Data[6] & 0x3F) << 6) | (bufferRX0.CAN_Data[7] & 0x3F)) & 0x0FFF);
20001bf4:	30c6003f 	andi	a2,a2,0x3f
20001bf8:	3062003f 	andi	v0,v1,0x3f
20001bfc:	00063180 	sll	a2,a2,0x6
void readCAN(void)
{
	if((bufferRX0.ID & 0xFF) == 0xC4)
	{
		/* Check to see data received from Proximity sensor */
		sensorReadings.IRLeft = bufferRX0.CAN_Data[3] & 0x3F;
20001c00:	3c034000 	lui	v1,0x4000
		sensorReadings.IRRight = bufferRX0.CAN_Data[5] & 0x3F;

		sensorReadings.USFwd = ((((bufferRX0.CAN_Data[6] & 0x3F) << 6) | (bufferRX0.CAN_Data[7] & 0x3F)) & 0x0FFF);
20001c04:	00c23025 	or	a2,a2,v0
void readCAN(void)
{
	if((bufferRX0.ID & 0xFF) == 0xC4)
	{
		/* Check to see data received from Proximity sensor */
		sensorReadings.IRLeft = bufferRX0.CAN_Data[3] & 0x3F;
20001c08:	30a5003f 	andi	a1,a1,0x3f
		sensorReadings.IRRight = bufferRX0.CAN_Data[5] & 0x3F;
20001c0c:	246203dc 	addiu	v0,v1,988
20001c10:	3084003f 	andi	a0,a0,0x3f

		sensorReadings.USFwd = ((((bufferRX0.CAN_Data[6] & 0x3F) << 6) | (bufferRX0.CAN_Data[7] & 0x3F)) & 0x0FFF);
20001c14:	ac460008 	sw	a2,8(v0)
void readCAN(void)
{
	if((bufferRX0.ID & 0xFF) == 0xC4)
	{
		/* Check to see data received from Proximity sensor */
		sensorReadings.IRLeft = bufferRX0.CAN_Data[3] & 0x3F;
20001c18:	ac6503dc 	sw	a1,988(v1)
		sensorReadings.IRRight = bufferRX0.CAN_Data[5] & 0x3F;
20001c1c:	ac440004 	sw	a0,4(v0)
20001c20:	03e00008 	jr	ra
20001c24:	00000000 	nop

20001c28 <constructCANEnc>:
}

void constructCANEnc(void)
{

	candataEnc[0] =  (WheelCounts_Left_G  >>24)&0xFF;
20001c28:	8f830088 	lw	v1,136(gp)
	candataEnc[1] =  (WheelCounts_Left_G  >>16)&0xFF;
	candataEnc[2] =  (WheelCounts_Left_G  >>8) &0xFF;
	candataEnc[3] =  (WheelCounts_Left_G  >>0) &0xFF;
	candataEnc[4] =  (WheelCounts_Right_G >>24)&0xFF;
20001c2c:	8f8200c8 	lw	v0,200(gp)
}

void constructCANEnc(void)
{

	candataEnc[0] =  (WheelCounts_Left_G  >>24)&0xFF;
20001c30:	00034e02 	srl	t1,v1,0x18
	candataEnc[1] =  (WheelCounts_Left_G  >>16)&0xFF;
20001c34:	00034403 	sra	t0,v1,0x10
	candataEnc[2] =  (WheelCounts_Left_G  >>8) &0xFF;
20001c38:	00033a03 	sra	a3,v1,0x8
	candataEnc[3] =  (WheelCounts_Left_G  >>0) &0xFF;
	candataEnc[4] =  (WheelCounts_Right_G >>24)&0xFF;
20001c3c:	00023602 	srl	a2,v0,0x18
	candataEnc[5] =  (WheelCounts_Right_G >>16)&0xFF;
20001c40:	00022c03 	sra	a1,v0,0x10
	candataEnc[6] =  (WheelCounts_Right_G >>8) &0xFF;
20001c44:	00022203 	sra	a0,v0,0x8
}

void constructCANEnc(void)
{

	candataEnc[0] =  (WheelCounts_Left_G  >>24)&0xFF;
20001c48:	a38900a8 	sb	t1,168(gp)
	candataEnc[1] =  (WheelCounts_Left_G  >>16)&0xFF;
20001c4c:	a38800a9 	sb	t0,169(gp)
	candataEnc[2] =  (WheelCounts_Left_G  >>8) &0xFF;
20001c50:	a38700aa 	sb	a3,170(gp)
	candataEnc[3] =  (WheelCounts_Left_G  >>0) &0xFF;
20001c54:	a38300ab 	sb	v1,171(gp)
	candataEnc[4] =  (WheelCounts_Right_G >>24)&0xFF;
20001c58:	a38600ac 	sb	a2,172(gp)
	candataEnc[5] =  (WheelCounts_Right_G >>16)&0xFF;
20001c5c:	a38500ad 	sb	a1,173(gp)
	candataEnc[6] =  (WheelCounts_Right_G >>8) &0xFF;
20001c60:	a38400ae 	sb	a0,174(gp)
	candataEnc[7] =  (WheelCounts_Right_G >>0) &0xFF;
}
20001c64:	03e00008 	jr	ra
20001c68:	a38200af 	sb	v0,175(gp)

20001c6c <CAN_relay_Update>:

/**
 * Retrieves and translates the Speed and Direction from the Motor Tasks into CAN messages.
 */
void CAN_relay_Update(void)
{
20001c6c:	27bdffe8 	addiu	sp,sp,-24
20001c70:	afbf0014 	sw	ra,20(sp)
	/* If the System is in GO mode, perform the calculations and translation */
	//if(System_Mode_G == Go)
	{
		/* Read CAN buffer */
		readCAN();
20001c74:	0c0006f3 	jal	20001bcc <readCAN>
20001c78:	00000000 	nop

		/* Motor direction control */
		switch(Left_motor_direction_G)
20001c7c:	8f820094 	lw	v0,148(gp)
20001c80:	24030001 	li	v1,1
20001c84:	10430003 	beq	v0,v1,20001c94 <CAN_relay_Update+0x28>
20001c88:	24030002 	li	v1,2
20001c8c:	14430003 	bne	v0,v1,20001c9c <CAN_relay_Update+0x30>
20001c90:	00000000 	nop
		case Forwards:
			motor_direction_Lf = 0x1;
			break;
		case Reverse:
			motor_direction_Lf = 0x2;
			break;
20001c94:	08000728 	j	20001ca0 <CAN_relay_Update+0x34>
20001c98:	a3820198 	sb	v0,408(gp)
		case Off:
		default:
			motor_direction_Lf = 0x0;
20001c9c:	a3800198 	sb	zero,408(gp)
			break;
		}

		switch(Right_motor_direction_G)
20001ca0:	8f820084 	lw	v0,132(gp)
20001ca4:	24030001 	li	v1,1
20001ca8:	10430003 	beq	v0,v1,20001cb8 <CAN_relay_Update+0x4c>
20001cac:	24030002 	li	v1,2
20001cb0:	14430003 	bne	v0,v1,20001cc0 <CAN_relay_Update+0x54>
20001cb4:	00000000 	nop
		case Forwards:
			motor_direction_Rt = 0x1;
			break;
		case Reverse:
			motor_direction_Rt = 0x2;
			break;
20001cb8:	08000731 	j	20001cc4 <CAN_relay_Update+0x58>
20001cbc:	a3820192 	sb	v0,402(gp)
		case Off:
		default:
			motor_direction_Rt = 0x0;
20001cc0:	a3800192 	sb	zero,402(gp)
			break;
		}

		/* Motor speed value has a resolution of 0.5 RPM per bit; multiply value by 2 */
		motor_speed_Lf = Left_motor_speed_G * 2;
20001cc4:	978300b0 	lhu	v1,176(gp)
		motor_speed_Rt = Right_motor_speed_G * 2;
20001cc8:	978200b2 	lhu	v0,178(gp)
			motor_direction_Rt = 0x0;
			break;
		}

		/* Motor speed value has a resolution of 0.5 RPM per bit; multiply value by 2 */
		motor_speed_Lf = Left_motor_speed_G * 2;
20001ccc:	00031840 	sll	v1,v1,0x1
20001cd0:	3063ffff 	andi	v1,v1,0xffff
	 * Byte 2: Motor speed LO_BYTE
	 * Byte 3: Motor speed HI_BYTE
	 */
	candataLf[0] = motor_direction_Lf & 0x3;
	candataLf[2] = motor_speed_Lf & 0xFF;
	candataLf[3] = motor_speed_Lf >> 8;
20001cd4:	00033202 	srl	a2,v1,0x8
			break;
		}

		/* Motor speed value has a resolution of 0.5 RPM per bit; multiply value by 2 */
		motor_speed_Lf = Left_motor_speed_G * 2;
		motor_speed_Rt = Right_motor_speed_G * 2;
20001cd8:	00021040 	sll	v0,v0,0x1
	/* CAN_Data
	 * Byte 0: Motor direction
	 * Byte 2: Motor speed LO_BYTE
	 * Byte 3: Motor speed HI_BYTE
	 */
	candataLf[0] = motor_direction_Lf & 0x3;
20001cdc:	93870198 	lbu	a3,408(gp)
}

void constructCANRt(void)
{
	canIDRt = 0x10EFD100;
	candataRt[0] = motor_direction_Rt & 0x3;
20001ce0:	93850192 	lbu	a1,402(gp)
			break;
		}

		/* Motor speed value has a resolution of 0.5 RPM per bit; multiply value by 2 */
		motor_speed_Lf = Left_motor_speed_G * 2;
		motor_speed_Rt = Right_motor_speed_G * 2;
20001ce4:	3042ffff 	andi	v0,v0,0xffff
	 * Byte 0: Priority. (Bits 3,4,5) [Bits 0,1,2,6,7 excluded]
	 * Byte 1: PDU1 Proprietary A identifier for peer-to-peer communications.
	 * Byte 2: Destination Peer Address: Motor Controller Address. Configurable using MC configuration utility.
	 * Byte 3: Source Peer Address.
	 */
	canIDLf = 0x14EFD000;
20001ce8:	3c0814ef 	lui	t0,0x14ef
	 * Byte 2: Motor speed LO_BYTE
	 * Byte 3: Motor speed HI_BYTE
	 */
	candataLf[0] = motor_direction_Lf & 0x3;
	candataLf[2] = motor_speed_Lf & 0xFF;
	candataLf[3] = motor_speed_Lf >> 8;
20001cec:	a386006f 	sb	a2,111(gp)
}

void constructCANRt(void)
{
	canIDRt = 0x10EFD100;
20001cf0:	3c0610ef 	lui	a2,0x10ef
	/* CAN_Data
	 * Byte 0: Motor direction
	 * Byte 2: Motor speed LO_BYTE
	 * Byte 3: Motor speed HI_BYTE
	 */
	candataLf[0] = motor_direction_Lf & 0x3;
20001cf4:	30e70003 	andi	a3,a3,0x3
}

void constructCANRt(void)
{
	canIDRt = 0x10EFD100;
	candataRt[0] = motor_direction_Rt & 0x3;
20001cf8:	30a50003 	andi	a1,a1,0x3
	candataRt[2] = motor_speed_Rt & 0xFF;
	candataRt[3] = motor_speed_Rt >> 8;
20001cfc:	00022202 	srl	a0,v0,0x8
	 * Byte 0: Priority. (Bits 3,4,5) [Bits 0,1,2,6,7 excluded]
	 * Byte 1: PDU1 Proprietary A identifier for peer-to-peer communications.
	 * Byte 2: Destination Peer Address: Motor Controller Address. Configurable using MC configuration utility.
	 * Byte 3: Source Peer Address.
	 */
	canIDLf = 0x14EFD000;
20001d00:	3508d000 	ori	t0,t0,0xd000
	candataLf[3] = motor_speed_Lf >> 8;
}

void constructCANRt(void)
{
	canIDRt = 0x10EFD100;
20001d04:	34c6d100 	ori	a2,a2,0xd100
	/* Force the Robot to stop by flooding the CAN with the STOP message */
	//else
	{
		//constructStopCAN();
	}
}
20001d08:	8fbf0014 	lw	ra,20(sp)
20001d0c:	27bd0018 	addiu	sp,sp,24
	 * Byte 0: Priority. (Bits 3,4,5) [Bits 0,1,2,6,7 excluded]
	 * Byte 1: PDU1 Proprietary A identifier for peer-to-peer communications.
	 * Byte 2: Destination Peer Address: Motor Controller Address. Configurable using MC configuration utility.
	 * Byte 3: Source Peer Address.
	 */
	canIDLf = 0x14EFD000;
20001d10:	af8800e8 	sw	t0,232(gp)
	/* CAN_Data
	 * Byte 0: Motor direction
	 * Byte 2: Motor speed LO_BYTE
	 * Byte 3: Motor speed HI_BYTE
	 */
	candataLf[0] = motor_direction_Lf & 0x3;
20001d14:	a387006c 	sb	a3,108(gp)
	candataLf[3] = motor_speed_Lf >> 8;
}

void constructCANRt(void)
{
	canIDRt = 0x10EFD100;
20001d18:	af860068 	sw	a2,104(gp)
	candataRt[0] = motor_direction_Rt & 0x3;
20001d1c:	a3850098 	sb	a1,152(gp)
	candataRt[2] = motor_speed_Rt & 0xFF;
	candataRt[3] = motor_speed_Rt >> 8;
20001d20:	a384009b 	sb	a0,155(gp)
			motor_direction_Rt = 0x0;
			break;
		}

		/* Motor speed value has a resolution of 0.5 RPM per bit; multiply value by 2 */
		motor_speed_Lf = Left_motor_speed_G * 2;
20001d24:	a7830196 	sh	v1,406(gp)
		motor_speed_Rt = Right_motor_speed_G * 2;
20001d28:	a7820194 	sh	v0,404(gp)
	 * Byte 0: Motor direction
	 * Byte 2: Motor speed LO_BYTE
	 * Byte 3: Motor speed HI_BYTE
	 */
	candataLf[0] = motor_direction_Lf & 0x3;
	candataLf[2] = motor_speed_Lf & 0xFF;
20001d2c:	a383006e 	sb	v1,110(gp)


		/* Construct the CAN messages based on the information */
		constructCANLf();
		constructCANRt();
		constructCANEnc();
20001d30:	0800070a 	j	20001c28 <constructCANEnc>
20001d34:	a382009a 	sb	v0,154(gp)

20001d38 <Handler>:
        .section .text.Handler
        .ent Handler
        .set noat
        .set noreorder
Handler:
        mfc0   $26, $13			# Read CP0 Cause register
20001d38:	401a6800 	mfc0	k0,c0_cause
		nop
20001d3c:	00000000 	nop
		and    $27, $26, 0x3f
20001d40:	335b003f 	andi	k1,k0,0x3f
		la	   $26, TableBase
20001d44:	3c1a4000 	lui	k0,0x4000
20001d48:	275a0138 	addiu	k0,k0,312
		addu   $26, $26, $27
20001d4c:	035bd021 	addu	k0,k0,k1
		lw     $27, 0($26)
20001d50:	8f5b0000 	lw	k1,0(k0)
		nop
20001d54:	00000000 	nop
		j	   $27
20001d58:	03600008 	jr	k1
        nop
20001d5c:	00000000 	nop

20001d60 <End_Handler>:
        .end Handler

      .globl End_Handler
      .ent End_Handler
End_Handler:
 		mfc0   $26,$14         # Read CP0 EPC return address Reg
20001d60:	401a7000 	mfc0	k0,c0_epc
        nop
20001d64:	00000000 	nop
        j      $26             # Return from handler
20001d68:	03400008 	jr	k0
        rfe
20001d6c:	42000010 	rfe

20001d70 <Excpt_Unused>:
	.set noreorder
	.set noat

	.globl Excpt_Unused
Excpt_Unused:
        j    Excpt_Unused 	# Loop
20001d70:	0800075c 00000000                       \.......

20001d78 <Excpt_IAbort>:
        nop

	.globl Excpt_IAbort
Excpt_IAbort:
		mfc0   $26,$14         # Read CP0 EPC return address Reg
20001d78:	401a7000 0800075e 00000000              .p.@^.......

20001d84 <Excpt_DAbort>:
        j    Excpt_IAbort 	   # Loop
        nop

	.globl Excpt_DAbort
Excpt_DAbort:
        j    Excpt_DAbort 	   # Loop
20001d84:	08000761 00000000                       a.......

20001d8c <Excpt_Syscall>:
        nop

	.globl Excpt_Syscall
Excpt_Syscall:
        j    Excpt_Syscall 	   # Loop
20001d8c:	08000763 00000000                       c.......

20001d94 <Excpt_UndefInst>:
        nop

	.globl Excpt_UndefInst
Excpt_UndefInst:
        j    Excpt_UndefInst   # Loop
20001d94:	08000765 00000000                       e.......

20001d9c <Excpt_Overflow>:
        nop

	.globl Excpt_Overflow
Excpt_Overflow:
        j    Excpt_Overflow	   # Loop
20001d9c:	08000767 00000000                       g.......

20001da4 <Excpt_CoPro>:
        nop

	.globl Excpt_CoPro
Excpt_CoPro:
        j    Excpt_CoPro	   # Loop
20001da4:	08000769 00000000                       i.......

20001dac <Excpt_Break>:
        nop

	.globl Excpt_Break
Excpt_Break:
        j    Excpt_Break	   # Loop
20001dac:	0800076b 00000000                       k.......

20001db4 <InterruptHandler>:
        .ent InterruptHandler
        .set noat
        .set noreorder
InterruptHandler:
		/* Temporarily store the User Stack Pointer */
		move $k1, $sp
20001db4:	03a0d821 	move	k1,sp

		/* Load the IRQ Stack Pointer */
		la $k0, IRQ_Stk_Base_Val
20001db8:	3c1a4000 	lui	k0,0x4000
20001dbc:	375a4000 	ori	k0,k0,0x4000
		move $sp, $k0
20001dc0:	0340e821 	move	sp,k0

		/* Allocate stack space */
#ifndef FPU
		subu $sp, 120
20001dc4:	27bdff88 	addiu	sp,sp,-120
#else
		subu $sp, 252
#endif

		/* Save all the key general purpose registers */
		sw $ra,   4($sp)
20001dc8:	afbf0004 	sw	ra,4(sp)
        sw $t9,   8($sp)
20001dcc:	afb90008 	sw	t9,8(sp)
        sw $t8,  12($sp)
20001dd0:	afb8000c 	sw	t8,12(sp)
        sw $s7,  16($sp)
20001dd4:	afb70010 	sw	s7,16(sp)
        sw $s6,  20($sp)
20001dd8:	afb60014 	sw	s6,20(sp)
        sw $s5,  24($sp)
20001ddc:	afb50018 	sw	s5,24(sp)
        sw $s4,  28($sp)
20001de0:	afb4001c 	sw	s4,28(sp)
        sw $s3,  32($sp)
20001de4:	afb30020 	sw	s3,32(sp)
        sw $s2,  36($sp)
20001de8:	afb20024 	sw	s2,36(sp)
        sw $s1,  40($sp)
20001dec:	afb10028 	sw	s1,40(sp)
        sw $s0,  44($sp)
20001df0:	afb0002c 	sw	s0,44(sp)
        sw $t7,  48($sp)
20001df4:	afaf0030 	sw	t7,48(sp)
        sw $t6,  52($sp)
20001df8:	afae0034 	sw	t6,52(sp)
        sw $t5,  56($sp)
20001dfc:	afad0038 	sw	t5,56(sp)
        sw $t4,  60($sp)
20001e00:	afac003c 	sw	t4,60(sp)
        sw $t3,  64($sp)
20001e04:	afab0040 	sw	t3,64(sp)
        sw $t2,  68($sp)
20001e08:	afaa0044 	sw	t2,68(sp)
        sw $t1,  72($sp)
20001e0c:	afa90048 	sw	t1,72(sp)
        sw $t0,  76($sp)
20001e10:	afa8004c 	sw	t0,76(sp)
        sw $a3,  80($sp)
20001e14:	afa70050 	sw	a3,80(sp)
        sw $a2,  84($sp)
20001e18:	afa60054 	sw	a2,84(sp)
        sw $a1,  88($sp)
20001e1c:	afa50058 	sw	a1,88(sp)
        sw $a0,  92($sp)
20001e20:	afa4005c 	sw	a0,92(sp)
        sw $v1,  96($sp)
20001e24:	afa30060 	sw	v1,96(sp)
        sw $v0, 100($sp)
20001e28:	afa20064 	sw	v0,100(sp)
        sw $at, 104($sp)
20001e2c:	afa10068 	sw	at,104(sp)
        sw $k1, 108($sp)
20001e30:	afbb006c 	sw	k1,108(sp)
		swc1 $f31, 236($sp)
		sw $t1, 240($sp)
#endif

        /* Get the Return Address (EPC) */
        mfc0 $k0, $14
20001e34:	401a7000 	mfc0	k0,c0_epc

		/* Store the stack frame */
#ifndef FPU
		sw $fp, 112($sp)
20001e38:	afbe0070 	sw	s8,112(sp)
		sw $k0, 116($sp)
20001e3c:	afba0074 	sw	k0,116(sp)
#else
		sw $fp, 244($sp)
		sw $k0, 248($sp)
#endif
		move $fp,$sp
20001e40:	03a0f021 	move	s8,sp

		/* Clear pending interrupts */
		mfc0 $26,$13
20001e44:	401a6800 	mfc0	k0,c0_cause
        nop
20001e48:	00000000 	nop
        li   $26,0xFF00
20001e4c:	341aff00 	li	k0,0xff00
        mtc0 $26,$13
20001e50:	409a6800 	mtc0	k0,c0_cause

 		subu $sp, 24
20001e54:	27bdffe8 	addiu	sp,sp,-24

		/* Call C handler */
 		jal   Handle_Interrupts
20001e58:	0c000ab3 	jal	20002acc <Handle_Interrupts>
        nop
20001e5c:	00000000 	nop

        addu $sp, 24
20001e60:	27bd0018 	addiu	sp,sp,24
		lwc1 $f31, 236($sp)
		ctc1 $t0, $31
#endif

		/* Restore all the key general purpose registers */
		lw $ra,   4($sp)
20001e64:	8fbf0004 	lw	ra,4(sp)
        lw $t9,   8($sp)
20001e68:	8fb90008 	lw	t9,8(sp)
        lw $t8,  12($sp)
20001e6c:	8fb8000c 	lw	t8,12(sp)
        lw $s7,  16($sp)
20001e70:	8fb70010 	lw	s7,16(sp)
        lw $s6,  20($sp)
20001e74:	8fb60014 	lw	s6,20(sp)
        lw $s5,  24($sp)
20001e78:	8fb50018 	lw	s5,24(sp)
        lw $s4,  28($sp)
20001e7c:	8fb4001c 	lw	s4,28(sp)
        lw $s3,  32($sp)
20001e80:	8fb30020 	lw	s3,32(sp)
        lw $s2,  36($sp)
20001e84:	8fb20024 	lw	s2,36(sp)
        lw $s1,  40($sp)
20001e88:	8fb10028 	lw	s1,40(sp)
        lw $s0,  44($sp)
20001e8c:	8fb0002c 	lw	s0,44(sp)
        lw $t7,  48($sp)
20001e90:	8faf0030 	lw	t7,48(sp)
        lw $t6,  52($sp)
20001e94:	8fae0034 	lw	t6,52(sp)
        lw $t5,  56($sp)
20001e98:	8fad0038 	lw	t5,56(sp)
        lw $t4,  60($sp)
20001e9c:	8fac003c 	lw	t4,60(sp)
        lw $t3,  64($sp)
20001ea0:	8fab0040 	lw	t3,64(sp)
        lw $t2,  68($sp)
20001ea4:	8faa0044 	lw	t2,68(sp)
        lw $t1,  72($sp)
20001ea8:	8fa90048 	lw	t1,72(sp)
        lw $t0,  76($sp)
20001eac:	8fa8004c 	lw	t0,76(sp)
        lw $a3,  80($sp)
20001eb0:	8fa70050 	lw	a3,80(sp)
        lw $a2,  84($sp)
20001eb4:	8fa60054 	lw	a2,84(sp)
        lw $a1,  88($sp)
20001eb8:	8fa50058 	lw	a1,88(sp)
        lw $a0,  92($sp)
20001ebc:	8fa4005c 	lw	a0,92(sp)
        lw $v1,  96($sp)
20001ec0:	8fa30060 	lw	v1,96(sp)
        lw $v0, 100($sp)
20001ec4:	8fa20064 	lw	v0,100(sp)
        lw $at, 104($sp)
20001ec8:	8fa10068 	lw	at,104(sp)
        lw $k0, 108($sp)
20001ecc:	8fba006c 	lw	k0,108(sp)

#ifndef FPU
		/* Restore the stack frame */
		lw	$fp,112($sp)
20001ed0:	8fbe0070 	lw	s8,112(sp)

        /* Get the Return Address (EPC) */
        lw $k1, 116($sp)
20001ed4:	8fbb0074 	lw	k1,116(sp)
        
        /* Restore the stack pointer */
        addu $sp, 120
20001ed8:	27bd0078 	addiu	sp,sp,120

        /* Restore the stack pointer */
        addu $sp, 252
#endif
        /* Load the User Stack Pointer */
        move $sp, $k0
20001edc:	0340e821 	move	sp,k0

        /* Return from interrupt */
        j  $k1
20001ee0:	03600008 	jr	k1

20001ee4 <End_IRQ_Ptr>:
End_IRQ_Ptr:
        rfe
20001ee4:	42000010                                ...B

20001ee8 <Enable_Interrupts>:
	.global Enable_Interrupts
	.ent Enable_Interrupts

        .set noreorder
Enable_Interrupts:
        addiu   $29, $29, -24
20001ee8:	27bdffe8 	addiu	sp,sp,-24
        .frame $29, 24, $31
        sw   $8, 4($29)
20001eec:	afa80004 	sw	t0,4(sp)

        mfc0   $8, $12
20001ef0:	40086000 	mfc0	t0,c0_sr
        nop
20001ef4:	00000000 	nop
        ori   $8, $8, 0x01
20001ef8:	35080001 	ori	t0,t0,0x1
        nop
20001efc:	00000000 	nop
        mtc0   $8, $12
20001f00:	40886000 	mtc0	t0,c0_sr
        nop
20001f04:	00000000 	nop

        lw   $8, 4($29)
20001f08:	8fa80004 	lw	t0,4(sp)
        addiu   $29, $29, 24
20001f0c:	27bd0018 	addiu	sp,sp,24
        jr   $31
20001f10:	03e00008 	jr	ra
        nop
20001f14:	00000000 	nop

20001f18 <Disable_Interrupts>:
	.global Disable_Interrupts
	.ent Disable_Interrupts

    	.set noreorder
Disable_Interrupts:
        addiu   $29, $29, -24
20001f18:	27bdffe8 	addiu	sp,sp,-24
        .frame $29, 24, $31
        sw   $8, 4($29)
20001f1c:	afa80004 	sw	t0,4(sp)

        mfc0    $8, $12
20001f20:	40086000 	mfc0	t0,c0_sr
        lui     $9, 0xFFFF
20001f24:	3c09ffff 	lui	t1,0xffff
        ori     $9, 0xFFFE
20001f28:	3529fffe 	ori	t1,t1,0xfffe
        nop
20001f2c:	00000000 	nop
        and     $8, $8, $9
20001f30:	01094024 	and	t0,t0,t1
        nop
20001f34:	00000000 	nop
        mtc0   $8, $12
20001f38:	40886000 	mtc0	t0,c0_sr
        nop
20001f3c:	00000000 	nop

        lw   $8, 4($29)
20001f40:	8fa80004 	lw	t0,4(sp)
        addiu   $29, $29, 24
20001f44:	27bd0018 	addiu	sp,sp,24
        jr   $31
20001f48:	03e00008 	jr	ra
        nop
20001f4c:	00000000 	nop

20001f50 <Enter_Sleep_Mode>:
	.global Sleep_Ptr
	.ent Enter_Sleep_Mode

    	.set noreorder
Enter_Sleep_Mode:
        addiu   $29, $29, -24
20001f50:	27bdffe8 	addiu	sp,sp,-24
        .frame $29, 24, $31
        sw   $8, 4($29)
20001f54:	afa80004 	sw	t0,4(sp)

        mfc0   $8, $16
20001f58:	40088000 	mfc0	t0,$16
        ori    $8, $8, 1
20001f5c:	35080001 	ori	t0,t0,0x1

20001f60 <Sleep_Ptr>:
Sleep_Ptr:
        mtc0   $8, $16
20001f60:	40888000 00000000 8fa80004 27bd0018     ...@...........'
        nop

        lw   $8, 4($29)
        addiu   $29, $29, 24
        jr   $31
20001f70:	03e00008 00000000                       ........

20001f78 <LOG_Trigger_Breakpoint>:
	.section .text.LOG_Trigger_Breakpoint
	.global LOG_Trigger_Breakpoint
	.ent LOG_Trigger_Breakpoint
	
LOG_Trigger_Breakpoint:
	jr $31
20001f78:	03e00008 	jr	ra
20001f7c:	00000000 	nop

20001f80 <Scheduler_Tick>:

void Scheduler_Tick(void)
{
#if (Config_Hardware_Scheduler != TRUE)
#if (Config_Logging == TRUE)
	Log_Tick_Start(current_task);
20001f80:	8f840008 	lw	a0,8(gp)

// Found in Scheduler_Tick, below.
extern void Hybrid_End_Label(void);

void Scheduler_Tick(void)
{
20001f84:	27bdffd0 	addiu	sp,sp,-48
20001f88:	afb60028 	sw	s6,40(sp)
20001f8c:	afb50024 	sw	s5,36(sp)
20001f90:	afb40020 	sw	s4,32(sp)
20001f94:	afb3001c 	sw	s3,28(sp)
20001f98:	afb20018 	sw	s2,24(sp)
20001f9c:	afb00010 	sw	s0,16(sp)
20001fa0:	afbf002c 	sw	ra,44(sp)
#if (Config_Hardware_Scheduler != TRUE)
#if (Config_Logging == TRUE)
	Log_Tick_Start(current_task);
20001fa4:	0c0009d0 	jal	20002740 <Log_Tick_Start>
20001fa8:	afb10014 	sw	s1,20(sp)
#endif

	system_time += tick_skip_time;
20001fac:	8f82000c 	lw	v0,12(gp)

	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
	{
		Tasks[i].delay_counter -= tick_skip_time;
20001fb0:	3c124000 	lui	s2,0x4000
#if (Config_Hardware_Scheduler != TRUE)
#if (Config_Logging == TRUE)
	Log_Tick_Start(current_task);
#endif

	system_time += tick_skip_time;
20001fb4:	24420001 	addiu	v0,v0,1
#if (Config_Hybrid_Tasks == TRUE)
		if (Task_Ready(i, TRUE))
		{
			Tasks[i].delay_counter = Tasks[i].period_reload;
#if (Config_Logging == TRUE)
			Log_Set_Address(TRUE, (uint32_t) Tasks[i].task_function,
20001fb8:	3c162000 	lui	s6,0x2000
	Log_Tick_Start(current_task);
#endif

	system_time += tick_skip_time;

	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
20001fbc:	00008021 	move	s0,zero
#if (Config_Hardware_Scheduler != TRUE)
#if (Config_Logging == TRUE)
	Log_Tick_Start(current_task);
#endif

	system_time += tick_skip_time;
20001fc0:	af82000c 	sw	v0,12(gp)

	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
	{
		Tasks[i].delay_counter -= tick_skip_time;
20001fc4:	26520058 	addiu	s2,s2,88
#if (Config_Hybrid_Tasks == TRUE)
		if (Task_Ready(i, TRUE))
		{
			Tasks[i].delay_counter = Tasks[i].period_reload;
#if (Config_Logging == TRUE)
			Log_Set_Address(TRUE, (uint32_t) Tasks[i].task_function,
20001fc8:	26d62054 	addiu	s6,s6,8276
	Log_Tick_Start(current_task);
#endif

	system_time += tick_skip_time;

	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
20001fcc:	8f95ffd8 	lw	s5,-40(gp)
	{
		Tasks[i].delay_counter -= tick_skip_time;
20001fd0:	24140003 	li	s4,3
	Log_Tick_Start(current_task);
#endif

	system_time += tick_skip_time;

	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
20001fd4:	0800081a 	j	20002068 <Hybrid_End_Label+0x14>
20001fd8:	24130018 	li	s3,24
	{
		Tasks[i].delay_counter -= tick_skip_time;
20001fdc:	00001012 	mflo	v0
20001fe0:	24420001 	addiu	v0,v0,1
20001fe4:	000210c0 	sll	v0,v0,0x3

static inline boolean_t Task_Ready(const uint32_t task_index,
								   TTE_UNUSED const boolean_t in_isr)
{
	// Avoid short-circuiting, to eliminate jitter.
	boolean_t ready = Tasks[task_index].task_function != NULL;
20001fe8:	02130018 	mult	s0,s3

	system_time += tick_skip_time;

	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
	{
		Tasks[i].delay_counter -= tick_skip_time;
20001fec:	00521021 	addu	v0,v0,s2
20001ff0:	8c430000 	lw	v1,0(v0)
20001ff4:	00000000 	nop
20001ff8:	2463ffff 	addiu	v1,v1,-1
20001ffc:	ac430000 	sw	v1,0(v0)

static inline boolean_t Task_Ready(const uint32_t task_index,
								   TTE_UNUSED const boolean_t in_isr)
{
	// Avoid short-circuiting, to eliminate jitter.
	boolean_t ready = Tasks[task_index].task_function != NULL;
20002000:	00008812 	mflo	s1
20002004:	02328821 	addu	s1,s1,s2
20002008:	8e250000 	lw	a1,0(s1)
	ready &= Tasks[task_index].delay_counter <= 0;
2000200c:	8c430000 	lw	v1,0(v0)
20002010:	0005282b 	sltu	a1,zero,a1
20002014:	28630001 	slti	v1,v1,1
#if (Config_Hybrid_Tasks == TRUE)
	ready &= Tasks[task_index].exec_from_isr == in_isr;
20002018:	92240014 	lbu	a0,20(s1)

	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
	{
		Tasks[i].delay_counter -= tick_skip_time;
#if (Config_Hybrid_Tasks == TRUE)
		if (Task_Ready(i, TRUE))
2000201c:	00651824 	and	v1,v1,a1
20002020:	00641824 	and	v1,v1,a0
20002024:	1060000f 	beqz	v1,20002064 <Hybrid_End_Label+0x10>
20002028:	00000000 	nop
		{
			Tasks[i].delay_counter = Tasks[i].period_reload;
2000202c:	8e230004 	lw	v1,4(s1)
#if (Config_Logging == TRUE)
			Log_Set_Address(TRUE, (uint32_t) Tasks[i].task_function,
20002030:	24040001 	li	a0,1
	{
		Tasks[i].delay_counter -= tick_skip_time;
#if (Config_Hybrid_Tasks == TRUE)
		if (Task_Ready(i, TRUE))
		{
			Tasks[i].delay_counter = Tasks[i].period_reload;
20002034:	ac430000 	sw	v1,0(v0)
#if (Config_Logging == TRUE)
			Log_Set_Address(TRUE, (uint32_t) Tasks[i].task_function,
20002038:	8e250000 	lw	a1,0(s1)
2000203c:	0c00093b 	jal	200024ec <Log_Set_Address>
20002040:	02c03021 	move	a2,s6
							(uint32_t) Hybrid_End_Label);
#endif

			(*Tasks[i].task_function)();
20002044:	8e220000 	lw	v0,0(s1)
20002048:	00000000 	nop
2000204c:	0040f809 	jalr	v0
20002050:	00000000 	nop

20002054 <Hybrid_End_Label>:

			__asm__ volatile(".global Hybrid_End_Label");
			__asm__ volatile("Hybrid_End_Label:");

#if (Config_Logging == TRUE)
			Log_Hybrid_Start(i);
20002054:	0c0009fa 02002021 0c0009ee 02002021     ....! ......! ..
	Log_Tick_Start(current_task);
#endif

	system_time += tick_skip_time;

	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
20002064:	26100001 0215102b 1440ffdb 02140018     ...&+.....@.....
		}
#endif
	}

#if (Config_Logging == TRUE)
	Log_Reset_Addresses();
20002074:	0c000921 00000000 8f840008 8fbf002c     !...........,...
	tick_skip_time = Next_Tick();
	Timer_Set_Match(Config_Scheduler_Timer_Number,
			tick_skip_time * single_tick_time);
#endif
#endif
}
20002084:	8fb60028 8fb50024 8fb40020 8fb3001c     (...$... .......
20002094:	8fb20018 8fb10014 8fb00010 08000a8b     ................
#endif
	}

#if (Config_Logging == TRUE)
	Log_Reset_Addresses();
	Log_Tick_End(current_task);
200020a4:	27bd0030                                0..'

200020a8 <Scheduler_Dispatch>:

// Found in Scheduler_Dispatch, below.
extern void Task_End_Label(void);

void Scheduler_Dispatch(void)
{
200020a8:	27bdffd0 	addiu	sp,sp,-48
200020ac:	afb60028 	sw	s6,40(sp)
200020b0:	afb3001c 	sw	s3,28(sp)
		{
			if (Task_Ready(i, FALSE))
			{
				Tasks[i].delay_counter = Tasks[i].period_reload;
#if (Config_Logging == TRUE)
				Log_Set_Address(FALSE, (uint32_t) Tasks[i].task_function,
200020b4:	3c162000 	lui	s6,0x2000

static inline boolean_t Task_Ready(const uint32_t task_index,
								   TTE_UNUSED const boolean_t in_isr)
{
	// Avoid short-circuiting, to eliminate jitter.
	boolean_t ready = Tasks[task_index].task_function != NULL;
200020b8:	3c134000 	lui	s3,0x4000

// Found in Scheduler_Dispatch, below.
extern void Task_End_Label(void);

void Scheduler_Dispatch(void)
{
200020bc:	afb50024 	sw	s5,36(sp)
200020c0:	afb40020 	sw	s4,32(sp)
200020c4:	afb20018 	sw	s2,24(sp)
200020c8:	afbf002c 	sw	ra,44(sp)
200020cc:	afb10014 	sw	s1,20(sp)
200020d0:	afb00010 	sw	s0,16(sp)
#if (Config_Hardware_Scheduler != TRUE)
	Disable_Interrupt();
200020d4:	0c000ac3 	jal	20002b0c <Disable_Interrupt>
200020d8:	26730058 	addiu	s3,s3,88
		{
			if (Task_Ready(i, FALSE))
			{
				Tasks[i].delay_counter = Tasks[i].period_reload;
#if (Config_Logging == TRUE)
				Log_Set_Address(FALSE, (uint32_t) Tasks[i].task_function,
200020dc:	26d62168 	addiu	s6,s6,8552
{
#if (Config_Hardware_Scheduler != TRUE)
	Disable_Interrupt();
	while (Update_Required())
	{
		for (uint32_t i = 0; i < Config_Num_Tasks; i++)
200020e0:	8f92ffd8 	lw	s2,-40(gp)

static inline boolean_t Task_Ready(const uint32_t task_index,
								   TTE_UNUSED const boolean_t in_isr)
{
	// Avoid short-circuiting, to eliminate jitter.
	boolean_t ready = Tasks[task_index].task_function != NULL;
200020e4:	24150018 	li	s5,24

void Scheduler_Dispatch(void)
{
#if (Config_Hardware_Scheduler != TRUE)
	Disable_Interrupt();
	while (Update_Required())
200020e8:	08000865 	j	20002194 <Task_End_Label+0x2c>
200020ec:	24140003 	li	s4,3
static inline boolean_t Task_Ready(const uint32_t task_index,
								   TTE_UNUSED const boolean_t in_isr)
{
	// Avoid short-circuiting, to eliminate jitter.
	boolean_t ready = Tasks[task_index].task_function != NULL;
	ready &= Tasks[task_index].delay_counter <= 0;
200020f0:	00001012 	mflo	v0
200020f4:	24420001 	addiu	v0,v0,1
200020f8:	000210c0 	sll	v0,v0,0x3

static inline boolean_t Task_Ready(const uint32_t task_index,
								   TTE_UNUSED const boolean_t in_isr)
{
	// Avoid short-circuiting, to eliminate jitter.
	boolean_t ready = Tasks[task_index].task_function != NULL;
200020fc:	02150018 	mult	s0,s5
	ready &= Tasks[task_index].delay_counter <= 0;
20002100:	00531021 	addu	v0,v0,s3

static inline boolean_t Task_Ready(const uint32_t task_index,
								   TTE_UNUSED const boolean_t in_isr)
{
	// Avoid short-circuiting, to eliminate jitter.
	boolean_t ready = Tasks[task_index].task_function != NULL;
20002104:	00008812 	mflo	s1
20002108:	02338821 	addu	s1,s1,s3
2000210c:	8e230000 	lw	v1,0(s1)
	ready &= Tasks[task_index].delay_counter <= 0;
20002110:	8c450000 	lw	a1,0(v0)
#if (Config_Hybrid_Tasks == TRUE)
	ready &= Tasks[task_index].exec_from_isr == in_isr;
20002114:	92240014 	lbu	a0,20(s1)
static inline boolean_t Task_Ready(const uint32_t task_index,
								   TTE_UNUSED const boolean_t in_isr)
{
	// Avoid short-circuiting, to eliminate jitter.
	boolean_t ready = Tasks[task_index].task_function != NULL;
	ready &= Tasks[task_index].delay_counter <= 0;
20002118:	28a50001 	slti	a1,a1,1
2000211c:	0003182b 	sltu	v1,zero,v1
	Disable_Interrupt();
	while (Update_Required())
	{
		for (uint32_t i = 0; i < Config_Num_Tasks; i++)
		{
			if (Task_Ready(i, FALSE))
20002120:	00a31824 	and	v1,a1,v1
20002124:	2c840001 	sltiu	a0,a0,1
20002128:	00641824 	and	v1,v1,a0
2000212c:	10600015 	beqz	v1,20002184 <Task_End_Label+0x1c>
20002130:	00000000 	nop
			{
				Tasks[i].delay_counter = Tasks[i].period_reload;
20002134:	8e230004 	lw	v1,4(s1)
#if (Config_Logging == TRUE)
				Log_Set_Address(FALSE, (uint32_t) Tasks[i].task_function,
20002138:	00002021 	move	a0,zero
	{
		for (uint32_t i = 0; i < Config_Num_Tasks; i++)
		{
			if (Task_Ready(i, FALSE))
			{
				Tasks[i].delay_counter = Tasks[i].period_reload;
2000213c:	ac430000 	sw	v1,0(v0)
#if (Config_Logging == TRUE)
				Log_Set_Address(FALSE, (uint32_t) Tasks[i].task_function,
20002140:	8e250000 	lw	a1,0(s1)
20002144:	0c00093b 	jal	200024ec <Log_Set_Address>
20002148:	02c03021 	move	a2,s6
								(uint32_t) Task_End_Label);
#endif

				current_task = i;
2000214c:	af900008 	sw	s0,8(gp)
				Enable_Interrupt();
20002150:	0c000ab5 	jal	20002ad4 <Enable_Interrupt>
20002154:	00000000 	nop

				(*Tasks[i].task_function)();
20002158:	8e220000 	lw	v0,0(s1)
2000215c:	00000000 	nop
20002160:	0040f809 	jalr	v0
20002164:	00000000 	nop

20002168 <Task_End_Label>:

				__asm__ volatile(".global Task_End_Label");
				__asm__ volatile("Task_End_Label:");

				Disable_Interrupt();
20002168:	0c000ac3 00000000 02002021 0c000a42     ........! ..B...
				current_task = Config_Num_Tasks;

#if (Config_Logging == TRUE)
				Log_Task_Start(i);
20002178:	af920008 0c000a36 02002021 26100001     ....6...! .....&
{
#if (Config_Hardware_Scheduler != TRUE)
	Disable_Interrupt();
	while (Update_Required())
	{
		for (uint32_t i = 0; i < Config_Num_Tasks; i++)
20002188:	0212102b 1440ffd8 02140018 0c000ac3     +.....@.........

static inline boolean_t Update_Required(void)
{
	boolean_t update = FALSE;

	Disable_Interrupt();
20002198:	00000000 8f82000c 00000000 10400005     ..............@.
	if (system_time > 0)
200021a8:	00008021 8f82000c 24100001 2442ffff     !..........$..B$
	{
		update = TRUE;
		system_time--;
200021b8:	af82000c 0c000ab5 00000000 1600fff0     ................

void Scheduler_Dispatch(void)
{
#if (Config_Hardware_Scheduler != TRUE)
	Disable_Interrupt();
	while (Update_Required())
200021c8:	00008021 0c000931 00000000 0c000ab5     !...1...........

#if (Config_Logging == TRUE)
	Log_Idle();
#endif

	Enable_Interrupt();
200021d8:	00000000 8fbf002c 8fb60028 8fb50024     ....,...(...$...
	Enter_Sleep_Mode();
#endif
}
200021e8:	8fb40020 8fb3001c 8fb20018 8fb10014      ...............
200021f8:	8fb00010 080007d4 27bd0030              ........0..'

20002204 <Shutdown_System>:

// Found in the startup.strt assembly file.
extern void Enter_Sleep_Mode(void);

void Shutdown_System(void)
{
20002204:	27bdffe8 	addiu	sp,sp,-24
20002208:	afbf0014 	sw	ra,20(sp)
#if (Config_Hardware_Scheduler == TRUE)
	hwsch_register[0].enable = 0;
#endif

	Disable_Interrupt();
2000220c:	0c000ac3 	jal	20002b0c <Disable_Interrupt>
20002210:	00000000 	nop
	Enter_Sleep_Mode();
}
20002214:	8fbf0014 	lw	ra,20(sp)
#if (Config_Hardware_Scheduler == TRUE)
	hwsch_register[0].enable = 0;
#endif

	Disable_Interrupt();
	Enter_Sleep_Mode();
20002218:	080007d4 	j	20001f50 <Enter_Sleep_Mode>
2000221c:	27bd0018 	addiu	sp,sp,24

20002220 <Scheduler_Start>:
}

///////////////////////////////////////////////////////////////////////////////

void Scheduler_Start(void)
{
20002220:	27bdffe8 	addiu	sp,sp,-24
20002224:	afbf0014 	sw	ra,20(sp)
#if (Config_Logging == TRUE && Config_Hardware_Scheduler != TRUE)
	Log_Init();
20002228:	0c000a4e 	jal	20002938 <Log_Init>
2000222c:	00000000 	nop
		tmrbuf_register[1] = (Config_Log_Buffer_Size / 8) - 1;
	}
	tmrbuf_register[2] = Config_Log_Num_Ticks;
#endif
#else
	Enable_Interrupt();
20002230:	0c000ab5 	jal	20002ad4 <Enable_Interrupt>
20002234:	00000000 	nop
#endif

	Timer_Start(Config_Scheduler_Timer_Number);
}
20002238:	8fbf0014 	lw	ra,20(sp)
#endif
#else
	Enable_Interrupt();
#endif

	Timer_Start(Config_Scheduler_Timer_Number);
2000223c:	00002021 	move	a0,zero
20002240:	08000afd 	j	20002bf4 <Timer_Start>
20002244:	27bd0018 	addiu	sp,sp,24

20002248 <Scheduler_Init>:

///////////////////////////////////////////////////////////////////////////////

void Scheduler_Init(const uint32_t tick_us)
{
	single_tick_time = Timer_Init(Config_Scheduler_Timer_Number, tick_us,
20002248:	3c0602fa 	lui	a2,0x2fa
2000224c:	00802821 	move	a1,a0
#endif

///////////////////////////////////////////////////////////////////////////////

void Scheduler_Init(const uint32_t tick_us)
{
20002250:	27bdffe8 	addiu	sp,sp,-24
	single_tick_time = Timer_Init(Config_Scheduler_Timer_Number, tick_us,
20002254:	00002021 	move	a0,zero
20002258:	34c6f080 	ori	a2,a2,0xf080
#endif

///////////////////////////////////////////////////////////////////////////////

void Scheduler_Init(const uint32_t tick_us)
{
2000225c:	afbf0014 	sw	ra,20(sp)
	single_tick_time = Timer_Init(Config_Scheduler_Timer_Number, tick_us,
20002260:	0c000acd 	jal	20002b34 <Timer_Init>
20002264:	24070001 	li	a3,1
		}
		hwsch_register[i].bvector = (uint32_t) Tasks[i].recovery_task;
		hwsch_register[i].aot = gpt - 1;
	}
#else
	Init_Interrupt();
20002268:	0c000aaa 	jal	20002aa8 <Init_Interrupt>
2000226c:	af820010 	sw	v0,16(gp)
	current_task = Config_Num_Tasks;
20002270:	8f83ffd8 	lw	v1,-40(gp)
	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
	{
		Tasks[i].delay_counter++;
20002274:	3c054000 	lui	a1,0x4000
		hwsch_register[i].bvector = (uint32_t) Tasks[i].recovery_task;
		hwsch_register[i].aot = gpt - 1;
	}
#else
	Init_Interrupt();
	current_task = Config_Num_Tasks;
20002278:	af830008 	sw	v1,8(gp)
	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
	{
		Tasks[i].delay_counter++;
2000227c:	24a50058 	addiu	a1,a1,88
		hwsch_register[i].bvector = (uint32_t) Tasks[i].recovery_task;
		hwsch_register[i].aot = gpt - 1;
	}
#else
	Init_Interrupt();
	current_task = Config_Num_Tasks;
20002280:	00001021 	move	v0,zero
	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
20002284:	080008ac 	j	200022b0 <Scheduler_Init+0x68>
20002288:	24040003 	li	a0,3
2000228c:	24420001 	addiu	v0,v0,1
	{
		Tasks[i].delay_counter++;
20002290:	00003012 	mflo	a2
20002294:	24c60001 	addiu	a2,a2,1
20002298:	000630c0 	sll	a2,a2,0x3
2000229c:	00c53021 	addu	a2,a2,a1
200022a0:	8cc70000 	lw	a3,0(a2)
200022a4:	00000000 	nop
200022a8:	24e70001 	addiu	a3,a3,1
200022ac:	acc70000 	sw	a3,0(a2)
		hwsch_register[i].aot = gpt - 1;
	}
#else
	Init_Interrupt();
	current_task = Config_Num_Tasks;
	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
200022b0:	0043302b 	sltu	a2,v0,v1
200022b4:	14c0fff5 	bnez	a2,2000228c <Scheduler_Init+0x44>
200022b8:	00440018 	mult	v0,a0
	{
		Tasks[i].delay_counter++;
	}
#endif
}
200022bc:	8fbf0014 	lw	ra,20(sp)
200022c0:	00000000 	nop
200022c4:	03e00008 	jr	ra
200022c8:	27bd0018 	addiu	sp,sp,24

200022cc <Write_32>:

///////////////////////////////////////////////////////////////////////////////

void Write_32(const uint32_t value)
{
	Log_Buffer[buffer_index++] = (uint8_t) (value >> 24);
200022cc:	8f820024 	lw	v0,36(gp)
200022d0:	3c034000 	lui	v1,0x4000
200022d4:	246305e8 	addiu	v1,v1,1512
200022d8:	24450001 	addiu	a1,v0,1
200022dc:	00043602 	srl	a2,a0,0x18
200022e0:	00431021 	addu	v0,v0,v1
200022e4:	a0460000 	sb	a2,0(v0)
200022e8:	af850024 	sw	a1,36(gp)
	Log_Buffer[buffer_index++] = (uint8_t) (value >> 16);
200022ec:	8f820024 	lw	v0,36(gp)
200022f0:	00043402 	srl	a2,a0,0x10
200022f4:	24450001 	addiu	a1,v0,1
200022f8:	30c600ff 	andi	a2,a2,0xff
200022fc:	00431021 	addu	v0,v0,v1
20002300:	a0460000 	sb	a2,0(v0)
20002304:	af850024 	sw	a1,36(gp)
	Log_Buffer[buffer_index++] = (uint8_t) (value >> 8);
20002308:	8f820024 	lw	v0,36(gp)
2000230c:	00043202 	srl	a2,a0,0x8
20002310:	24450001 	addiu	a1,v0,1
20002314:	30c600ff 	andi	a2,a2,0xff
20002318:	00431021 	addu	v0,v0,v1
2000231c:	a0460000 	sb	a2,0(v0)
20002320:	af850024 	sw	a1,36(gp)
	Log_Buffer[buffer_index++] = (uint8_t) value;
20002324:	8f820024 	lw	v0,36(gp)
20002328:	308400ff 	andi	a0,a0,0xff
2000232c:	00431821 	addu	v1,v0,v1
20002330:	24420001 	addiu	v0,v0,1
20002334:	a0640000 	sb	a0,0(v1)
20002338:	af820024 	sw	v0,36(gp)
}
2000233c:	03e00008 	jr	ra
20002340:	00000000 	nop

20002344 <Set_Watch>:

///////////////////////////////////////////////////////////////////////////////

void Set_Watch(const uint8_t number, const uint32_t value)
{
20002344:	308400ff 	andi	a0,a0,0xff
	switch (number)
20002348:	24020002 	li	v0,2
2000234c:	10820017 	beq	a0,v0,200023ac <Set_Watch+0x68>
20002350:	2c820003 	sltiu	v0,a0,3
20002354:	10400007 	beqz	v0,20002374 <Set_Watch+0x30>
20002358:	24020004 	li	v0,4
2000235c:	1080000d 	beqz	a0,20002394 <Set_Watch+0x50>
20002360:	24020001 	li	v0,1
20002364:	1482001b 	bne	a0,v0,200023d4 <Set_Watch+0x90>
20002368:	00000000 	nop
2000236c:	080008e8 	j	200023a0 <Set_Watch+0x5c>
20002370:	00000000 	nop
20002374:	10820013 	beq	a0,v0,200023c4 <Set_Watch+0x80>
20002378:	2c820004 	sltiu	v0,a0,4
2000237c:	1440000e 	bnez	v0,200023b8 <Set_Watch+0x74>
20002380:	24020005 	li	v0,5
20002384:	14820013 	bne	a0,v0,200023d4 <Set_Watch+0x90>
20002388:	00000000 	nop
2000238c:	080008f4 	j	200023d0 <Set_Watch+0x8c>
20002390:	00000000 	nop
	{
	case 0:
		__asm__ volatile ("mtc0 %0, $18"::"r"(value));
20002394:	40859000 	mtc0	a1,$18
		break;
20002398:	03e00008 	jr	ra
2000239c:	00000000 	nop
	case 1:
		__asm__ volatile ("mtc0 %0, $19"::"r"(value));
200023a0:	40859800 	mtc0	a1,$19
		break;
200023a4:	03e00008 	jr	ra
200023a8:	00000000 	nop
	case 2:
		__asm__ volatile ("mtc0 %0, $20"::"r"(value));
200023ac:	4085a000 	mtc0	a1,$20
		break;
200023b0:	03e00008 	jr	ra
200023b4:	00000000 	nop
	case 3:
		__asm__ volatile ("mtc0 %0, $21"::"r"(value));
200023b8:	4085a800 	mtc0	a1,$21
		break;
200023bc:	03e00008 	jr	ra
200023c0:	00000000 	nop
	case 4:
		__asm__ volatile ("mtc0 %0, $22"::"r"(value));
200023c4:	4085b000 	mtc0	a1,$22
		break;
200023c8:	03e00008 	jr	ra
200023cc:	00000000 	nop
	case 5:
		__asm__ volatile ("mtc0 %0, $23"::"r"(value));
200023d0:	4085b800 	mtc0	a1,$23
200023d4:	03e00008 	jr	ra
200023d8:	00000000 	nop

200023dc <Get_Watch>:
}

///////////////////////////////////////////////////////////////////////////////

uint32_t Get_Watch(const uint8_t number)
{
200023dc:	308400ff 	andi	a0,a0,0xff
	uint32_t value = 0;

	switch (number)
200023e0:	24020002 	li	v0,2
200023e4:	1082001b 	beq	a0,v0,20002454 <Get_Watch+0x78>
200023e8:	00000000 	nop
200023ec:	2c820003 	sltiu	v0,a0,3
200023f0:	10400008 	beqz	v0,20002414 <Get_Watch+0x38>
200023f4:	24020004 	li	v0,4
200023f8:	10800010 	beqz	a0,2000243c <Get_Watch+0x60>
200023fc:	00000000 	nop
20002400:	24020001 	li	v0,1
20002404:	1482000b 	bne	a0,v0,20002434 <Get_Watch+0x58>
20002408:	00000000 	nop
2000240c:	08000912 	j	20002448 <Get_Watch+0x6c>
20002410:	00000000 	nop
20002414:	10820015 	beq	a0,v0,2000246c <Get_Watch+0x90>
20002418:	00000000 	nop
2000241c:	2c820004 	sltiu	v0,a0,4
20002420:	1440000f 	bnez	v0,20002460 <Get_Watch+0x84>
20002424:	00000000 	nop
20002428:	24020005 	li	v0,5
2000242c:	10820012 	beq	a0,v0,20002478 <Get_Watch+0x9c>
20002430:	00000000 	nop
20002434:	03e00008 	jr	ra
20002438:	00001021 	move	v0,zero
	{
	case 0:
		__asm__ volatile ("mfc0 %0, $18":"=r"(value));
2000243c:	40029000 	mfc0	v0,$18
		break;
20002440:	03e00008 	jr	ra
20002444:	00000000 	nop
	case 1:
		__asm__ volatile ("mfc0 %0, $19":"=r"(value));
20002448:	40029800 	mfc0	v0,$19
		break;
2000244c:	03e00008 	jr	ra
20002450:	00000000 	nop
	case 2:
		__asm__ volatile ("mfc0 %0, $20":"=r"(value));
20002454:	4002a000 	mfc0	v0,$20
		break;
20002458:	03e00008 	jr	ra
2000245c:	00000000 	nop
	case 3:
		__asm__ volatile ("mfc0 %0, $21":"=r"(value));
20002460:	4002a800 	mfc0	v0,$21
		break;
20002464:	03e00008 	jr	ra
20002468:	00000000 	nop
	case 4:
		__asm__ volatile ("mfc0 %0, $22":"=r"(value));
2000246c:	4002b000 	mfc0	v0,$22
		break;
20002470:	03e00008 	jr	ra
20002474:	00000000 	nop
	case 5:
		__asm__ volatile ("mfc0 %0, $23":"=r"(value));
20002478:	4002b800 	mfc0	v0,$23
	default:
		value = 0;
	}

	return value;
}
2000247c:	03e00008 	jr	ra
20002480:	00000000 	nop

20002484 <Log_Reset_Addresses>:
extern void End_IRQ_Ptr(void);
extern void Sleep_Ptr(void);

void Log_Reset_Addresses(void)
{
	Set_Watch(0, 0x20000008);
20002484:	3c052000 	lui	a1,0x2000
// Found in the startup.strt assembly file.
extern void End_IRQ_Ptr(void);
extern void Sleep_Ptr(void);

void Log_Reset_Addresses(void)
{
20002488:	27bdffe8 	addiu	sp,sp,-24
	Set_Watch(0, 0x20000008);
2000248c:	34a50008 	ori	a1,a1,0x8
// Found in the startup.strt assembly file.
extern void End_IRQ_Ptr(void);
extern void Sleep_Ptr(void);

void Log_Reset_Addresses(void)
{
20002490:	afbf0014 	sw	ra,20(sp)
	Set_Watch(0, 0x20000008);
20002494:	0c0008d1 	jal	20002344 <Set_Watch>
20002498:	00002021 	move	a0,zero
	Set_Watch(1, (uint32_t) End_IRQ_Ptr);
2000249c:	3c052000 	lui	a1,0x2000
200024a0:	24a51ee4 	addiu	a1,a1,7908
200024a4:	0c0008d1 	jal	20002344 <Set_Watch>
200024a8:	24040001 	li	a0,1
	Set_Watch(4, (uint32_t) Sleep_Ptr);
200024ac:	3c052000 	lui	a1,0x2000
}
200024b0:	8fbf0014 	lw	ra,20(sp)

void Log_Reset_Addresses(void)
{
	Set_Watch(0, 0x20000008);
	Set_Watch(1, (uint32_t) End_IRQ_Ptr);
	Set_Watch(4, (uint32_t) Sleep_Ptr);
200024b4:	24a51f60 	addiu	a1,a1,8032
200024b8:	24040004 	li	a0,4
200024bc:	080008d1 	j	20002344 <Set_Watch>
200024c0:	27bd0018 	addiu	sp,sp,24

200024c4 <Log_Idle>:
}

///////////////////////////////////////////////////////////////////////////////

void Log_Idle(void)
{
200024c4:	27bdffe8 	addiu	sp,sp,-24
200024c8:	afbf0014 	sw	ra,20(sp)
	Disable_Interrupt();
200024cc:	0c000ac3 	jal	20002b0c <Disable_Interrupt>
200024d0:	00000000 	nop
	idle_index = Config_Num_Tasks;
200024d4:	8f82ffd8 	lw	v0,-40(gp)
	Enable_Interrupt();
}
200024d8:	8fbf0014 	lw	ra,20(sp)
200024dc:	27bd0018 	addiu	sp,sp,24
///////////////////////////////////////////////////////////////////////////////

void Log_Idle(void)
{
	Disable_Interrupt();
	idle_index = Config_Num_Tasks;
200024e0:	af82fff4 	sw	v0,-12(gp)
	Enable_Interrupt();
200024e4:	08000ab5 	j	20002ad4 <Enable_Interrupt>
200024e8:	00000000 	nop

200024ec <Log_Set_Address>:

///////////////////////////////////////////////////////////////////////////////

void Log_Set_Address(const boolean_t in_isr, const uint32_t start,
					 const uint32_t finish)
{
200024ec:	27bdffe0 	addiu	sp,sp,-32
	idle_index = UINT8_MAX;
200024f0:	240200ff 	li	v0,255

///////////////////////////////////////////////////////////////////////////////

void Log_Set_Address(const boolean_t in_isr, const uint32_t start,
					 const uint32_t finish)
{
200024f4:	308400ff 	andi	a0,a0,0xff
200024f8:	afb10018 	sw	s1,24(sp)
200024fc:	afb00014 	sw	s0,20(sp)
20002500:	afbf001c 	sw	ra,28(sp)
	idle_index = UINT8_MAX;
20002504:	af82fff4 	sw	v0,-12(gp)

///////////////////////////////////////////////////////////////////////////////

void Log_Set_Address(const boolean_t in_isr, const uint32_t start,
					 const uint32_t finish)
{
20002508:	00c08021 	move	s0,a2
	idle_index = UINT8_MAX;
	if (in_isr)
2000250c:	1080000a 	beqz	a0,20002538 <Log_Set_Address+0x4c>
20002510:	00a08821 	move	s1,a1
	{
		Set_Watch(1, start);
20002514:	0c0008d1 	jal	20002344 <Set_Watch>
20002518:	24040001 	li	a0,1
		Set_Watch(0, finish);
2000251c:	02002821 	move	a1,s0
		Disable_Interrupt();
		Set_Watch(2, start);
		Set_Watch(3, finish);
		Enable_Interrupt();
	}
}
20002520:	8fbf001c 	lw	ra,28(sp)
20002524:	8fb10018 	lw	s1,24(sp)
20002528:	8fb00014 	lw	s0,20(sp)
{
	idle_index = UINT8_MAX;
	if (in_isr)
	{
		Set_Watch(1, start);
		Set_Watch(0, finish);
2000252c:	00002021 	move	a0,zero
20002530:	080008d1 	j	20002344 <Set_Watch>
20002534:	27bd0020 	addiu	sp,sp,32
	}
	else
	{
		Disable_Interrupt();
20002538:	0c000ac3 	jal	20002b0c <Disable_Interrupt>
2000253c:	00000000 	nop
		Set_Watch(2, start);
20002540:	02202821 	move	a1,s1
20002544:	0c0008d1 	jal	20002344 <Set_Watch>
20002548:	24040002 	li	a0,2
		Set_Watch(3, finish);
2000254c:	02002821 	move	a1,s0
20002550:	0c0008d1 	jal	20002344 <Set_Watch>
20002554:	24040003 	li	a0,3
		Enable_Interrupt();
	}
}
20002558:	8fbf001c 	lw	ra,28(sp)
2000255c:	8fb10018 	lw	s1,24(sp)
20002560:	8fb00014 	lw	s0,20(sp)
	else
	{
		Disable_Interrupt();
		Set_Watch(2, start);
		Set_Watch(3, finish);
		Enable_Interrupt();
20002564:	08000ab5 	j	20002ad4 <Enable_Interrupt>
20002568:	27bd0020 	addiu	sp,sp,32

2000256c <Check_Buffer>:
// Found in the startup.strt assembly file.
extern void LOG_Trigger_Breakpoint(void);

void Check_Buffer(const uint32_t size)
{
	if (Config_Log_Buffer_Size - buffer_index < size + 1)
2000256c:	8f820024 	lw	v0,36(gp)
20002570:	240303e8 	li	v1,1000
20002574:	00621023 	subu	v0,v1,v0
20002578:	24840001 	addiu	a0,a0,1

// Found in the startup.strt assembly file.
extern void LOG_Trigger_Breakpoint(void);

void Check_Buffer(const uint32_t size)
{
2000257c:	27bdffe8 	addiu	sp,sp,-24
	if (Config_Log_Buffer_Size - buffer_index < size + 1)
20002580:	0044102b 	sltu	v0,v0,a0
20002584:	1040000a 	beqz	v0,200025b0 <Check_Buffer+0x44>
20002588:	afbf0014 	sw	ra,20(sp)
	{
		Log_Buffer[buffer_index] = 'z';
2000258c:	8f830024 	lw	v1,36(gp)
20002590:	3c024000 	lui	v0,0x4000
20002594:	244205e8 	addiu	v0,v0,1512
20002598:	00621021 	addu	v0,v1,v0
2000259c:	2403007a 	li	v1,122
200025a0:	a0430000 	sb	v1,0(v0)
		LOG_Trigger_Breakpoint();
200025a4:	0c0007de 	jal	20001f78 <LOG_Trigger_Breakpoint>
200025a8:	00000000 	nop
		buffer_index = 0;
200025ac:	af800024 	sw	zero,36(gp)
	}
}
200025b0:	8fbf0014 	lw	ra,20(sp)
200025b4:	00000000 	nop
200025b8:	03e00008 	jr	ra
200025bc:	27bd0018 	addiu	sp,sp,24

200025c0 <Log_Task_Address>:
}

///////////////////////////////////////////////////////////////////////////////

void Log_Task_Address(const task_function_t task, const uint8_t priority)
{
200025c0:	27bdffe0 	addiu	sp,sp,-32
200025c4:	afb00010 	sw	s0,16(sp)
200025c8:	00808021 	move	s0,a0
	Check_Buffer(7);
200025cc:	24040007 	li	a0,7
}

///////////////////////////////////////////////////////////////////////////////

void Log_Task_Address(const task_function_t task, const uint8_t priority)
{
200025d0:	afbf001c 	sw	ra,28(sp)
200025d4:	afb20018 	sw	s2,24(sp)
200025d8:	afb10014 	sw	s1,20(sp)
200025dc:	30b200ff 	andi	s2,a1,0xff
	Check_Buffer(7);
200025e0:	0c00095b 	jal	2000256c <Check_Buffer>
200025e4:	3c114000 	lui	s1,0x4000

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
200025e8:	8f820024 	lw	v0,36(gp)
200025ec:	263105e8 	addiu	s1,s1,1512
200025f0:	24430001 	addiu	v1,v0,1
200025f4:	24050058 	li	a1,88
200025f8:	00511021 	addu	v0,v0,s1

void Log_Task_Address(const task_function_t task, const uint8_t priority)
{
	Check_Buffer(7);
	Write_8('X');
	Write_32((uint32_t) task);
200025fc:	02002021 	move	a0,s0

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
20002600:	a0450000 	sb	a1,0(v0)
20002604:	af830024 	sw	v1,36(gp)

void Log_Task_Address(const task_function_t task, const uint8_t priority)
{
	Check_Buffer(7);
	Write_8('X');
	Write_32((uint32_t) task);
20002608:	0c0008b3 	jal	200022cc <Write_32>
2000260c:	00000000 	nop

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
20002610:	8f820024 	lw	v0,36(gp)
20002614:	24040070 	li	a0,112
20002618:	24430001 	addiu	v1,v0,1
2000261c:	00511021 	addu	v0,v0,s1
20002620:	a0440000 	sb	a0,0(v0)
20002624:	af830024 	sw	v1,36(gp)
20002628:	8f820024 	lw	v0,36(gp)
2000262c:	00000000 	nop
20002630:	00518821 	addu	s1,v0,s1
20002634:	a2320000 	sb	s2,0(s1)
	Check_Buffer(7);
	Write_8('X');
	Write_32((uint32_t) task);
	Write_8('p');
	Write_8(priority);
}
20002638:	8fbf001c 	lw	ra,28(sp)

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
2000263c:	24420001 	addiu	v0,v0,1
	Check_Buffer(7);
	Write_8('X');
	Write_32((uint32_t) task);
	Write_8('p');
	Write_8(priority);
}
20002640:	8fb20018 	lw	s2,24(sp)
20002644:	8fb10014 	lw	s1,20(sp)
20002648:	8fb00010 	lw	s0,16(sp)

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
2000264c:	af820024 	sw	v0,36(gp)
	Check_Buffer(7);
	Write_8('X');
	Write_32((uint32_t) task);
	Write_8('p');
	Write_8(priority);
}
20002650:	03e00008 	jr	ra
20002654:	27bd0020 	addiu	sp,sp,32

20002658 <Log_ISR_Time>:
///////////////////////////////////////////////////////////////////////////////

void Log_ISR_Time(const log_type_t log_type, const uint32_t task_index,
				  const uint32_t cycle_count)
{
	const uint32_t time = Get_Relative_Time(previous_isr_time, cycle_count);
20002658:	8f82001c 	lw	v0,28(gp)

///////////////////////////////////////////////////////////////////////////////

void Log_ISR_Time(const log_type_t log_type, const uint32_t task_index,
				  const uint32_t cycle_count)
{
2000265c:	27bdffd8 	addiu	sp,sp,-40

///////////////////////////////////////////////////////////////////////////////

uint32_t Get_Relative_Time(const uint32_t first, const uint32_t second)
{
	if (second >= first)
20002660:	00c2182b 	sltu	v1,a2,v0

///////////////////////////////////////////////////////////////////////////////

void Log_ISR_Time(const log_type_t log_type, const uint32_t task_index,
				  const uint32_t cycle_count)
{
20002664:	afb20020 	sw	s2,32(sp)
20002668:	afb1001c 	sw	s1,28(sp)
2000266c:	afb00018 	sw	s0,24(sp)
20002670:	afbf0024 	sw	ra,36(sp)
20002674:	00808021 	move	s0,a0
20002678:	00a08821 	move	s1,a1

///////////////////////////////////////////////////////////////////////////////

uint32_t Get_Relative_Time(const uint32_t first, const uint32_t second)
{
	if (second >= first)
2000267c:	10600003 	beqz	v1,2000268c <Log_ISR_Time+0x34>
20002680:	00c29023 	subu	s2,a2,v0
	{
		return second - first;
	}

	return second + (UINT32_MAX - first);
20002684:	00029027 	nor	s2,zero,v0
20002688:	00d29021 	addu	s2,a2,s2

void Log_ISR_Time(const log_type_t log_type, const uint32_t task_index,
				  const uint32_t cycle_count)
{
	const uint32_t time = Get_Relative_Time(previous_isr_time, cycle_count);
	Check_Buffer(7);
2000268c:	24040007 	li	a0,7
20002690:	0c00095b 	jal	2000256c <Check_Buffer>
20002694:	afa60010 	sw	a2,16(sp)

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
20002698:	8f820024 	lw	v0,36(gp)
2000269c:	3c034000 	lui	v1,0x4000
200026a0:	246305e8 	addiu	v1,v1,1512
200026a4:	24440001 	addiu	a0,v0,1
200026a8:	24050079 	li	a1,121
200026ac:	00431021 	addu	v0,v0,v1
200026b0:	a0450000 	sb	a1,0(v0)
200026b4:	af840024 	sw	a0,36(gp)
200026b8:	8f820024 	lw	v0,36(gp)
				  const uint32_t cycle_count)
{
	const uint32_t time = Get_Relative_Time(previous_isr_time, cycle_count);
	Check_Buffer(7);
	Write_8('y');
	Write_8(task_index);
200026bc:	322500ff 	andi	a1,s1,0xff

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
200026c0:	24440001 	addiu	a0,v0,1
200026c4:	00431021 	addu	v0,v0,v1
200026c8:	a0450000 	sb	a1,0(v0)
200026cc:	af840024 	sw	a0,36(gp)
{
	const uint32_t time = Get_Relative_Time(previous_isr_time, cycle_count);
	Check_Buffer(7);
	Write_8('y');
	Write_8(task_index);
	Write_8(log_char[log_type]);
200026d0:	2782fff8 	addiu	v0,gp,-8
200026d4:	00508021 	addu	s0,v0,s0

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
200026d8:	8f820024 	lw	v0,36(gp)
{
	const uint32_t time = Get_Relative_Time(previous_isr_time, cycle_count);
	Check_Buffer(7);
	Write_8('y');
	Write_8(task_index);
	Write_8(log_char[log_type]);
200026dc:	92050000 	lbu	a1,0(s0)

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
200026e0:	00431821 	addu	v1,v0,v1
	Write_8(task_index);
	Write_8(log_char[log_type]);
	Write_32(time);

	// Update if task_index is not 255; nasty bit-fiddling to avoid branching.
	const int32_t update = task_index != 255;
200026e4:	3a3100ff 	xori	s1,s1,0xff

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
200026e8:	24420001 	addiu	v0,v0,1
200026ec:	a0650000 	sb	a1,0(v1)
	const uint32_t time = Get_Relative_Time(previous_isr_time, cycle_count);
	Check_Buffer(7);
	Write_8('y');
	Write_8(task_index);
	Write_8(log_char[log_type]);
	Write_32(time);
200026f0:	02402021 	move	a0,s2

	// Update if task_index is not 255; nasty bit-fiddling to avoid branching.
	const int32_t update = task_index != 255;
200026f4:	0011882b 	sltu	s1,zero,s1

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
200026f8:	af820024 	sw	v0,36(gp)
	const uint32_t time = Get_Relative_Time(previous_isr_time, cycle_count);
	Check_Buffer(7);
	Write_8('y');
	Write_8(task_index);
	Write_8(log_char[log_type]);
	Write_32(time);
200026fc:	0c0008b3 	jal	200022cc <Write_32>
20002700:	00000000 	nop

	// Update if task_index is not 255; nasty bit-fiddling to avoid branching.
	const int32_t update = task_index != 255;
	const int32_t no_update = !update;
	previous_isr_time = (-update & cycle_count) |
20002704:	3a220001 	xori	v0,s1,0x1
20002708:	8f83001c 	lw	v1,28(gp)
2000270c:	8fa60010 	lw	a2,16(sp)
20002710:	00118823 	negu	s1,s1
20002714:	00021023 	negu	v0,v0
20002718:	02263024 	and	a2,s1,a2
2000271c:	00431024 	and	v0,v0,v1
						(-no_update & previous_isr_time);
}
20002720:	8fbf0024 	lw	ra,36(sp)
	Write_32(time);

	// Update if task_index is not 255; nasty bit-fiddling to avoid branching.
	const int32_t update = task_index != 255;
	const int32_t no_update = !update;
	previous_isr_time = (-update & cycle_count) |
20002724:	00463025 	or	a2,v0,a2
						(-no_update & previous_isr_time);
}
20002728:	8fb20020 	lw	s2,32(sp)
2000272c:	8fb1001c 	lw	s1,28(sp)
20002730:	8fb00018 	lw	s0,24(sp)
	Write_32(time);

	// Update if task_index is not 255; nasty bit-fiddling to avoid branching.
	const int32_t update = task_index != 255;
	const int32_t no_update = !update;
	previous_isr_time = (-update & cycle_count) |
20002734:	af86001c 	sw	a2,28(gp)
						(-no_update & previous_isr_time);
}
20002738:	03e00008 	jr	ra
2000273c:	27bd0028 	addiu	sp,sp,40

20002740 <Log_Tick_Start>:
}

///////////////////////////////////////////////////////////////////////////////

void Log_Tick_Start(const uint32_t task_index)
{
20002740:	27bdffe0 	addiu	sp,sp,-32
	Log_ISR_Time(LOG_INTERRUPT_END, last_index, Get_Watch(1));
20002744:	8f850014 	lw	a1,20(gp)
}

///////////////////////////////////////////////////////////////////////////////

void Log_Tick_Start(const uint32_t task_index)
{
20002748:	afb00018 	sw	s0,24(sp)
2000274c:	00808021 	move	s0,a0
	Log_ISR_Time(LOG_INTERRUPT_END, last_index, Get_Watch(1));
20002750:	24040001 	li	a0,1
}

///////////////////////////////////////////////////////////////////////////////

void Log_Tick_Start(const uint32_t task_index)
{
20002754:	afbf001c 	sw	ra,28(sp)
	Log_ISR_Time(LOG_INTERRUPT_END, last_index, Get_Watch(1));
20002758:	0c0008f7 	jal	200023dc <Get_Watch>
2000275c:	afa50010 	sw	a1,16(sp)
20002760:	8fa50010 	lw	a1,16(sp)
20002764:	00403021 	move	a2,v0
20002768:	0c000996 	jal	20002658 <Log_ISR_Time>
2000276c:	24040003 	li	a0,3
	Log_ISR_Time(LOG_INTERRUPT_END, idle_index, Get_Watch(4));
20002770:	8f85fff4 	lw	a1,-12(gp)
20002774:	24040004 	li	a0,4
20002778:	0c0008f7 	jal	200023dc <Get_Watch>
2000277c:	afa50010 	sw	a1,16(sp)
20002780:	8fa50010 	lw	a1,16(sp)
20002784:	00403021 	move	a2,v0
20002788:	0c000996 	jal	20002658 <Log_ISR_Time>
2000278c:	24040003 	li	a0,3

	last_index = task_index;

	Log_ISR_Time(LOG_INTERRUPT_START, task_index, Get_Watch(0));
20002790:	00002021 	move	a0,zero
20002794:	0c0008f7 	jal	200023dc <Get_Watch>
20002798:	af900014 	sw	s0,20(gp)
2000279c:	00403021 	move	a2,v0
200027a0:	02002821 	move	a1,s0
}
200027a4:	8fbf001c 	lw	ra,28(sp)
200027a8:	8fb00018 	lw	s0,24(sp)
	Log_ISR_Time(LOG_INTERRUPT_END, last_index, Get_Watch(1));
	Log_ISR_Time(LOG_INTERRUPT_END, idle_index, Get_Watch(4));

	last_index = task_index;

	Log_ISR_Time(LOG_INTERRUPT_START, task_index, Get_Watch(0));
200027ac:	24040002 	li	a0,2
200027b0:	08000996 	j	20002658 <Log_ISR_Time>
200027b4:	27bd0020 	addiu	sp,sp,32

200027b8 <Log_Hybrid_End>:
}

///////////////////////////////////////////////////////////////////////////////

void Log_Hybrid_End(const uint32_t task_index)
{
200027b8:	27bdffe0 	addiu	sp,sp,-32
200027bc:	00802821 	move	a1,a0
	Log_ISR_Time(LOG_HYBRID_END, task_index, Get_Watch(0));
200027c0:	00002021 	move	a0,zero
}

///////////////////////////////////////////////////////////////////////////////

void Log_Hybrid_End(const uint32_t task_index)
{
200027c4:	afbf001c 	sw	ra,28(sp)
	Log_ISR_Time(LOG_HYBRID_END, task_index, Get_Watch(0));
200027c8:	0c0008f7 	jal	200023dc <Get_Watch>
200027cc:	afa50010 	sw	a1,16(sp)
200027d0:	8fa50010 	lw	a1,16(sp)
}
200027d4:	8fbf001c 	lw	ra,28(sp)

///////////////////////////////////////////////////////////////////////////////

void Log_Hybrid_End(const uint32_t task_index)
{
	Log_ISR_Time(LOG_HYBRID_END, task_index, Get_Watch(0));
200027d8:	00403021 	move	a2,v0
200027dc:	24040005 	li	a0,5
200027e0:	08000996 	j	20002658 <Log_ISR_Time>
200027e4:	27bd0020 	addiu	sp,sp,32

200027e8 <Log_Hybrid_Start>:
}

///////////////////////////////////////////////////////////////////////////////

void Log_Hybrid_Start(const uint32_t task_index)
{
200027e8:	27bdffe0 	addiu	sp,sp,-32
200027ec:	00802821 	move	a1,a0
	Log_ISR_Time(LOG_HYBRID_START, task_index, Get_Watch(1));
200027f0:	24040001 	li	a0,1
}

///////////////////////////////////////////////////////////////////////////////

void Log_Hybrid_Start(const uint32_t task_index)
{
200027f4:	afbf001c 	sw	ra,28(sp)
	Log_ISR_Time(LOG_HYBRID_START, task_index, Get_Watch(1));
200027f8:	0c0008f7 	jal	200023dc <Get_Watch>
200027fc:	afa50010 	sw	a1,16(sp)
20002800:	8fa50010 	lw	a1,16(sp)
}
20002804:	8fbf001c 	lw	ra,28(sp)

///////////////////////////////////////////////////////////////////////////////

void Log_Hybrid_Start(const uint32_t task_index)
{
	Log_ISR_Time(LOG_HYBRID_START, task_index, Get_Watch(1));
20002808:	00403021 	move	a2,v0
2000280c:	24040004 	li	a0,4
20002810:	08000996 	j	20002658 <Log_ISR_Time>
20002814:	27bd0020 	addiu	sp,sp,32

20002818 <Log_Time>:
///////////////////////////////////////////////////////////////////////////////

void Log_Time(const log_type_t log_type, const uint32_t task_index,
			  const uint32_t cycle_count)
{
	const uint32_t time = Get_Relative_Time(previous_time, cycle_count);
20002818:	8f820018 	lw	v0,24(gp)

///////////////////////////////////////////////////////////////////////////////

void Log_Time(const log_type_t log_type, const uint32_t task_index,
			  const uint32_t cycle_count)
{
2000281c:	27bdffd8 	addiu	sp,sp,-40

///////////////////////////////////////////////////////////////////////////////

uint32_t Get_Relative_Time(const uint32_t first, const uint32_t second)
{
	if (second >= first)
20002820:	00c2182b 	sltu	v1,a2,v0

///////////////////////////////////////////////////////////////////////////////

void Log_Time(const log_type_t log_type, const uint32_t task_index,
			  const uint32_t cycle_count)
{
20002824:	afb10020 	sw	s1,32(sp)
20002828:	afb0001c 	sw	s0,28(sp)
2000282c:	afbf0024 	sw	ra,36(sp)
20002830:	00808021 	move	s0,a0

///////////////////////////////////////////////////////////////////////////////

uint32_t Get_Relative_Time(const uint32_t first, const uint32_t second)
{
	if (second >= first)
20002834:	10600003 	beqz	v1,20002844 <Log_Time+0x2c>
20002838:	00c28823 	subu	s1,a2,v0
	{
		return second - first;
	}

	return second + (UINT32_MAX - first);
2000283c:	00028827 	nor	s1,zero,v0
20002840:	00d18821 	addu	s1,a2,s1

void Log_Time(const log_type_t log_type, const uint32_t task_index,
			  const uint32_t cycle_count)
{
	const uint32_t time = Get_Relative_Time(previous_time, cycle_count);
	Check_Buffer(7);
20002844:	24040007 	li	a0,7
20002848:	afa60014 	sw	a2,20(sp)
2000284c:	0c00095b 	jal	2000256c <Check_Buffer>
20002850:	afa50010 	sw	a1,16(sp)

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
20002854:	8f820024 	lw	v0,36(gp)
20002858:	3c034000 	lui	v1,0x4000
2000285c:	246305e8 	addiu	v1,v1,1512
20002860:	24440001 	addiu	a0,v0,1
20002864:	24070079 	li	a3,121
20002868:	00431021 	addu	v0,v0,v1
2000286c:	a0470000 	sb	a3,0(v0)
20002870:	af840024 	sw	a0,36(gp)
20002874:	8f820024 	lw	v0,36(gp)
			  const uint32_t cycle_count)
{
	const uint32_t time = Get_Relative_Time(previous_time, cycle_count);
	Check_Buffer(7);
	Write_8('y');
	Write_8(task_index);
20002878:	8fa50010 	lw	a1,16(sp)

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
2000287c:	24440001 	addiu	a0,v0,1
			  const uint32_t cycle_count)
{
	const uint32_t time = Get_Relative_Time(previous_time, cycle_count);
	Check_Buffer(7);
	Write_8('y');
	Write_8(task_index);
20002880:	30a500ff 	andi	a1,a1,0xff

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
20002884:	00431021 	addu	v0,v0,v1
20002888:	a0450000 	sb	a1,0(v0)
2000288c:	af840024 	sw	a0,36(gp)
{
	const uint32_t time = Get_Relative_Time(previous_time, cycle_count);
	Check_Buffer(7);
	Write_8('y');
	Write_8(task_index);
	Write_8(log_char[log_type]);
20002890:	2782fff8 	addiu	v0,gp,-8
20002894:	00508021 	addu	s0,v0,s0

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
20002898:	8f820024 	lw	v0,36(gp)
{
	const uint32_t time = Get_Relative_Time(previous_time, cycle_count);
	Check_Buffer(7);
	Write_8('y');
	Write_8(task_index);
	Write_8(log_char[log_type]);
2000289c:	92050000 	lbu	a1,0(s0)

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
200028a0:	00431821 	addu	v1,v0,v1
	const uint32_t time = Get_Relative_Time(previous_time, cycle_count);
	Check_Buffer(7);
	Write_8('y');
	Write_8(task_index);
	Write_8(log_char[log_type]);
	Write_32(time);
200028a4:	02202021 	move	a0,s1

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
200028a8:	24420001 	addiu	v0,v0,1
200028ac:	a0650000 	sb	a1,0(v1)
200028b0:	af820024 	sw	v0,36(gp)
	const uint32_t time = Get_Relative_Time(previous_time, cycle_count);
	Check_Buffer(7);
	Write_8('y');
	Write_8(task_index);
	Write_8(log_char[log_type]);
	Write_32(time);
200028b4:	0c0008b3 	jal	200022cc <Write_32>
200028b8:	00000000 	nop
	previous_time = cycle_count;
200028bc:	8fa60014 	lw	a2,20(sp)
}
200028c0:	8fbf0024 	lw	ra,36(sp)
200028c4:	8fb10020 	lw	s1,32(sp)
200028c8:	8fb0001c 	lw	s0,28(sp)
	Check_Buffer(7);
	Write_8('y');
	Write_8(task_index);
	Write_8(log_char[log_type]);
	Write_32(time);
	previous_time = cycle_count;
200028cc:	af860018 	sw	a2,24(gp)
}
200028d0:	03e00008 	jr	ra
200028d4:	27bd0028 	addiu	sp,sp,40

200028d8 <Log_Task_End>:
}

///////////////////////////////////////////////////////////////////////////////

void Log_Task_End(const uint32_t task_index)
{
200028d8:	27bdffe0 	addiu	sp,sp,-32
200028dc:	00802821 	move	a1,a0
	Log_Time(LOG_TASK_END, task_index, Get_Watch(3));
200028e0:	24040003 	li	a0,3
}

///////////////////////////////////////////////////////////////////////////////

void Log_Task_End(const uint32_t task_index)
{
200028e4:	afbf001c 	sw	ra,28(sp)
	Log_Time(LOG_TASK_END, task_index, Get_Watch(3));
200028e8:	0c0008f7 	jal	200023dc <Get_Watch>
200028ec:	afa50010 	sw	a1,16(sp)
200028f0:	8fa50010 	lw	a1,16(sp)
}
200028f4:	8fbf001c 	lw	ra,28(sp)

///////////////////////////////////////////////////////////////////////////////

void Log_Task_End(const uint32_t task_index)
{
	Log_Time(LOG_TASK_END, task_index, Get_Watch(3));
200028f8:	00403021 	move	a2,v0
200028fc:	24040001 	li	a0,1
20002900:	08000a06 	j	20002818 <Log_Time>
20002904:	27bd0020 	addiu	sp,sp,32

20002908 <Log_Task_Start>:
}

///////////////////////////////////////////////////////////////////////////////

void Log_Task_Start(const uint32_t task_index)
{
20002908:	27bdffe0 	addiu	sp,sp,-32
2000290c:	00802821 	move	a1,a0
	Log_Time(LOG_TASK_START, task_index, Get_Watch(2));
20002910:	24040002 	li	a0,2
}

///////////////////////////////////////////////////////////////////////////////

void Log_Task_Start(const uint32_t task_index)
{
20002914:	afbf001c 	sw	ra,28(sp)
	Log_Time(LOG_TASK_START, task_index, Get_Watch(2));
20002918:	0c0008f7 	jal	200023dc <Get_Watch>
2000291c:	afa50010 	sw	a1,16(sp)
20002920:	8fa50010 	lw	a1,16(sp)
}
20002924:	8fbf001c 	lw	ra,28(sp)

///////////////////////////////////////////////////////////////////////////////

void Log_Task_Start(const uint32_t task_index)
{
	Log_Time(LOG_TASK_START, task_index, Get_Watch(2));
20002928:	00403021 	move	a2,v0
2000292c:	00002021 	move	a0,zero
20002930:	08000a06 	j	20002818 <Log_Time>
20002934:	27bd0020 	addiu	sp,sp,32

20002938 <Log_Init>:
}

///////////////////////////////////////////////////////////////////////////////

void Log_Init(void)
{
20002938:	27bdffd8 	addiu	sp,sp,-40
	Check_Buffer(5);
2000293c:	24040005 	li	a0,5
}

///////////////////////////////////////////////////////////////////////////////

void Log_Init(void)
{
20002940:	afbf0024 	sw	ra,36(sp)
20002944:	afb30020 	sw	s3,32(sp)
20002948:	afb2001c 	sw	s2,28(sp)
2000294c:	afb10018 	sw	s1,24(sp)
	Check_Buffer(5);
20002950:	0c00095b 	jal	2000256c <Check_Buffer>
20002954:	afb00014 	sw	s0,20(sp)

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
20002958:	8f820024 	lw	v0,36(gp)
2000295c:	3c034000 	lui	v1,0x4000
20002960:	246305e8 	addiu	v1,v1,1512
20002964:	00431821 	addu	v1,v0,v1
20002968:	24050057 	li	a1,87

void Log_Init(void)
{
	Check_Buffer(5);
	Write_8('W');
	Write_32(Config_Oscillator_Frequency);
2000296c:	3c0402fa 	lui	a0,0x2fa

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
20002970:	24420001 	addiu	v0,v0,1
20002974:	a0650000 	sb	a1,0(v1)

void Log_Init(void)
{
	Check_Buffer(5);
	Write_8('W');
	Write_32(Config_Oscillator_Frequency);
20002978:	3484f080 	ori	a0,a0,0xf080

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
2000297c:	af820024 	sw	v0,36(gp)

void Log_Init(void)
{
	Check_Buffer(5);
	Write_8('W');
	Write_32(Config_Oscillator_Frequency);
20002980:	0c0008b3 	jal	200022cc <Write_32>
20002984:	3c124000 	lui	s2,0x4000

	last_index = Config_Num_Tasks;
20002988:	8f93ffd8 	lw	s3,-40(gp)
2000298c:	00000000 	nop
20002990:	af930014 	sw	s3,20(gp)

	uint32_t priority = 0;
	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
	{
		if (Tasks[i].exec_from_isr == TRUE)
20002994:	26520058 	addiu	s2,s2,88
{
	Check_Buffer(5);
	Write_8('W');
	Write_32(Config_Oscillator_Frequency);

	last_index = Config_Num_Tasks;
20002998:	00008021 	move	s0,zero

	uint32_t priority = 0;
	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
2000299c:	08000a78 	j	200029e0 <Log_Init+0xa8>
200029a0:	24110018 	li	s1,24
200029a4:	8f850014 	lw	a1,20(gp)
200029a8:	00000000 	nop
	{
		if (Tasks[i].exec_from_isr == TRUE)
		{
			priority = (last_index * 2) - i;
200029ac:	00051040 	sll	v0,a1,0x1
		}
		else
		{
			priority = last_index - i;
200029b0:	00b02823 	subu	a1,a1,s0
		}
		Log_Task_Address(Tasks[i].task_function, priority);
200029b4:	00001812 	mflo	v1
200029b8:	00721821 	addu	v1,v1,s2
	last_index = Config_Num_Tasks;

	uint32_t priority = 0;
	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
	{
		if (Tasks[i].exec_from_isr == TRUE)
200029bc:	90640014 	lbu	a0,20(v1)
200029c0:	00000000 	nop
200029c4:	10800002 	beqz	a0,200029d0 <Log_Init+0x98>
200029c8:	00000000 	nop
		{
			priority = (last_index * 2) - i;
200029cc:	00502823 	subu	a1,v0,s0
		}
		else
		{
			priority = last_index - i;
		}
		Log_Task_Address(Tasks[i].task_function, priority);
200029d0:	8c640000 	lw	a0,0(v1)
200029d4:	0c000970 	jal	200025c0 <Log_Task_Address>
200029d8:	30a500ff 	andi	a1,a1,0xff
	Write_32(Config_Oscillator_Frequency);

	last_index = Config_Num_Tasks;

	uint32_t priority = 0;
	for (uint32_t i = 0; i < Config_Num_Tasks; i++)
200029dc:	26100001 	addiu	s0,s0,1
200029e0:	0213102b 	sltu	v0,s0,s3
200029e4:	1440ffef 	bnez	v0,200029a4 <Log_Init+0x6c>
200029e8:	02110018 	mult	s0,s1
			priority = last_index - i;
		}
		Log_Task_Address(Tasks[i].task_function, priority);
	}

	Log_Reset_Addresses();
200029ec:	0c000921 	jal	20002484 <Log_Reset_Addresses>
200029f0:	00000000 	nop

	previous_time = Get_Watch(0);
200029f4:	0c0008f7 	jal	200023dc <Get_Watch>
200029f8:	00002021 	move	a0,zero
	previous_isr_time = previous_time;
	Log_Time(LOG_TASK_START, last_index, 0);
200029fc:	8f850014 	lw	a1,20(gp)
}
20002a00:	8fbf0024 	lw	ra,36(sp)
20002a04:	8fb30020 	lw	s3,32(sp)
20002a08:	8fb2001c 	lw	s2,28(sp)
20002a0c:	8fb10018 	lw	s1,24(sp)
20002a10:	8fb00014 	lw	s0,20(sp)

	Log_Reset_Addresses();

	previous_time = Get_Watch(0);
	previous_isr_time = previous_time;
	Log_Time(LOG_TASK_START, last_index, 0);
20002a14:	00002021 	move	a0,zero
20002a18:	00003021 	move	a2,zero
}
20002a1c:	27bd0028 	addiu	sp,sp,40
	}

	Log_Reset_Addresses();

	previous_time = Get_Watch(0);
	previous_isr_time = previous_time;
20002a20:	af82001c 	sw	v0,28(gp)
	Log_Time(LOG_TASK_START, last_index, 0);
20002a24:	08000a06 	j	20002818 <Log_Time>
20002a28:	af820018 	sw	v0,24(gp)

20002a2c <Log_Tick_End>:

///////////////////////////////////////////////////////////////////////////////

void Log_Tick_End(const uint32_t task_index)
{
	current_tick++;
20002a2c:	8f820020 	lw	v0,32(gp)
}

///////////////////////////////////////////////////////////////////////////////

void Log_Tick_End(const uint32_t task_index)
{
20002a30:	27bdffe8 	addiu	sp,sp,-24
	current_tick++;
20002a34:	24420001 	addiu	v0,v0,1
	if (current_tick > Config_Log_Num_Ticks)
20002a38:	2c430065 	sltiu	v1,v0,101
}

///////////////////////////////////////////////////////////////////////////////

void Log_Tick_End(const uint32_t task_index)
{
20002a3c:	afb00010 	sw	s0,16(sp)
20002a40:	afbf0014 	sw	ra,20(sp)
20002a44:	00808021 	move	s0,a0
	current_tick++;
	if (current_tick > Config_Log_Num_Ticks)
20002a48:	1460000d 	bnez	v1,20002a80 <Log_Tick_End+0x54>
20002a4c:	af820020 	sw	v0,32(gp)
	{
		Check_Buffer(1);
20002a50:	0c00095b 	jal	2000256c <Check_Buffer>
20002a54:	24040001 	li	a0,1

///////////////////////////////////////////////////////////////////////////////

void Write_8(const uint8_t value)
{
	Log_Buffer[buffer_index++] = value;
20002a58:	8f820024 	lw	v0,36(gp)
20002a5c:	3c034000 	lui	v1,0x4000
20002a60:	246305e8 	addiu	v1,v1,1512
20002a64:	00431821 	addu	v1,v0,v1
20002a68:	24040067 	li	a0,103
20002a6c:	24420001 	addiu	v0,v0,1
20002a70:	a0640000 	sb	a0,0(v1)
20002a74:	af820024 	sw	v0,36(gp)
	current_tick++;
	if (current_tick > Config_Log_Num_Ticks)
	{
		Check_Buffer(1);
		Write_8('g');
		LOG_Trigger_Breakpoint();
20002a78:	0c0007de 	jal	20001f78 <LOG_Trigger_Breakpoint>
20002a7c:	00000000 	nop
	}

	if (task_index >= Config_Num_Tasks)
20002a80:	8f82ffd8 	lw	v0,-40(gp)
20002a84:	00000000 	nop
20002a88:	0202802b 	sltu	s0,s0,v0
20002a8c:	16000002 	bnez	s0,20002a98 <Log_Tick_End+0x6c>
20002a90:	240200ff 	li	v0,255
	{
		idle_index = UINT8_MAX;
20002a94:	af82fff4 	sw	v0,-12(gp)
	}
}
20002a98:	8fbf0014 	lw	ra,20(sp)
20002a9c:	8fb00010 	lw	s0,16(sp)
20002aa0:	03e00008 	jr	ra
20002aa4:	27bd0018 	addiu	sp,sp,24

20002aa8 <Init_Interrupt>:
///////////////////////////////////////////////////////////////////////////////


void Init_Interrupt(void)
{
	TableBase = (uint32_t)InterruptHandler;
20002aa8:	3c022000 	lui	v0,0x2000
20002aac:	24421db4 	addiu	v0,v0,7604
20002ab0:	af82ff98 	sw	v0,-104(gp)
 *
 */
uint32_t Status_Reg_Get()
{
	uint32_t regValue;
	__asm volatile("mfc0 %0, $12" : "=d" (regValue) :);
20002ab4:	40026000 	mfc0	v0,c0_sr
20002ab8:	00000000 	nop
 *
 * \param[in] The value to write.
 */
void Status_Reg_Set(uint32_t value)
{
	__asm volatile("mtc0 %0, $12" :: "d" ((unsigned long)(value)));
20002abc:	34420700 	ori	v0,v0,0x700
20002ac0:	40826000 	mtc0	v0,c0_sr

void Init_Interrupt(void)
{
	TableBase = (uint32_t)InterruptHandler;
	Enable_System_Interrupt(Config_Scheduler_Interrupt_Number);
}
20002ac4:	03e00008 	jr	ra
20002ac8:	00000000 	nop

20002acc <Handle_Interrupts>:

///////////////////////////////////////////////////////////////////////////////

void Handle_Interrupts(void)
{
	Scheduler_Tick();
20002acc:	080007e0 	j	20001f80 <Scheduler_Tick>
20002ad0:	00000000 	nop

20002ad4 <Enable_Interrupt>:

///////////////////////////////////////////////////////////////////////////////

void Enable_Interrupt(void)
{
	if (nesting_level > 0)
20002ad4:	8f820028 	lw	v0,40(gp)
20002ad8:	00000000 	nop
20002adc:	10400005 	beqz	v0,20002af4 <Enable_Interrupt+0x20>
20002ae0:	00000000 	nop
	{
		nesting_level--;
20002ae4:	2442ffff 	addiu	v0,v0,-1
20002ae8:	af820028 	sw	v0,40(gp)
	}

	if (nesting_level == 0)
20002aec:	8f820028 	lw	v0,40(gp)
20002af0:	00000000 	nop
20002af4:	14400003 	bnez	v0,20002b04 <Enable_Interrupt+0x30>
20002af8:	00000000 	nop
	{
		Enable_Interrupts();
20002afc:	080007ba 	j	20001ee8 <Enable_Interrupts>
20002b00:	00000000 	nop
20002b04:	03e00008 	jr	ra
20002b08:	00000000 	nop

20002b0c <Disable_Interrupt>:
}

///////////////////////////////////////////////////////////////////////////////

void Disable_Interrupt(void)
{
20002b0c:	27bdffe8 	addiu	sp,sp,-24
20002b10:	afbf0014 	sw	ra,20(sp)
	Disable_Interrupts();
20002b14:	0c0007c6 	jal	20001f18 <Disable_Interrupts>
20002b18:	00000000 	nop
	nesting_level++;
20002b1c:	8f820028 	lw	v0,40(gp)
}
20002b20:	8fbf0014 	lw	ra,20(sp)
///////////////////////////////////////////////////////////////////////////////

void Disable_Interrupt(void)
{
	Disable_Interrupts();
	nesting_level++;
20002b24:	24420001 	addiu	v0,v0,1
20002b28:	af820028 	sw	v0,40(gp)
}
20002b2c:	03e00008 	jr	ra
20002b30:	27bd0018 	addiu	sp,sp,24

20002b34 <Timer_Init>:
	Timer_Set_Prescalar(timer, 0);
	Timer_Clear(timer);
	Timer_Overflow_Clear(timer);

	const uint32_t clock_frequency = oscillator_frequency;
	const uint32_t timer_frequency = clock_frequency / clock_divider;
20002b34:	14e00002 	bnez	a3,20002b40 <Timer_Init+0xc>
20002b38:	00c7001b 	divu	zero,a2,a3
20002b3c:	0007000d 	break	0x7

///////////////////////////////////////////////////////////////////////////////

uint32_t Timer_Init(const uint8_t timer, const uint32_t tick_us,
		const uint32_t oscillator_frequency, const uint32_t clock_divider)
{
20002b40:	308400ff 	andi	a0,a0,0xff

///////////////////////////////////////////////////////////////////////////////

void Timer_Stop(const uint8_t timer)
{
	timer_register[timer].control &= ~control_start;
20002b44:	3c028000 	lui	v0,0x8000
20002b48:	00042200 	sll	a0,a0,0x8
20002b4c:	00822021 	addu	a0,a0,v0
20002b50:	8c870000 	lw	a3,0(a0)
20002b54:	2402fffe 	li	v0,-2
20002b58:	00e21024 	and	v0,a3,v0
20002b5c:	ac820000 	sw	v0,0(a0)
///////////////////////////////////////////////////////////////////////////////

void Timer_Set_Prescalar(const uint8_t timer, const uint32_t prescalar)
{
	const uint32_t value = prescalar > 0 ? prescalar - 1 : 0;
	timer_register[timer].prescalar_match = value;
20002b60:	ac800008 	sw	zero,8(a0)

///////////////////////////////////////////////////////////////////////////////

void Timer_Clear(const uint8_t timer)
{
	timer_register[timer].timer_counter = 0;
20002b64:	ac80000c 	sw	zero,12(a0)

///////////////////////////////////////////////////////////////////////////////

void Timer_Overflow_Clear(const uint8_t timer)
{
	timer_register[timer].control &= ~control_overflow;
20002b68:	8c870000 	lw	a3,0(a0)
	Timer_Clear(timer);
	Timer_Overflow_Clear(timer);

	const uint32_t clock_frequency = oscillator_frequency;
	const uint32_t timer_frequency = clock_frequency / clock_divider;
	Timer_Set_Prescalar(timer, timer_frequency / 1000000);
20002b6c:	3c06000f 	lui	a2,0xf

///////////////////////////////////////////////////////////////////////////////

void Timer_Overflow_Clear(const uint8_t timer)
{
	timer_register[timer].control &= ~control_overflow;
20002b70:	2402fffd 	li	v0,-3
20002b74:	00e21024 	and	v0,a3,v0
	Timer_Clear(timer);
	Timer_Overflow_Clear(timer);

	const uint32_t clock_frequency = oscillator_frequency;
	const uint32_t timer_frequency = clock_frequency / clock_divider;
	Timer_Set_Prescalar(timer, timer_frequency / 1000000);
20002b78:	34c64240 	ori	a2,a2,0x4240

///////////////////////////////////////////////////////////////////////////////

void Timer_Overflow_Clear(const uint8_t timer)
{
	timer_register[timer].control &= ~control_overflow;
20002b7c:	ac820000 	sw	v0,0(a0)
	Timer_Set_Prescalar(timer, 0);
	Timer_Clear(timer);
	Timer_Overflow_Clear(timer);

	const uint32_t clock_frequency = oscillator_frequency;
	const uint32_t timer_frequency = clock_frequency / clock_divider;
20002b80:	00001812 	mflo	v1
	...
	Timer_Set_Prescalar(timer, timer_frequency / 1000000);

	const uint32_t match = timer_frequency / (timer_frequency / tick_us);
20002b8c:	14a00002 	bnez	a1,20002b98 <Timer_Init+0x64>
20002b90:	0065001b 	divu	zero,v1,a1
20002b94:	0007000d 	break	0x7
20002b98:	00002812 	mflo	a1
	...
20002ba4:	14a00002 	bnez	a1,20002bb0 <Timer_Init+0x7c>
20002ba8:	0065001b 	divu	zero,v1,a1
20002bac:	0007000d 	break	0x7
20002bb0:	00001012 	mflo	v0

///////////////////////////////////////////////////////////////////////////////

void Timer_Set_Match(const uint8_t timer, const uint32_t match)
{
	const uint32_t value = match > 0 ? match - 1 : 0;
20002bb4:	0002282b 	sltu	a1,zero,v0
20002bb8:	00052823 	negu	a1,a1
	Timer_Clear(timer);
	Timer_Overflow_Clear(timer);

	const uint32_t clock_frequency = oscillator_frequency;
	const uint32_t timer_frequency = clock_frequency / clock_divider;
	Timer_Set_Prescalar(timer, timer_frequency / 1000000);
20002bbc:	14c00002 	bnez	a2,20002bc8 <Timer_Init+0x94>
20002bc0:	0066001b 	divu	zero,v1,a2
20002bc4:	0007000d 	break	0x7

///////////////////////////////////////////////////////////////////////////////

void Timer_Set_Match(const uint8_t timer, const uint32_t match)
{
	const uint32_t value = match > 0 ? match - 1 : 0;
20002bc8:	2447ffff 	addiu	a3,v0,-1
20002bcc:	00e53824 	and	a3,a3,a1
	Timer_Clear(timer);
	Timer_Overflow_Clear(timer);

	const uint32_t clock_frequency = oscillator_frequency;
	const uint32_t timer_frequency = clock_frequency / clock_divider;
	Timer_Set_Prescalar(timer, timer_frequency / 1000000);
20002bd0:	00001812 	mflo	v1

///////////////////////////////////////////////////////////////////////////////

void Timer_Set_Prescalar(const uint8_t timer, const uint32_t prescalar)
{
	const uint32_t value = prescalar > 0 ? prescalar - 1 : 0;
20002bd4:	0003282b 	sltu	a1,zero,v1
20002bd8:	00052823 	negu	a1,a1
20002bdc:	2463ffff 	addiu	v1,v1,-1
20002be0:	00651824 	and	v1,v1,a1
	timer_register[timer].prescalar_match = value;
20002be4:	ac830008 	sw	v1,8(a0)
///////////////////////////////////////////////////////////////////////////////

void Timer_Set_Match(const uint8_t timer, const uint32_t match)
{
	const uint32_t value = match > 0 ? match - 1 : 0;
	timer_register[timer].timer_match = value;
20002be8:	ac870010 	sw	a3,16(a0)

	const uint32_t match = timer_frequency / (timer_frequency / tick_us);
	Timer_Set_Match(timer, match);

	return match;
}
20002bec:	03e00008 	jr	ra
20002bf0:	00000000 	nop

20002bf4 <Timer_Start>:
}

///////////////////////////////////////////////////////////////////////////////

void Timer_Start(const uint8_t timer)
{
20002bf4:	308400ff 	andi	a0,a0,0xff
	timer_register[timer].control |= control_start;
20002bf8:	3c028000 	lui	v0,0x8000
20002bfc:	00042200 	sll	a0,a0,0x8
20002c00:	00822021 	addu	a0,a0,v0
20002c04:	8c820000 	lw	v0,0(a0)
20002c08:	00000000 	nop
20002c0c:	34420001 	ori	v0,v0,0x1
20002c10:	ac820000 	sw	v0,0(a0)
}
20002c14:	03e00008 	jr	ra
20002c18:	00000000 	nop

20002c1c <SPI_Init>:
static const uint32_t control_cpol     = (1 << 2);

///////////////////////////////////////////////////////////////////////////////

void SPI_Init(const uint8_t spi, const uint32_t mode, const uint32_t clock_divider)
{
20002c1c:	308400ff 	andi	a0,a0,0xff
	spi_register[spi].control = ((mode & 0x03) << 1);
20002c20:	3c028000 	lui	v0,0x8000
20002c24:	34420a00 	ori	v0,v0,0xa00
20002c28:	00042200 	sll	a0,a0,0x8
20002c2c:	00822021 	addu	a0,a0,v0
20002c30:	30a50003 	andi	a1,a1,0x3
	spi_register[spi].clk_div = clock_divider & 0xFFFFFFFC;
20002c34:	2402fffc 	li	v0,-4
20002c38:	00c21024 	and	v0,a2,v0

///////////////////////////////////////////////////////////////////////////////

void SPI_Init(const uint8_t spi, const uint32_t mode, const uint32_t clock_divider)
{
	spi_register[spi].control = ((mode & 0x03) << 1);
20002c3c:	00052840 	sll	a1,a1,0x1
20002c40:	ac850000 	sw	a1,0(a0)
	spi_register[spi].clk_div = clock_divider & 0xFFFFFFFC;
20002c44:	ac820004 	sw	v0,4(a0)
}
20002c48:	03e00008 	jr	ra
20002c4c:	00000000 	nop

20002c50 <SPI_Swap>:
}

///////////////////////////////////////////////////////////////////////////////

uint8_t SPI_Swap(const uint8_t spi, const uint8_t data)
{
20002c50:	308400ff 	andi	a0,a0,0xff

///////////////////////////////////////////////////////////////////////////////

boolean_t SPI_Ready(const uint8_t spi)
{
	return spi_register[spi].control & 0x01;
20002c54:	3c028000 	lui	v0,0x8000
20002c58:	00042200 	sll	a0,a0,0x8
20002c5c:	34420a00 	ori	v0,v0,0xa00
20002c60:	00822021 	addu	a0,a0,v0
}

///////////////////////////////////////////////////////////////////////////////

uint8_t SPI_Swap(const uint8_t spi, const uint8_t data)
{
20002c64:	30a500ff 	andi	a1,a1,0xff

///////////////////////////////////////////////////////////////////////////////

boolean_t SPI_Ready(const uint8_t spi)
{
	return spi_register[spi].control & 0x01;
20002c68:	8c820000 	lw	v0,0(a0)
20002c6c:	00000000 	nop

///////////////////////////////////////////////////////////////////////////////

uint8_t SPI_Swap(const uint8_t spi, const uint8_t data)
{
	while(!SPI_Ready(spi));
20002c70:	30420001 	andi	v0,v0,0x1
20002c74:	1040fffc 	beqz	v0,20002c68 <SPI_Swap+0x18>
20002c78:	00000000 	nop
	spi_register[spi].data = data;
20002c7c:	ac850008 	sw	a1,8(a0)

///////////////////////////////////////////////////////////////////////////////

boolean_t SPI_Ready(const uint8_t spi)
{
	return spi_register[spi].control & 0x01;
20002c80:	8c820000 	lw	v0,0(a0)
20002c84:	00000000 	nop

uint8_t SPI_Swap(const uint8_t spi, const uint8_t data)
{
	while(!SPI_Ready(spi));
	spi_register[spi].data = data;
	while(!SPI_Ready(spi));
20002c88:	30420001 	andi	v0,v0,0x1
20002c8c:	1040fffc 	beqz	v0,20002c80 <SPI_Swap+0x30>
20002c90:	00000000 	nop
	return spi_register[spi].data;
20002c94:	8c820008 	lw	v0,8(a0)
}
20002c98:	03e00008 	jr	ra
20002c9c:	304200ff 	andi	v0,v0,0xff

20002ca0 <Segment_Clear_Decimal>:
}

///////////////////////////////////////////////////////////////////////////////

void Segment_Clear_Decimal(const segment_digit_t digit)
{
20002ca0:	27bdffe0 	addiu	sp,sp,-32
20002ca4:	afb10018 	sw	s1,24(sp)
20002ca8:	afb00014 	sw	s0,20(sp)
20002cac:	3091ffff 	andi	s1,a0,0xffff
20002cb0:	309000ff 	andi	s0,a0,0xff
20002cb4:	afbf001c 	sw	ra,28(sp)
20002cb8:	a7a40020 	sh	a0,32(sp)
	TTE_DEBUG_ASSERT(digit.segment < 1);
20002cbc:	12000005 	beqz	s0,20002cd4 <Segment_Clear_Decimal+0x34>
20002cc0:	00118a02 	srl	s1,s1,0x8
20002cc4:	3c044000 	lui	a0,0x4000
20002cc8:	24840000 	addiu	a0,a0,0
20002ccc:	0c000056 	jal	20000158 <DEBUG_Assert_Failed>
20002cd0:	24050056 	li	a1,86
	TTE_DEBUG_ASSERT(digit.digit < 4);
20002cd4:	2e220004 	sltiu	v0,s1,4
20002cd8:	14400006 	bnez	v0,20002cf4 <Segment_Clear_Decimal+0x54>
20002cdc:	3c024000 	lui	v0,0x4000
20002ce0:	3c044000 	lui	a0,0x4000
20002ce4:	24840000 	addiu	a0,a0,0
20002ce8:	0c000056 	jal	20000158 <DEBUG_Assert_Failed>
20002cec:	24050057 	li	a1,87

	segment_register[digit.segment].decimals &= ~segment_decimal[digit.digit];
20002cf0:	3c024000 	lui	v0,0x4000
20002cf4:	24420028 	addiu	v0,v0,40
20002cf8:	00118880 	sll	s1,s1,0x2
20002cfc:	02228821 	addu	s1,s1,v0
20002d00:	3c028000 	lui	v0,0x8000
20002d04:	34420900 	ori	v0,v0,0x900
20002d08:	00108200 	sll	s0,s0,0x8
20002d0c:	02028021 	addu	s0,s0,v0
20002d10:	8e220000 	lw	v0,0(s1)
20002d14:	8e030008 	lw	v1,8(s0)
20002d18:	00021027 	nor	v0,zero,v0
}
20002d1c:	8fbf001c 	lw	ra,28(sp)
void Segment_Clear_Decimal(const segment_digit_t digit)
{
	TTE_DEBUG_ASSERT(digit.segment < 1);
	TTE_DEBUG_ASSERT(digit.digit < 4);

	segment_register[digit.segment].decimals &= ~segment_decimal[digit.digit];
20002d20:	00431024 	and	v0,v0,v1
20002d24:	ae020008 	sw	v0,8(s0)
}
20002d28:	8fb10018 	lw	s1,24(sp)
20002d2c:	8fb00014 	lw	s0,20(sp)
20002d30:	03e00008 	jr	ra
20002d34:	27bd0020 	addiu	sp,sp,32

20002d38 <Segment_Set_Decimal>:
}

///////////////////////////////////////////////////////////////////////////////

void Segment_Set_Decimal(const segment_digit_t digit)
{
20002d38:	27bdffe0 	addiu	sp,sp,-32
20002d3c:	afb10018 	sw	s1,24(sp)
20002d40:	afb00014 	sw	s0,20(sp)
20002d44:	309100ff 	andi	s1,a0,0xff
20002d48:	3090ffff 	andi	s0,a0,0xffff
20002d4c:	afbf001c 	sw	ra,28(sp)
20002d50:	a7a40020 	sh	a0,32(sp)
	TTE_DEBUG_ASSERT(digit.segment < 1);
20002d54:	12200005 	beqz	s1,20002d6c <Segment_Set_Decimal+0x34>
20002d58:	00108202 	srl	s0,s0,0x8
20002d5c:	3c044000 	lui	a0,0x4000
20002d60:	24840000 	addiu	a0,a0,0
20002d64:	0c000056 	jal	20000158 <DEBUG_Assert_Failed>
20002d68:	2405004c 	li	a1,76
	TTE_DEBUG_ASSERT(digit.digit < 4);
20002d6c:	2e020004 	sltiu	v0,s0,4
20002d70:	14400006 	bnez	v0,20002d8c <Segment_Set_Decimal+0x54>
20002d74:	3c028000 	lui	v0,0x8000
20002d78:	3c044000 	lui	a0,0x4000
20002d7c:	24840000 	addiu	a0,a0,0
20002d80:	0c000056 	jal	20000158 <DEBUG_Assert_Failed>
20002d84:	2405004d 	li	a1,77

	segment_register[digit.segment].decimals |= segment_decimal[digit.digit];
20002d88:	3c028000 	lui	v0,0x8000
20002d8c:	34420900 	ori	v0,v0,0x900
20002d90:	00118a00 	sll	s1,s1,0x8
20002d94:	02228821 	addu	s1,s1,v0
20002d98:	3c024000 	lui	v0,0x4000
20002d9c:	24420028 	addiu	v0,v0,40
20002da0:	00108080 	sll	s0,s0,0x2
20002da4:	02028021 	addu	s0,s0,v0
20002da8:	8e230008 	lw	v1,8(s1)
20002dac:	8e020000 	lw	v0,0(s0)
}
20002db0:	8fbf001c 	lw	ra,28(sp)
void Segment_Set_Decimal(const segment_digit_t digit)
{
	TTE_DEBUG_ASSERT(digit.segment < 1);
	TTE_DEBUG_ASSERT(digit.digit < 4);

	segment_register[digit.segment].decimals |= segment_decimal[digit.digit];
20002db4:	00621025 	or	v0,v1,v0
20002db8:	ae220008 	sw	v0,8(s1)
}
20002dbc:	8fb00014 	lw	s0,20(sp)
20002dc0:	8fb10018 	lw	s1,24(sp)
20002dc4:	03e00008 	jr	ra
20002dc8:	27bd0020 	addiu	sp,sp,32

20002dcc <Segment_Write>:
}

///////////////////////////////////////////////////////////////////////////////

void Segment_Write(const segment_digit_t digit, const uint8_t value)
{
20002dcc:	27bdffe0 	addiu	sp,sp,-32
20002dd0:	afb10014 	sw	s1,20(sp)
20002dd4:	afb00010 	sw	s0,16(sp)
20002dd8:	3091ffff 	andi	s1,a0,0xffff
20002ddc:	309000ff 	andi	s0,a0,0xff
20002de0:	afb20018 	sw	s2,24(sp)
20002de4:	afbf001c 	sw	ra,28(sp)
20002de8:	a7a40020 	sh	a0,32(sp)
20002dec:	30b200ff 	andi	s2,a1,0xff
	TTE_DEBUG_ASSERT(digit.segment < 1);
20002df0:	12000005 	beqz	s0,20002e08 <Segment_Write+0x3c>
20002df4:	00118a02 	srl	s1,s1,0x8
20002df8:	3c044000 	lui	a0,0x4000
20002dfc:	24840000 	addiu	a0,a0,0
20002e00:	0c000056 	jal	20000158 <DEBUG_Assert_Failed>
20002e04:	24050041 	li	a1,65
	TTE_DEBUG_ASSERT(digit.digit < 4);
20002e08:	2e220004 	sltiu	v0,s1,4
20002e0c:	14400006 	bnez	v0,20002e28 <Segment_Write+0x5c>
20002e10:	3c024000 	lui	v0,0x4000
20002e14:	3c044000 	lui	a0,0x4000
20002e18:	24840000 	addiu	a0,a0,0
20002e1c:	0c000056 	jal	20000158 <DEBUG_Assert_Failed>
20002e20:	24050042 	li	a1,66

	segment_register[digit.segment].values &= ~segment_value[digit.digit];
20002e24:	3c024000 	lui	v0,0x4000
20002e28:	00118880 	sll	s1,s1,0x2
20002e2c:	24420038 	addiu	v0,v0,56
20002e30:	3c038000 	lui	v1,0x8000
20002e34:	02221021 	addu	v0,s1,v0
20002e38:	34630900 	ori	v1,v1,0x900
20002e3c:	00108200 	sll	s0,s0,0x8
20002e40:	02038021 	addu	s0,s0,v1
20002e44:	8c420000 	lw	v0,0(v0)
20002e48:	8e030004 	lw	v1,4(s0)
20002e4c:	00021027 	nor	v0,zero,v0
20002e50:	00431024 	and	v0,v0,v1
20002e54:	ae020004 	sw	v0,4(s0)
	segment_register[digit.segment].values |= (value << (digit.digit * 4));
20002e58:	8e020004 	lw	v0,4(s0)
20002e5c:	02328804 	sllv	s1,s2,s1
}
20002e60:	8fbf001c 	lw	ra,28(sp)
{
	TTE_DEBUG_ASSERT(digit.segment < 1);
	TTE_DEBUG_ASSERT(digit.digit < 4);

	segment_register[digit.segment].values &= ~segment_value[digit.digit];
	segment_register[digit.segment].values |= (value << (digit.digit * 4));
20002e64:	02228825 	or	s1,s1,v0
20002e68:	ae110004 	sw	s1,4(s0)
}
20002e6c:	8fb20018 	lw	s2,24(sp)
20002e70:	8fb10014 	lw	s1,20(sp)
20002e74:	8fb00010 	lw	s0,16(sp)
20002e78:	03e00008 	jr	ra
20002e7c:	27bd0020 	addiu	sp,sp,32

20002e80 <Segment_Enable>:
											(1 << 2), (1 << 3) };

///////////////////////////////////////////////////////////////////////////////

void Segment_Enable(const segment_digit_t digit)
{
20002e80:	27bdffe0 	addiu	sp,sp,-32
20002e84:	afb10018 	sw	s1,24(sp)
20002e88:	afb00014 	sw	s0,20(sp)
20002e8c:	309100ff 	andi	s1,a0,0xff
20002e90:	3090ffff 	andi	s0,a0,0xffff
20002e94:	afbf001c 	sw	ra,28(sp)
20002e98:	a7a40020 	sh	a0,32(sp)
	TTE_DEBUG_ASSERT(digit.segment < 1);
20002e9c:	12200005 	beqz	s1,20002eb4 <Segment_Enable+0x34>
20002ea0:	00108202 	srl	s0,s0,0x8
20002ea4:	3c044000 	lui	a0,0x4000
20002ea8:	24840000 	addiu	a0,a0,0
20002eac:	0c000056 	jal	20000158 <DEBUG_Assert_Failed>
20002eb0:	2405002d 	li	a1,45
	TTE_DEBUG_ASSERT(digit.digit < 4);
20002eb4:	2e020004 	sltiu	v0,s0,4
20002eb8:	14400006 	bnez	v0,20002ed4 <Segment_Enable+0x54>
20002ebc:	3c028000 	lui	v0,0x8000
20002ec0:	3c044000 	lui	a0,0x4000
20002ec4:	24840000 	addiu	a0,a0,0
20002ec8:	0c000056 	jal	20000158 <DEBUG_Assert_Failed>
20002ecc:	2405002e 	li	a1,46

	segment_register[digit.segment].enabled |= segment_enabled[digit.digit];
20002ed0:	3c028000 	lui	v0,0x8000
20002ed4:	34420900 	ori	v0,v0,0x900
20002ed8:	00118a00 	sll	s1,s1,0x8
20002edc:	02228821 	addu	s1,s1,v0
20002ee0:	3c024000 	lui	v0,0x4000
20002ee4:	24420048 	addiu	v0,v0,72
20002ee8:	00108080 	sll	s0,s0,0x2
20002eec:	02028021 	addu	s0,s0,v0
20002ef0:	8e230000 	lw	v1,0(s1)
20002ef4:	8e020000 	lw	v0,0(s0)
}
20002ef8:	8fbf001c 	lw	ra,28(sp)
void Segment_Enable(const segment_digit_t digit)
{
	TTE_DEBUG_ASSERT(digit.segment < 1);
	TTE_DEBUG_ASSERT(digit.digit < 4);

	segment_register[digit.segment].enabled |= segment_enabled[digit.digit];
20002efc:	00621025 	or	v0,v1,v0
20002f00:	ae220000 	sw	v0,0(s1)
}
20002f04:	8fb00014 	lw	s0,20(sp)
20002f08:	8fb10018 	lw	s1,24(sp)
20002f0c:	03e00008 	jr	ra
20002f10:	27bd0020 	addiu	sp,sp,32

20002f14 <Device_Add>:
20002f14:	3c034000 	lui	v1,0x4000
20002f18:	8c6501cc 	lw	a1,460(v1)
20002f1c:	00000000 	nop
20002f20:	14a00004 	bnez	a1,20002f34 <Device_Add+0x20>
20002f24:	2402ffff 	li	v0,-1
20002f28:	ac6401cc 	sw	a0,460(v1)
20002f2c:	00001021 	move	v0,zero
20002f30:	3c034000 	lui	v1,0x4000
20002f34:	246301cc 	addiu	v1,v1,460
20002f38:	8c650004 	lw	a1,4(v1)
20002f3c:	00000000 	nop
20002f40:	14a00003 	bnez	a1,20002f50 <Device_Add+0x3c>
20002f44:	00000000 	nop
20002f48:	ac640004 	sw	a0,4(v1)
20002f4c:	24020001 	li	v0,1
20002f50:	3c034000 	lui	v1,0x4000
20002f54:	246301cc 	addiu	v1,v1,460
20002f58:	8c650008 	lw	a1,8(v1)
20002f5c:	00000000 	nop
20002f60:	14a00003 	bnez	a1,20002f70 <Device_Add+0x5c>
20002f64:	00000000 	nop
20002f68:	ac640008 	sw	a0,8(v1)
20002f6c:	24020002 	li	v0,2
20002f70:	3c034000 	lui	v1,0x4000
20002f74:	246301cc 	addiu	v1,v1,460
20002f78:	8c65000c 	lw	a1,12(v1)
20002f7c:	00000000 	nop
20002f80:	14a00003 	bnez	a1,20002f90 <Device_Add+0x7c>
20002f84:	00000000 	nop
20002f88:	ac64000c 	sw	a0,12(v1)
20002f8c:	24020003 	li	v0,3
20002f90:	03e00008 	jr	ra
20002f94:	00000000 	nop
